// Package portonev2client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package portonev2client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerJwtScopes = "bearerJwt.Scopes"
	PortOneScopes   = "portOne.Scopes"
)

// Defines values for B2bBulkTaxInvoiceSourceType.
const (
	PLATFORM B2bBulkTaxInvoiceSourceType = "PLATFORM"
	SHEET    B2bBulkTaxInvoiceSourceType = "SHEET"
)

// Defines values for B2bBulkTaxInvoiceStatus.
const (
	B2bBulkTaxInvoiceStatusCANCELLED      B2bBulkTaxInvoiceStatus = "CANCELLED"
	B2bBulkTaxInvoiceStatusCOMPLETED      B2bBulkTaxInvoiceStatus = "COMPLETED"
	B2bBulkTaxInvoiceStatusDRAFTED        B2bBulkTaxInvoiceStatus = "DRAFTED"
	B2bBulkTaxInvoiceStatusDRAFTPENDING   B2bBulkTaxInvoiceStatus = "DRAFT_PENDING"
	B2bBulkTaxInvoiceStatusFAILED         B2bBulkTaxInvoiceStatus = "FAILED"
	B2bBulkTaxInvoiceStatusINPROGRESS     B2bBulkTaxInvoiceStatus = "IN_PROGRESS"
	B2bBulkTaxInvoiceStatusISSUEPENDING   B2bBulkTaxInvoiceStatus = "ISSUE_PENDING"
	B2bBulkTaxInvoiceStatusREQUESTPENDING B2bBulkTaxInvoiceStatus = "REQUEST_PENDING"
)

// Defines values for B2bCompanyStateBusinessStatus.
const (
	B2bCompanyStateBusinessStatusCLOSED     B2bCompanyStateBusinessStatus = "CLOSED"
	B2bCompanyStateBusinessStatusINBUSINESS B2bCompanyStateBusinessStatus = "IN_BUSINESS"
	B2bCompanyStateBusinessStatusSUSPENDED  B2bCompanyStateBusinessStatus = "SUSPENDED"
)

// Defines values for B2bSearchDateType.
const (
	ISSUE    B2bSearchDateType = "ISSUE"
	REGISTER B2bSearchDateType = "REGISTER"
	WRITE    B2bSearchDateType = "WRITE"
)

// Defines values for B2bTaxInvoiceDocumentModificationType.
const (
	B2bTaxInvoiceDocumentModificationTypeMODIFICATION B2bTaxInvoiceDocumentModificationType = "MODIFICATION"
	B2bTaxInvoiceDocumentModificationTypeNORMAL       B2bTaxInvoiceDocumentModificationType = "NORMAL"
)

// Defines values for B2bTaxInvoiceIssuanceType.
const (
	B2bTaxInvoiceIssuanceTypeNORMAL  B2bTaxInvoiceIssuanceType = "NORMAL"
	B2bTaxInvoiceIssuanceTypeREVERSE B2bTaxInvoiceIssuanceType = "REVERSE"
)

// Defines values for B2bTaxInvoiceKeyType.
const (
	RECIPIENT    B2bTaxInvoiceKeyType = "RECIPIENT"
	SUPPLIER     B2bTaxInvoiceKeyType = "SUPPLIER"
	TAXINVOICEID B2bTaxInvoiceKeyType = "TAX_INVOICE_ID"
)

// Defines values for B2bTaxInvoiceModificationType.
const (
	CANCELLATIONOFCONTRACT      B2bTaxInvoiceModificationType = "CANCELLATION_OF_CONTRACT"
	CHANGEINSUPPLYCOST          B2bTaxInvoiceModificationType = "CHANGE_IN_SUPPLY_COST"
	CORRECTIONOFENTRYERRORS     B2bTaxInvoiceModificationType = "CORRECTION_OF_ENTRY_ERRORS"
	DUPLICATEISSUANCEDUETOERROR B2bTaxInvoiceModificationType = "DUPLICATE_ISSUANCE_DUE_TO_ERROR"
	RETURN                      B2bTaxInvoiceModificationType = "RETURN"
)

// Defines values for B2bTaxInvoicePurposeType.
const (
	B2bTaxInvoicePurposeTypeINVOICE B2bTaxInvoicePurposeType = "INVOICE"
	B2bTaxInvoicePurposeTypeNONE    B2bTaxInvoicePurposeType = "NONE"
	B2bTaxInvoicePurposeTypeRECEIPT B2bTaxInvoicePurposeType = "RECEIPT"
)

// Defines values for B2bTaxInvoiceStatus.
const (
	B2bTaxInvoiceStatusBEFORESENDING     B2bTaxInvoiceStatus = "BEFORE_SENDING"
	B2bTaxInvoiceStatusDRAFTED           B2bTaxInvoiceStatus = "DRAFTED"
	B2bTaxInvoiceStatusDRAFTFAILED       B2bTaxInvoiceStatus = "DRAFT_FAILED"
	B2bTaxInvoiceStatusDRAFTPENDING      B2bTaxInvoiceStatus = "DRAFT_PENDING"
	B2bTaxInvoiceStatusISSUANCECANCELLED B2bTaxInvoiceStatus = "ISSUANCE_CANCELLED"
	B2bTaxInvoiceStatusISSUED            B2bTaxInvoiceStatus = "ISSUED"
	B2bTaxInvoiceStatusISSUEFAILED       B2bTaxInvoiceStatus = "ISSUE_FAILED"
	B2bTaxInvoiceStatusISSUEPENDING      B2bTaxInvoiceStatus = "ISSUE_PENDING"
	B2bTaxInvoiceStatusREQUESTCANCELLED  B2bTaxInvoiceStatus = "REQUEST_CANCELLED"
	B2bTaxInvoiceStatusREQUESTED         B2bTaxInvoiceStatus = "REQUESTED"
	B2bTaxInvoiceStatusREQUESTFAILED     B2bTaxInvoiceStatus = "REQUEST_FAILED"
	B2bTaxInvoiceStatusREQUESTPENDING    B2bTaxInvoiceStatus = "REQUEST_PENDING"
	B2bTaxInvoiceStatusREQUESTREFUSED    B2bTaxInvoiceStatus = "REQUEST_REFUSED"
	B2bTaxInvoiceStatusSENDING           B2bTaxInvoiceStatus = "SENDING"
	B2bTaxInvoiceStatusSENDINGCOMPLETED  B2bTaxInvoiceStatus = "SENDING_COMPLETED"
	B2bTaxInvoiceStatusSENDINGFAILED     B2bTaxInvoiceStatus = "SENDING_FAILED"
	B2bTaxInvoiceStatusWAITINGSENDING    B2bTaxInvoiceStatus = "WAITING_SENDING"
)

// Defines values for B2bTaxInvoiceTaxationType.
const (
	FREE      B2bTaxInvoiceTaxationType = "FREE"
	TAXABLE   B2bTaxInvoiceTaxationType = "TAXABLE"
	ZERORATED B2bTaxInvoiceTaxationType = "ZERO_RATED"
)

// Defines values for Bank.
const (
	BankBANKOFAMERICA          Bank = "BANK_OF_AMERICA"
	BankBANKOFCHINA            Bank = "BANK_OF_CHINA"
	BankBANKOFKOREA            Bank = "BANK_OF_KOREA"
	BankBNKSECURITIES          Bank = "BNK_SECURITIES"
	BankBNPPARIBAS             Bank = "BNP_PARIBAS"
	BankBOCOM                  Bank = "BOCOM"
	BankBOOKOOKSECURITIES      Bank = "BOOKOOK_SECURITIES"
	BankBUSAN                  Bank = "BUSAN"
	BankCAPESECURITIES         Bank = "CAPE_SECURITIES"
	BankCCB                    Bank = "CCB"
	BankCITI                   Bank = "CITI"
	BankDAEGU                  Bank = "DAEGU"
	BankDAISHINSECURITIES      Bank = "DAISHIN_SECURITIES"
	BankDAOLSECURITIES         Bank = "DAOL_SECURITIES"
	BankDBSECURITIES           Bank = "DB_SECURITIES"
	BankDEUTSCHE               Bank = "DEUTSCHE"
	BankEBESTSECURITIES        Bank = "EBEST_SECURITIES"
	BankEUGENESECURITIES       Bank = "EUGENE_SECURITIES"
	BankHANA                   Bank = "HANA"
	BankHANASECURITIES         Bank = "HANA_SECURITIES"
	BankHANHWASECURITIES       Bank = "HANHWA_SECURITIES"
	BankHANYANGSECURITIES      Bank = "HANYANG_SECURITIES"
	BankHISECURITIES           Bank = "HI_SECURITIES"
	BankHSBC                   Bank = "HSBC"
	BankHYUNDAIMOTORSECURITIES Bank = "HYUNDAI_MOTOR_SECURITIES"
	BankIBK                    Bank = "IBK"
	BankIBKSECURITIES          Bank = "IBK_SECURITIES"
	BankICBC                   Bank = "ICBC"
	BankJEJU                   Bank = "JEJU"
	BankJEONBUK                Bank = "JEONBUK"
	BankJPMC                   Bank = "JPMC"
	BankKAKAO                  Bank = "KAKAO"
	BankKAKAOPAYSECURITIES     Bank = "KAKAO_PAY_SECURITIES"
	BankKBANK                  Bank = "K_BANK"
	BankKBSECURITIES           Bank = "KB_SECURITIES"
	BankKCIS                   Bank = "KCIS"
	BankKDB                    Bank = "KDB"
	BankKEXIM                  Bank = "KEXIM"
	BankKFCC                   Bank = "KFCC"
	BankKIBO                   Bank = "KIBO"
	BankKIWOOMSECURITIES       Bank = "KIWOOM_SECURITIES"
	BankKODIT                  Bank = "KODIT"
	BankKOOKMIN                Bank = "KOOKMIN"
	BankKOREAFOSSSECURITIES    Bank = "KOREA_FOSS_SECURITIES"
	BankKOREASECURITIES        Bank = "KOREA_SECURITIES"
	BankKOREASECURITIESFINANCE Bank = "KOREA_SECURITIES_FINANCE"
	BankKWANGJU                Bank = "KWANGJU"
	BankKYOBOSECURITIES        Bank = "KYOBO_SECURITIES"
	BankKYONGNAM               Bank = "KYONGNAM"
	BankLEADINGSECURITIES      Bank = "LEADING_SECURITIES"
	BankLOCALNONGHYUP          Bank = "LOCAL_NONGHYUP"
	BankMERITZSECURITIES       Bank = "MERITZ_SECURITIES"
	BankMIRAEASSETSECURITIES   Bank = "MIRAE_ASSET_SECURITIES"
	BankMISCFOREIGN            Bank = "MISC_FOREIGN"
	BankMIZUHO                 Bank = "MIZUHO"
	BankMORGANSTANLEY          Bank = "MORGAN_STANLEY"
	BankMUFG                   Bank = "MUFG"
	BankNFCF                   Bank = "NFCF"
	BankNHSECURITIES           Bank = "NH_SECURITIES"
	BankNONGHYUP               Bank = "NONGHYUP"
	BankPOST                   Bank = "POST"
	BankSAMSUNGSECURITIES      Bank = "SAMSUNG_SECURITIES"
	BankSANGSANGINSECURITIES   Bank = "SANGSANGIN_SECURITIES"
	BankSAVINGSBANK            Bank = "SAVINGS_BANK"
	BankSGI                    Bank = "SGI"
	BankSHINHAN                Bank = "SHINHAN"
	BankSHINHANSECURITIES      Bank = "SHINHAN_SECURITIES"
	BankSHINHYUP               Bank = "SHINHYUP"
	BankSHINYOUNGSECURITIES    Bank = "SHINYOUNG_SECURITIES"
	BankSKSECURITIES           Bank = "SK_SECURITIES"
	BankSTANDARDCHARTERED      Bank = "STANDARD_CHARTERED"
	BankSUHYUP                 Bank = "SUHYUP"
	BankSUHYUPFEDERATION       Bank = "SUHYUP_FEDERATION"
	BankTOSS                   Bank = "TOSS"
	BankTOSSSECURITIES         Bank = "TOSS_SECURITIES"
	BankUOB                    Bank = "UOB"
	BankWOORI                  Bank = "WOORI"
	BankWOORIINVESTMENTBANK    Bank = "WOORI_INVESTMENT_BANK"
	BankYUANTASECURITIES       Bank = "YUANTA_SECURITIES"
)

// Defines values for BillingKeyDeleteRequester.
const (
	BillingKeyDeleteRequesterADMIN    BillingKeyDeleteRequester = "ADMIN"
	BillingKeyDeleteRequesterCUSTOMER BillingKeyDeleteRequester = "CUSTOMER"
)

// Defines values for BillingKeyPaymentMethodType.
const (
	BillingKeyPaymentMethodTypeCARD     BillingKeyPaymentMethodType = "CARD"
	BillingKeyPaymentMethodTypeEASYPAY  BillingKeyPaymentMethodType = "EASY_PAY"
	BillingKeyPaymentMethodTypeMOBILE   BillingKeyPaymentMethodType = "MOBILE"
	BillingKeyPaymentMethodTypeTRANSFER BillingKeyPaymentMethodType = "TRANSFER"
)

// Defines values for BillingKeySortBy.
const (
	BillingKeySortByDELETEDAT       BillingKeySortBy = "DELETED_AT"
	BillingKeySortByISSUEDAT        BillingKeySortBy = "ISSUED_AT"
	BillingKeySortByREQUESTEDAT     BillingKeySortBy = "REQUESTED_AT"
	BillingKeySortBySTATUSTIMESTAMP BillingKeySortBy = "STATUS_TIMESTAMP"
)

// Defines values for BillingKeyStatus.
const (
	BillingKeyStatusDELETED BillingKeyStatus = "DELETED"
	BillingKeyStatusISSUED  BillingKeyStatus = "ISSUED"
)

// Defines values for BillingKeyTextSearchField.
const (
	BillingKeyTextSearchFieldBILLINGKEY          BillingKeyTextSearchField = "BILLING_KEY"
	BillingKeyTextSearchFieldCARDBIN             BillingKeyTextSearchField = "CARD_BIN"
	BillingKeyTextSearchFieldCARDNUMBER          BillingKeyTextSearchField = "CARD_NUMBER"
	BillingKeyTextSearchFieldCHANNELGROUPNAME    BillingKeyTextSearchField = "CHANNEL_GROUP_NAME"
	BillingKeyTextSearchFieldCUSTOMERADDRESS     BillingKeyTextSearchField = "CUSTOMER_ADDRESS"
	BillingKeyTextSearchFieldCUSTOMEREMAIL       BillingKeyTextSearchField = "CUSTOMER_EMAIL"
	BillingKeyTextSearchFieldCUSTOMERNAME        BillingKeyTextSearchField = "CUSTOMER_NAME"
	BillingKeyTextSearchFieldCUSTOMERPHONENUMBER BillingKeyTextSearchField = "CUSTOMER_PHONE_NUMBER"
	BillingKeyTextSearchFieldCUSTOMERZIPCODE     BillingKeyTextSearchField = "CUSTOMER_ZIPCODE"
	BillingKeyTextSearchFieldPGMERCHANTID        BillingKeyTextSearchField = "PG_MERCHANT_ID"
	BillingKeyTextSearchFieldUSERAGENT           BillingKeyTextSearchField = "USER_AGENT"
)

// Defines values for BillingKeyTimeRangeField.
const (
	BillingKeyTimeRangeFieldDELETEDAT       BillingKeyTimeRangeField = "DELETED_AT"
	BillingKeyTimeRangeFieldISSUEDAT        BillingKeyTimeRangeField = "ISSUED_AT"
	BillingKeyTimeRangeFieldREQUESTEDAT     BillingKeyTimeRangeField = "REQUESTED_AT"
	BillingKeyTimeRangeFieldSTATUSTIMESTAMP BillingKeyTimeRangeField = "STATUS_TIMESTAMP"
)

// Defines values for CancelRequester.
const (
	CancelRequesterADMIN    CancelRequester = "ADMIN"
	CancelRequesterCUSTOMER CancelRequester = "CUSTOMER"
)

// Defines values for CardBrand.
const (
	AMEX     CardBrand = "AMEX"
	DINERS   CardBrand = "DINERS"
	JCB      CardBrand = "JCB"
	LOCAL    CardBrand = "LOCAL"
	MASTER   CardBrand = "MASTER"
	UNIONPAY CardBrand = "UNIONPAY"
	VISA     CardBrand = "VISA"
)

// Defines values for CardOwnerType.
const (
	CardOwnerTypeCORPORATE CardOwnerType = "CORPORATE"
	CardOwnerTypePERSONAL  CardOwnerType = "PERSONAL"
)

// Defines values for CardType.
const (
	CREDIT CardType = "CREDIT"
	DEBIT  CardType = "DEBIT"
	GIFT   CardType = "GIFT"
)

// Defines values for Carrier.
const (
	CarrierKT      Carrier = "KT"
	CarrierKTMVNO  Carrier = "KT_MVNO"
	CarrierLGU     Carrier = "LGU"
	CarrierLGUMVNO Carrier = "LGU_MVNO"
	CarrierSKT     Carrier = "SKT"
	CarrierSKTMVNO Carrier = "SKT_MVNO"
)

// Defines values for CashReceiptInputType.
const (
	CashReceiptInputTypeCORPORATE CashReceiptInputType = "CORPORATE"
	CashReceiptInputTypeNORECEIPT CashReceiptInputType = "NO_RECEIPT"
	CashReceiptInputTypePERSONAL  CashReceiptInputType = "PERSONAL"
)

// Defines values for CashReceiptSortBy.
const (
	CashReceiptSortByCANCELLEDAT     CashReceiptSortBy = "CANCELLED_AT"
	CashReceiptSortByISSUEDAT        CashReceiptSortBy = "ISSUED_AT"
	CashReceiptSortBySTATUSUPDATEDAT CashReceiptSortBy = "STATUS_UPDATED_AT"
)

// Defines values for CashReceiptStatus.
const (
	CashReceiptStatusCANCELLED CashReceiptStatus = "CANCELLED"
	CashReceiptStatusFAILED    CashReceiptStatus = "FAILED"
	CashReceiptStatusISSUED    CashReceiptStatus = "ISSUED"
)

// Defines values for CashReceiptTimeRangeField.
const (
	CashReceiptTimeRangeFieldCANCELLEDAT     CashReceiptTimeRangeField = "CANCELLED_AT"
	CashReceiptTimeRangeFieldISSUEDAT        CashReceiptTimeRangeField = "ISSUED_AT"
	CashReceiptTimeRangeFieldSTATUSUPDATEDAT CashReceiptTimeRangeField = "STATUS_UPDATED_AT"
)

// Defines values for CashReceiptType.
const (
	CORPORATE CashReceiptType = "CORPORATE"
	PERSONAL  CashReceiptType = "PERSONAL"
)

// Defines values for ConvenienceStoreBrand.
const (
	FAMILYMART  ConvenienceStoreBrand = "FAMILY_MART"
	LAWSON      ConvenienceStoreBrand = "LAWSON"
	MINISTOP    ConvenienceStoreBrand = "MINI_STOP"
	SEICOMART   ConvenienceStoreBrand = "SEICOMART"
	SEVENELEVEN ConvenienceStoreBrand = "SEVEN_ELEVEN"
)

// Defines values for Country.
const (
	AD Country = "AD"
	AE Country = "AE"
	AF Country = "AF"
	AG Country = "AG"
	AI Country = "AI"
	AL Country = "AL"
	AM Country = "AM"
	AO Country = "AO"
	AQ Country = "AQ"
	AR Country = "AR"
	AS Country = "AS"
	AT Country = "AT"
	AU Country = "AU"
	AW Country = "AW"
	AX Country = "AX"
	AZ Country = "AZ"
	BA Country = "BA"
	BB Country = "BB"
	BD Country = "BD"
	BE Country = "BE"
	BF Country = "BF"
	BG Country = "BG"
	BH Country = "BH"
	BI Country = "BI"
	BJ Country = "BJ"
	BL Country = "BL"
	BM Country = "BM"
	BN Country = "BN"
	BO Country = "BO"
	BQ Country = "BQ"
	BR Country = "BR"
	BS Country = "BS"
	BT Country = "BT"
	BV Country = "BV"
	BW Country = "BW"
	BY Country = "BY"
	BZ Country = "BZ"
	CA Country = "CA"
	CC Country = "CC"
	CD Country = "CD"
	CF Country = "CF"
	CG Country = "CG"
	CH Country = "CH"
	CI Country = "CI"
	CK Country = "CK"
	CL Country = "CL"
	CM Country = "CM"
	CN Country = "CN"
	CO Country = "CO"
	CR Country = "CR"
	CU Country = "CU"
	CV Country = "CV"
	CW Country = "CW"
	CX Country = "CX"
	CY Country = "CY"
	CZ Country = "CZ"
	DE Country = "DE"
	DJ Country = "DJ"
	DK Country = "DK"
	DM Country = "DM"
	DO Country = "DO"
	DZ Country = "DZ"
	EC Country = "EC"
	EE Country = "EE"
	EG Country = "EG"
	EH Country = "EH"
	ER Country = "ER"
	ES Country = "ES"
	ET Country = "ET"
	FI Country = "FI"
	FJ Country = "FJ"
	FK Country = "FK"
	FM Country = "FM"
	FO Country = "FO"
	FR Country = "FR"
	GA Country = "GA"
	GB Country = "GB"
	GD Country = "GD"
	GE Country = "GE"
	GF Country = "GF"
	GG Country = "GG"
	GH Country = "GH"
	GI Country = "GI"
	GL Country = "GL"
	GM Country = "GM"
	GN Country = "GN"
	GP Country = "GP"
	GQ Country = "GQ"
	GR Country = "GR"
	GS Country = "GS"
	GT Country = "GT"
	GU Country = "GU"
	GW Country = "GW"
	GY Country = "GY"
	HK Country = "HK"
	HM Country = "HM"
	HN Country = "HN"
	HR Country = "HR"
	HT Country = "HT"
	HU Country = "HU"
	ID Country = "ID"
	IE Country = "IE"
	IL Country = "IL"
	IM Country = "IM"
	IN Country = "IN"
	IO Country = "IO"
	IQ Country = "IQ"
	IR Country = "IR"
	IS Country = "IS"
	IT Country = "IT"
	JE Country = "JE"
	JM Country = "JM"
	JO Country = "JO"
	JP Country = "JP"
	KE Country = "KE"
	KG Country = "KG"
	KH Country = "KH"
	KI Country = "KI"
	KM Country = "KM"
	KN Country = "KN"
	KP Country = "KP"
	KR Country = "KR"
	KW Country = "KW"
	KY Country = "KY"
	KZ Country = "KZ"
	LA Country = "LA"
	LB Country = "LB"
	LC Country = "LC"
	LI Country = "LI"
	LK Country = "LK"
	LR Country = "LR"
	LS Country = "LS"
	LT Country = "LT"
	LU Country = "LU"
	LV Country = "LV"
	LY Country = "LY"
	MA Country = "MA"
	MC Country = "MC"
	MD Country = "MD"
	ME Country = "ME"
	MF Country = "MF"
	MG Country = "MG"
	MH Country = "MH"
	MK Country = "MK"
	ML Country = "ML"
	MM Country = "MM"
	MN Country = "MN"
	MO Country = "MO"
	MP Country = "MP"
	MQ Country = "MQ"
	MR Country = "MR"
	MS Country = "MS"
	MT Country = "MT"
	MU Country = "MU"
	MV Country = "MV"
	MW Country = "MW"
	MX Country = "MX"
	MY Country = "MY"
	MZ Country = "MZ"
	NA Country = "NA"
	NC Country = "NC"
	NE Country = "NE"
	NF Country = "NF"
	NG Country = "NG"
	NI Country = "NI"
	NL Country = "NL"
	NO Country = "NO"
	NP Country = "NP"
	NR Country = "NR"
	NU Country = "NU"
	NZ Country = "NZ"
	OM Country = "OM"
	PA Country = "PA"
	PE Country = "PE"
	PF Country = "PF"
	PG Country = "PG"
	PH Country = "PH"
	PK Country = "PK"
	PL Country = "PL"
	PM Country = "PM"
	PN Country = "PN"
	PR Country = "PR"
	PS Country = "PS"
	PT Country = "PT"
	PW Country = "PW"
	PY Country = "PY"
	QA Country = "QA"
	RE Country = "RE"
	RO Country = "RO"
	RS Country = "RS"
	RU Country = "RU"
	RW Country = "RW"
	SA Country = "SA"
	SB Country = "SB"
	SC Country = "SC"
	SD Country = "SD"
	SE Country = "SE"
	SG Country = "SG"
	SH Country = "SH"
	SI Country = "SI"
	SJ Country = "SJ"
	SK Country = "SK"
	SL Country = "SL"
	SM Country = "SM"
	SN Country = "SN"
	SO Country = "SO"
	SR Country = "SR"
	SS Country = "SS"
	ST Country = "ST"
	SV Country = "SV"
	SX Country = "SX"
	SY Country = "SY"
	SZ Country = "SZ"
	TC Country = "TC"
	TD Country = "TD"
	TF Country = "TF"
	TG Country = "TG"
	TH Country = "TH"
	TJ Country = "TJ"
	TK Country = "TK"
	TL Country = "TL"
	TM Country = "TM"
	TN Country = "TN"
	TO Country = "TO"
	TR Country = "TR"
	TT Country = "TT"
	TV Country = "TV"
	TW Country = "TW"
	TZ Country = "TZ"
	UA Country = "UA"
	UG Country = "UG"
	UM Country = "UM"
	US Country = "US"
	UY Country = "UY"
	UZ Country = "UZ"
	VA Country = "VA"
	VC Country = "VC"
	VE Country = "VE"
	VG Country = "VG"
	VI Country = "VI"
	VN Country = "VN"
	VU Country = "VU"
	WF Country = "WF"
	WS Country = "WS"
	YE Country = "YE"
	YT Country = "YT"
	ZA Country = "ZA"
	ZM Country = "ZM"
	ZW Country = "ZW"
)

// Defines values for Currency.
const (
	AED Currency = "AED"
	AFN Currency = "AFN"
	ALL Currency = "ALL"
	AMD Currency = "AMD"
	ANG Currency = "ANG"
	AOA Currency = "AOA"
	ARS Currency = "ARS"
	AUD Currency = "AUD"
	AWG Currency = "AWG"
	AZN Currency = "AZN"
	BAM Currency = "BAM"
	BBD Currency = "BBD"
	BDT Currency = "BDT"
	BGN Currency = "BGN"
	BHD Currency = "BHD"
	BIF Currency = "BIF"
	BMD Currency = "BMD"
	BND Currency = "BND"
	BOB Currency = "BOB"
	BOV Currency = "BOV"
	BRL Currency = "BRL"
	BSD Currency = "BSD"
	BTN Currency = "BTN"
	BWP Currency = "BWP"
	BYN Currency = "BYN"
	BZD Currency = "BZD"
	CAD Currency = "CAD"
	CDF Currency = "CDF"
	CHE Currency = "CHE"
	CHF Currency = "CHF"
	CHW Currency = "CHW"
	CLF Currency = "CLF"
	CLP Currency = "CLP"
	CNY Currency = "CNY"
	COP Currency = "COP"
	COU Currency = "COU"
	CRC Currency = "CRC"
	CUC Currency = "CUC"
	CUP Currency = "CUP"
	CVE Currency = "CVE"
	CZK Currency = "CZK"
	DJF Currency = "DJF"
	DKK Currency = "DKK"
	DOP Currency = "DOP"
	DZD Currency = "DZD"
	EGP Currency = "EGP"
	ERN Currency = "ERN"
	ETB Currency = "ETB"
	EUR Currency = "EUR"
	FJD Currency = "FJD"
	FKP Currency = "FKP"
	GBP Currency = "GBP"
	GEL Currency = "GEL"
	GHS Currency = "GHS"
	GIP Currency = "GIP"
	GMD Currency = "GMD"
	GNF Currency = "GNF"
	GTQ Currency = "GTQ"
	GYD Currency = "GYD"
	HKD Currency = "HKD"
	HNL Currency = "HNL"
	HRK Currency = "HRK"
	HTG Currency = "HTG"
	HUF Currency = "HUF"
	IDR Currency = "IDR"
	ILS Currency = "ILS"
	INR Currency = "INR"
	IQD Currency = "IQD"
	IRR Currency = "IRR"
	ISK Currency = "ISK"
	JMD Currency = "JMD"
	JOD Currency = "JOD"
	JPY Currency = "JPY"
	KES Currency = "KES"
	KGS Currency = "KGS"
	KHR Currency = "KHR"
	KMF Currency = "KMF"
	KPW Currency = "KPW"
	KRW Currency = "KRW"
	KWD Currency = "KWD"
	KYD Currency = "KYD"
	KZT Currency = "KZT"
	LAK Currency = "LAK"
	LBP Currency = "LBP"
	LKR Currency = "LKR"
	LRD Currency = "LRD"
	LSL Currency = "LSL"
	LYD Currency = "LYD"
	MAD Currency = "MAD"
	MDL Currency = "MDL"
	MGA Currency = "MGA"
	MKD Currency = "MKD"
	MMK Currency = "MMK"
	MNT Currency = "MNT"
	MOP Currency = "MOP"
	MRU Currency = "MRU"
	MUR Currency = "MUR"
	MVR Currency = "MVR"
	MWK Currency = "MWK"
	MXN Currency = "MXN"
	MXV Currency = "MXV"
	MYR Currency = "MYR"
	MZN Currency = "MZN"
	NAD Currency = "NAD"
	NGN Currency = "NGN"
	NIO Currency = "NIO"
	NOK Currency = "NOK"
	NPR Currency = "NPR"
	NZD Currency = "NZD"
	OMR Currency = "OMR"
	PAB Currency = "PAB"
	PEN Currency = "PEN"
	PGK Currency = "PGK"
	PHP Currency = "PHP"
	PKR Currency = "PKR"
	PLN Currency = "PLN"
	PYG Currency = "PYG"
	QAR Currency = "QAR"
	RON Currency = "RON"
	RSD Currency = "RSD"
	RUB Currency = "RUB"
	RWF Currency = "RWF"
	SAR Currency = "SAR"
	SBD Currency = "SBD"
	SCR Currency = "SCR"
	SDG Currency = "SDG"
	SEK Currency = "SEK"
	SGD Currency = "SGD"
	SHP Currency = "SHP"
	SLE Currency = "SLE"
	SLL Currency = "SLL"
	SOS Currency = "SOS"
	SRD Currency = "SRD"
	SSP Currency = "SSP"
	STN Currency = "STN"
	SVC Currency = "SVC"
	SYP Currency = "SYP"
	SZL Currency = "SZL"
	THB Currency = "THB"
	TJS Currency = "TJS"
	TMT Currency = "TMT"
	TND Currency = "TND"
	TOP Currency = "TOP"
	TRY Currency = "TRY"
	TTD Currency = "TTD"
	TWD Currency = "TWD"
	TZS Currency = "TZS"
	UAH Currency = "UAH"
	UGX Currency = "UGX"
	USD Currency = "USD"
	USN Currency = "USN"
	UYI Currency = "UYI"
	UYU Currency = "UYU"
	UYW Currency = "UYW"
	UZS Currency = "UZS"
	VED Currency = "VED"
	VES Currency = "VES"
	VND Currency = "VND"
	VUV Currency = "VUV"
	WST Currency = "WST"
	XAF Currency = "XAF"
	XAG Currency = "XAG"
	XAU Currency = "XAU"
	XBA Currency = "XBA"
	XBB Currency = "XBB"
	XBC Currency = "XBC"
	XBD Currency = "XBD"
	XCD Currency = "XCD"
	XDR Currency = "XDR"
	XOF Currency = "XOF"
	XPD Currency = "XPD"
	XPF Currency = "XPF"
	XPT Currency = "XPT"
	XSU Currency = "XSU"
	XTS Currency = "XTS"
	XUA Currency = "XUA"
	XXX Currency = "XXX"
	YER Currency = "YER"
	ZAR Currency = "ZAR"
	ZMW Currency = "ZMW"
	ZWL Currency = "ZWL"
)

// Defines values for DayOfWeek.
const (
	FRI DayOfWeek = "FRI"
	MON DayOfWeek = "MON"
	SAT DayOfWeek = "SAT"
	SUN DayOfWeek = "SUN"
	THU DayOfWeek = "THU"
	TUE DayOfWeek = "TUE"
	WED DayOfWeek = "WED"
)

// Defines values for DisputeStatus.
const (
	RESOLVED   DisputeStatus = "RESOLVED"
	UNRESOLVED DisputeStatus = "UNRESOLVED"
)

// Defines values for EasyPayMethodType.
const (
	EasyPayMethodTypeCARD     EasyPayMethodType = "CARD"
	EasyPayMethodTypeCHARGE   EasyPayMethodType = "CHARGE"
	EasyPayMethodTypeTRANSFER EasyPayMethodType = "TRANSFER"
)

// Defines values for EasyPayProvider.
const (
	EasyPayProviderALIPAY       EasyPayProvider = "ALIPAY"
	EasyPayProviderAMAZONPAY    EasyPayProvider = "AMAZONPAY"
	EasyPayProviderAPPLEPAY     EasyPayProvider = "APPLEPAY"
	EasyPayProviderAUPAY        EasyPayProvider = "AUPAY"
	EasyPayProviderCHAI         EasyPayProvider = "CHAI"
	EasyPayProviderDBARAI       EasyPayProvider = "DBARAI"
	EasyPayProviderGRABPAY      EasyPayProvider = "GRABPAY"
	EasyPayProviderHYPHEN       EasyPayProvider = "HYPHEN"
	EasyPayProviderJKOPAY       EasyPayProvider = "JKOPAY"
	EasyPayProviderKAKAOPAY     EasyPayProvider = "KAKAOPAY"
	EasyPayProviderKBAPP        EasyPayProvider = "KB_APP"
	EasyPayProviderKLARNA       EasyPayProvider = "KLARNA"
	EasyPayProviderKPAY         EasyPayProvider = "KPAY"
	EasyPayProviderLGPAY        EasyPayProvider = "LGPAY"
	EasyPayProviderLINEPAY      EasyPayProvider = "LINEPAY"
	EasyPayProviderLPAY         EasyPayProvider = "LPAY"
	EasyPayProviderMERPAY       EasyPayProvider = "MERPAY"
	EasyPayProviderMIR          EasyPayProvider = "MIR"
	EasyPayProviderNAVERPAY     EasyPayProvider = "NAVERPAY"
	EasyPayProviderPAYCO        EasyPayProvider = "PAYCO"
	EasyPayProviderPAYPAL       EasyPayProvider = "PAYPAL"
	EasyPayProviderPAYPAY       EasyPayProvider = "PAYPAY"
	EasyPayProviderPINPAY       EasyPayProvider = "PINPAY"
	EasyPayProviderRAKUTENPAY   EasyPayProvider = "RAKUTENPAY"
	EasyPayProviderSAMSUNGPAY   EasyPayProvider = "SAMSUNGPAY"
	EasyPayProviderSHOPEEPAY    EasyPayProvider = "SHOPEEPAY"
	EasyPayProviderSKPAY        EasyPayProvider = "SKPAY"
	EasyPayProviderSMILEPAY     EasyPayProvider = "SMILEPAY"
	EasyPayProviderSSGPAY       EasyPayProvider = "SSGPAY"
	EasyPayProviderTMONEY       EasyPayProvider = "TMONEY"
	EasyPayProviderTOSSBRANDPAY EasyPayProvider = "TOSS_BRANDPAY"
	EasyPayProviderTOSSPAY      EasyPayProvider = "TOSSPAY"
	EasyPayProviderWECHAT       EasyPayProvider = "WECHAT"
)

// Defines values for Gender.
const (
	FEMALE Gender = "FEMALE"
	MALE   Gender = "MALE"
	OTHER  Gender = "OTHER"
)

// Defines values for IdentityVerificationMethod.
const (
	APP IdentityVerificationMethod = "APP"
	SMS IdentityVerificationMethod = "SMS"
)

// Defines values for IdentityVerificationOperator.
const (
	IdentityVerificationOperatorKT      IdentityVerificationOperator = "KT"
	IdentityVerificationOperatorKTMVNO  IdentityVerificationOperator = "KT_MVNO"
	IdentityVerificationOperatorLGU     IdentityVerificationOperator = "LGU"
	IdentityVerificationOperatorLGUMVNO IdentityVerificationOperator = "LGU_MVNO"
	IdentityVerificationOperatorSKT     IdentityVerificationOperator = "SKT"
	IdentityVerificationOperatorSKTMVNO IdentityVerificationOperator = "SKT_MVNO"
)

// Defines values for IdentityVerificationSortBy.
const (
	IdentityVerificationSortByFAILEDAT        IdentityVerificationSortBy = "FAILED_AT"
	IdentityVerificationSortByREQUESTEDAT     IdentityVerificationSortBy = "REQUESTED_AT"
	IdentityVerificationSortBySTATUSUPDATEDAT IdentityVerificationSortBy = "STATUS_UPDATED_AT"
	IdentityVerificationSortByVERIFIEDAT      IdentityVerificationSortBy = "VERIFIED_AT"
)

// Defines values for IdentityVerificationStatus.
const (
	IdentityVerificationStatusFAILED   IdentityVerificationStatus = "FAILED"
	IdentityVerificationStatusREADY    IdentityVerificationStatus = "READY"
	IdentityVerificationStatusVERIFIED IdentityVerificationStatus = "VERIFIED"
)

// Defines values for IdentityVerificationTimeRangeField.
const (
	IdentityVerificationTimeRangeFieldFAILEDAT        IdentityVerificationTimeRangeField = "FAILED_AT"
	IdentityVerificationTimeRangeFieldREQUESTEDAT     IdentityVerificationTimeRangeField = "REQUESTED_AT"
	IdentityVerificationTimeRangeFieldSTATUSUPDATEDAT IdentityVerificationTimeRangeField = "STATUS_UPDATED_AT"
	IdentityVerificationTimeRangeFieldVERIFIEDAT      IdentityVerificationTimeRangeField = "VERIFIED_AT"
)

// Defines values for InstantPaymentMethodInputVirtualAccountOptionType.
const (
	InstantPaymentMethodInputVirtualAccountOptionTypeFIXED  InstantPaymentMethodInputVirtualAccountOptionType = "FIXED"
	InstantPaymentMethodInputVirtualAccountOptionTypeNORMAL InstantPaymentMethodInputVirtualAccountOptionType = "NORMAL"
)

// Defines values for IssueCashReceiptPaymentMethodType.
const (
	IssueCashReceiptPaymentMethodTypeTRANSFER       IssueCashReceiptPaymentMethodType = "TRANSFER"
	IssueCashReceiptPaymentMethodTypeVIRTUALACCOUNT IssueCashReceiptPaymentMethodType = "VIRTUAL_ACCOUNT"
)

// Defines values for Locale.
const (
	ENUS Locale = "EN_US"
	JAJP Locale = "JA_JP"
	KOKR Locale = "KO_KR"
	RURU Locale = "RU_RU"
	THTH Locale = "TH_TH"
	VIVN Locale = "VI_VN"
	ZHCN Locale = "ZH_CN"
	ZHTW Locale = "ZH_TW"
)

// Defines values for PaymentCashReceiptStatus.
const (
	PaymentCashReceiptStatusCANCELLED PaymentCashReceiptStatus = "CANCELLED"
	PaymentCashReceiptStatusISSUED    PaymentCashReceiptStatus = "ISSUED"
)

// Defines values for PaymentClientType.
const (
	PaymentClientTypeAPI       PaymentClientType = "API"
	PaymentClientTypeSDKMOBILE PaymentClientType = "SDK_MOBILE"
	PaymentClientTypeSDKPC     PaymentClientType = "SDK_PC"
)

// Defines values for PaymentFilterInputEscrowStatus.
const (
	PaymentFilterInputEscrowStatusCANCELLED       PaymentFilterInputEscrowStatus = "CANCELLED"
	PaymentFilterInputEscrowStatusCONFIRMED       PaymentFilterInputEscrowStatus = "CONFIRMED"
	PaymentFilterInputEscrowStatusDELIVERED       PaymentFilterInputEscrowStatus = "DELIVERED"
	PaymentFilterInputEscrowStatusREGISTERED      PaymentFilterInputEscrowStatus = "REGISTERED"
	PaymentFilterInputEscrowStatusREJECTCONFIRMED PaymentFilterInputEscrowStatus = "REJECT_CONFIRMED"
	PaymentFilterInputEscrowStatusREJECTED        PaymentFilterInputEscrowStatus = "REJECTED"
)

// Defines values for PaymentLogisticsCompany.
const (
	PaymentLogisticsCompanyACI            PaymentLogisticsCompany = "ACI"
	PaymentLogisticsCompanyCHUNIL         PaymentLogisticsCompany = "CHUNIL"
	PaymentLogisticsCompanyCJ             PaymentLogisticsCompany = "CJ"
	PaymentLogisticsCompanyCJINTL         PaymentLogisticsCompany = "CJ_INTL"
	PaymentLogisticsCompanyDAESIN         PaymentLogisticsCompany = "DAESIN"
	PaymentLogisticsCompanyDHL            PaymentLogisticsCompany = "DHL"
	PaymentLogisticsCompanyDONGWON        PaymentLogisticsCompany = "DONGWON"
	PaymentLogisticsCompanyEMS            PaymentLogisticsCompany = "EMS"
	PaymentLogisticsCompanyETC            PaymentLogisticsCompany = "ETC"
	PaymentLogisticsCompanyFEDEX          PaymentLogisticsCompany = "FEDEX"
	PaymentLogisticsCompanyGOODSTOLUCK    PaymentLogisticsCompany = "GOODSTOLUCK"
	PaymentLogisticsCompanyGS             PaymentLogisticsCompany = "GS"
	PaymentLogisticsCompanyGSMNTON        PaymentLogisticsCompany = "GSM_NTON"
	PaymentLogisticsCompanyHANJIN         PaymentLogisticsCompany = "HANJIN"
	PaymentLogisticsCompanyHAPDONG        PaymentLogisticsCompany = "HAPDONG"
	PaymentLogisticsCompanyILYANG         PaymentLogisticsCompany = "ILYANG"
	PaymentLogisticsCompanyKGL            PaymentLogisticsCompany = "KGL"
	PaymentLogisticsCompanyKUNYOUNG       PaymentLogisticsCompany = "KUNYOUNG"
	PaymentLogisticsCompanyKYUNGDONG      PaymentLogisticsCompany = "KYUNGDONG"
	PaymentLogisticsCompanyLOGEN          PaymentLogisticsCompany = "LOGEN"
	PaymentLogisticsCompanyLOTTE          PaymentLogisticsCompany = "LOTTE"
	PaymentLogisticsCompanyLXPANTOS       PaymentLogisticsCompany = "LX_PANTOS"
	PaymentLogisticsCompanyPOST           PaymentLogisticsCompany = "POST"
	PaymentLogisticsCompanyPOSTREGISTERED PaymentLogisticsCompany = "POST_REGISTERED"
	PaymentLogisticsCompanySF             PaymentLogisticsCompany = "SF"
	PaymentLogisticsCompanySLX            PaymentLogisticsCompany = "SLX"
	PaymentLogisticsCompanySUNGWON        PaymentLogisticsCompany = "SUNGWON"
	PaymentLogisticsCompanyUPS            PaymentLogisticsCompany = "UPS"
	PaymentLogisticsCompanyUSPS           PaymentLogisticsCompany = "USPS"
	PaymentLogisticsCompanyWOORI          PaymentLogisticsCompany = "WOORI"
)

// Defines values for PaymentMethodGiftCertificateType.
const (
	BOOKNLIFE    PaymentMethodGiftCertificateType = "BOOKNLIFE"
	CULTUREGIFT  PaymentMethodGiftCertificateType = "CULTUREGIFT"
	CULTURELAND  PaymentMethodGiftCertificateType = "CULTURELAND"
	HAPPYMONEY   PaymentMethodGiftCertificateType = "HAPPYMONEY"
	SMARTMUNSANG PaymentMethodGiftCertificateType = "SMART_MUNSANG"
)

// Defines values for PaymentMethodType.
const (
	PaymentMethodTypeCARD             PaymentMethodType = "CARD"
	PaymentMethodTypeCONVENIENCESTORE PaymentMethodType = "CONVENIENCE_STORE"
	PaymentMethodTypeEASYPAY          PaymentMethodType = "EASY_PAY"
	PaymentMethodTypeGIFTCERTIFICATE  PaymentMethodType = "GIFT_CERTIFICATE"
	PaymentMethodTypeMOBILE           PaymentMethodType = "MOBILE"
	PaymentMethodTypeTRANSFER         PaymentMethodType = "TRANSFER"
	PaymentMethodTypeVIRTUALACCOUNT   PaymentMethodType = "VIRTUAL_ACCOUNT"
)

// Defines values for PaymentMethodVirtualAccountRefundStatus.
const (
	PaymentMethodVirtualAccountRefundStatusCOMPLETED           PaymentMethodVirtualAccountRefundStatus = "COMPLETED"
	PaymentMethodVirtualAccountRefundStatusFAILED              PaymentMethodVirtualAccountRefundStatus = "FAILED"
	PaymentMethodVirtualAccountRefundStatusPARTIALREFUNDFAILED PaymentMethodVirtualAccountRefundStatus = "PARTIAL_REFUND_FAILED"
	PaymentMethodVirtualAccountRefundStatusPENDING             PaymentMethodVirtualAccountRefundStatus = "PENDING"
)

// Defines values for PaymentMethodVirtualAccountType.
const (
	PaymentMethodVirtualAccountTypeFIXED  PaymentMethodVirtualAccountType = "FIXED"
	PaymentMethodVirtualAccountTypeNORMAL PaymentMethodVirtualAccountType = "NORMAL"
)

// Defines values for PaymentProductType.
const (
	DIGITAL  PaymentProductType = "DIGITAL"
	PHYSICAL PaymentProductType = "PHYSICAL"
)

// Defines values for PaymentScheduleSortBy.
const (
	PaymentScheduleSortByCOMPLETEDAT PaymentScheduleSortBy = "COMPLETED_AT"
	PaymentScheduleSortByCREATEDAT   PaymentScheduleSortBy = "CREATED_AT"
	PaymentScheduleSortByTIMETOPAY   PaymentScheduleSortBy = "TIME_TO_PAY"
)

// Defines values for PaymentScheduleStatus.
const (
	PaymentScheduleStatusFAILED    PaymentScheduleStatus = "FAILED"
	PaymentScheduleStatusPENDING   PaymentScheduleStatus = "PENDING"
	PaymentScheduleStatusREVOKED   PaymentScheduleStatus = "REVOKED"
	PaymentScheduleStatusSCHEDULED PaymentScheduleStatus = "SCHEDULED"
	PaymentScheduleStatusSTARTED   PaymentScheduleStatus = "STARTED"
	PaymentScheduleStatusSUCCEEDED PaymentScheduleStatus = "SUCCEEDED"
)

// Defines values for PaymentSortBy.
const (
	PaymentSortByREQUESTEDAT     PaymentSortBy = "REQUESTED_AT"
	PaymentSortBySTATUSCHANGEDAT PaymentSortBy = "STATUS_CHANGED_AT"
)

// Defines values for PaymentStatus.
const (
	PaymentStatusCANCELLED            PaymentStatus = "CANCELLED"
	PaymentStatusFAILED               PaymentStatus = "FAILED"
	PaymentStatusPAID                 PaymentStatus = "PAID"
	PaymentStatusPARTIALCANCELLED     PaymentStatus = "PARTIAL_CANCELLED"
	PaymentStatusPENDING              PaymentStatus = "PENDING"
	PaymentStatusREADY                PaymentStatus = "READY"
	PaymentStatusVIRTUALACCOUNTISSUED PaymentStatus = "VIRTUAL_ACCOUNT_ISSUED"
)

// Defines values for PaymentTextSearchField.
const (
	PaymentTextSearchFieldALL                             PaymentTextSearchField = "ALL"
	PaymentTextSearchFieldBILLINGKEY                      PaymentTextSearchField = "BILLING_KEY"
	PaymentTextSearchFieldCANCELREASON                    PaymentTextSearchField = "CANCEL_REASON"
	PaymentTextSearchFieldCARDACQUIRER                    PaymentTextSearchField = "CARD_ACQUIRER"
	PaymentTextSearchFieldCARDAPPROVALNUMBER              PaymentTextSearchField = "CARD_APPROVAL_NUMBER"
	PaymentTextSearchFieldCARDBIN                         PaymentTextSearchField = "CARD_BIN"
	PaymentTextSearchFieldCARDINSTALLMENT                 PaymentTextSearchField = "CARD_INSTALLMENT"
	PaymentTextSearchFieldCARDISSUER                      PaymentTextSearchField = "CARD_ISSUER"
	PaymentTextSearchFieldCARDNUMBER                      PaymentTextSearchField = "CARD_NUMBER"
	PaymentTextSearchFieldCARDRECEIPTNAME                 PaymentTextSearchField = "CARD_RECEIPT_NAME"
	PaymentTextSearchFieldCUSTOMERADDRESS                 PaymentTextSearchField = "CUSTOMER_ADDRESS"
	PaymentTextSearchFieldCUSTOMEREMAIL                   PaymentTextSearchField = "CUSTOMER_EMAIL"
	PaymentTextSearchFieldCUSTOMERNAME                    PaymentTextSearchField = "CUSTOMER_NAME"
	PaymentTextSearchFieldCUSTOMERPHONENUMBER             PaymentTextSearchField = "CUSTOMER_PHONE_NUMBER"
	PaymentTextSearchFieldCUSTOMERZIPCODE                 PaymentTextSearchField = "CUSTOMER_ZIPCODE"
	PaymentTextSearchFieldFAILREASON                      PaymentTextSearchField = "FAIL_REASON"
	PaymentTextSearchFieldGIFTCERTIFICATIONAPPROVALNUMBER PaymentTextSearchField = "GIFT_CERTIFICATION_APPROVAL_NUMBER"
	PaymentTextSearchFieldORDERNAME                       PaymentTextSearchField = "ORDER_NAME"
	PaymentTextSearchFieldPAYMENTID                       PaymentTextSearchField = "PAYMENT_ID"
	PaymentTextSearchFieldPGCANCELLATIONID                PaymentTextSearchField = "PG_CANCELLATION_ID"
	PaymentTextSearchFieldPGMERCHANTID                    PaymentTextSearchField = "PG_MERCHANT_ID"
	PaymentTextSearchFieldPGRECEIPTID                     PaymentTextSearchField = "PG_RECEIPT_ID"
	PaymentTextSearchFieldPGTXID                          PaymentTextSearchField = "PG_TX_ID"
	PaymentTextSearchFieldPROMOTIONID                     PaymentTextSearchField = "PROMOTION_ID"
	PaymentTextSearchFieldRECEIPTAPPROVALNUMBER           PaymentTextSearchField = "RECEIPT_APPROVAL_NUMBER"
	PaymentTextSearchFieldSCHEDULEID                      PaymentTextSearchField = "SCHEDULE_ID"
	PaymentTextSearchFieldTRANSBANK                       PaymentTextSearchField = "TRANS_BANK"
	PaymentTextSearchFieldTXID                            PaymentTextSearchField = "TX_ID"
	PaymentTextSearchFieldUSERAGENT                       PaymentTextSearchField = "USER_AGENT"
	PaymentTextSearchFieldVIRTUALACCOUNTBANK              PaymentTextSearchField = "VIRTUAL_ACCOUNT_BANK"
	PaymentTextSearchFieldVIRTUALACCOUNTHOLDERNAME        PaymentTextSearchField = "VIRTUAL_ACCOUNT_HOLDER_NAME"
	PaymentTextSearchFieldVIRTUALACCOUNTNUMBER            PaymentTextSearchField = "VIRTUAL_ACCOUNT_NUMBER"
)

// Defines values for PaymentTimestampType.
const (
	PaymentTimestampTypeCREATEDAT       PaymentTimestampType = "CREATED_AT"
	PaymentTimestampTypeSTATUSCHANGEDAT PaymentTimestampType = "STATUS_CHANGED_AT"
)

// Defines values for PaymentWebhookPaymentStatus.
const (
	PaymentWebhookPaymentStatusCANCELLED            PaymentWebhookPaymentStatus = "CANCELLED"
	PaymentWebhookPaymentStatusFAILED               PaymentWebhookPaymentStatus = "FAILED"
	PaymentWebhookPaymentStatusPAID                 PaymentWebhookPaymentStatus = "PAID"
	PaymentWebhookPaymentStatusPARTIALCANCELLED     PaymentWebhookPaymentStatus = "PARTIAL_CANCELLED"
	PaymentWebhookPaymentStatusPAYPENDING           PaymentWebhookPaymentStatus = "PAY_PENDING"
	PaymentWebhookPaymentStatusREADY                PaymentWebhookPaymentStatus = "READY"
	PaymentWebhookPaymentStatusVIRTUALACCOUNTISSUED PaymentWebhookPaymentStatus = "VIRTUAL_ACCOUNT_ISSUED"
)

// Defines values for PaymentWebhookStatus.
const (
	PaymentWebhookStatusFAILEDNOTOKRESPONSE   PaymentWebhookStatus = "FAILED_NOT_OK_RESPONSE"
	PaymentWebhookStatusFAILEDUNEXPECTEDERROR PaymentWebhookStatus = "FAILED_UNEXPECTED_ERROR"
	PaymentWebhookStatusSUCCEEDED             PaymentWebhookStatus = "SUCCEEDED"
)

// Defines values for PaymentWebhookTrigger.
const (
	PaymentWebhookTriggerASYNCCANCELAPPROVED   PaymentWebhookTrigger = "ASYNC_CANCEL_APPROVED"
	PaymentWebhookTriggerASYNCCANCELFAILED     PaymentWebhookTrigger = "ASYNC_CANCEL_FAILED"
	PaymentWebhookTriggerASYNCPAYAPPROVED      PaymentWebhookTrigger = "ASYNC_PAY_APPROVED"
	PaymentWebhookTriggerASYNCPAYFAILED        PaymentWebhookTrigger = "ASYNC_PAY_FAILED"
	PaymentWebhookTriggerDISPUTECREATED        PaymentWebhookTrigger = "DISPUTE_CREATED"
	PaymentWebhookTriggerDISPUTERESOLVED       PaymentWebhookTrigger = "DISPUTE_RESOLVED"
	PaymentWebhookTriggerMANUAL                PaymentWebhookTrigger = "MANUAL"
	PaymentWebhookTriggerVIRTUALACCOUNTDEPOSIT PaymentWebhookTrigger = "VIRTUAL_ACCOUNT_DEPOSIT"
)

// Defines values for PgCompany.
const (
	PgCompanyALIPAY       PgCompany = "ALIPAY"
	PgCompanyBLUEWALNUT   PgCompany = "BLUEWALNUT"
	PgCompanyCHAI         PgCompany = "CHAI"
	PgCompanyDANAL        PgCompany = "DANAL"
	PgCompanyDAOU         PgCompany = "DAOU"
	PgCompanyEXIMBAY      PgCompany = "EXIMBAY"
	PgCompanyGALAXIA      PgCompany = "GALAXIA"
	PgCompanyHYPHEN       PgCompany = "HYPHEN"
	PgCompanyINICIS       PgCompany = "INICIS"
	PgCompanyJTNET        PgCompany = "JTNET"
	PgCompanyKAKAO        PgCompany = "KAKAO"
	PgCompanyKAKAOPAY     PgCompany = "KAKAOPAY"
	PgCompanyKCP          PgCompany = "KCP"
	PgCompanyKICC         PgCompany = "KICC"
	PgCompanyKPN          PgCompany = "KPN"
	PgCompanyKSNET        PgCompany = "KSNET"
	PgCompanyMOBILIANS    PgCompany = "MOBILIANS"
	PgCompanyNAVERPAY     PgCompany = "NAVERPAY"
	PgCompanyNICE         PgCompany = "NICE"
	PgCompanyPAYCO        PgCompany = "PAYCO"
	PgCompanyPAYLETTER    PgCompany = "PAYLETTER"
	PgCompanyPAYMENTWALL  PgCompany = "PAYMENTWALL"
	PgCompanyPAYPAL       PgCompany = "PAYPAL"
	PgCompanyPAYPLE       PgCompany = "PAYPLE"
	PgCompanySETTLE       PgCompany = "SETTLE"
	PgCompanySMARTRO      PgCompany = "SMARTRO"
	PgCompanySMILEPAY     PgCompany = "SMILEPAY"
	PgCompanySYRUP        PgCompany = "SYRUP"
	PgCompanyTOSSPAY      PgCompany = "TOSSPAY"
	PgCompanyTOSSPAYMENTS PgCompany = "TOSSPAYMENTS"
	PgCompanyWELCOME      PgCompany = "WELCOME"
)

// Defines values for PgProvider.
const (
	ALIPAY          PgProvider = "ALIPAY"
	BLUEWALNUT      PgProvider = "BLUEWALNUT"
	CHAI            PgProvider = "CHAI"
	DANAL           PgProvider = "DANAL"
	DANALTPAY       PgProvider = "DANAL_TPAY"
	DAOU            PgProvider = "DAOU"
	EXIMBAY         PgProvider = "EXIMBAY"
	EXIMBAYV2       PgProvider = "EXIMBAY_V2"
	GALAXIA         PgProvider = "GALAXIA"
	HTML5INICIS     PgProvider = "HTML5_INICIS"
	HYPHEN          PgProvider = "HYPHEN"
	INICIS          PgProvider = "INICIS"
	INICISJP        PgProvider = "INICIS_JP"
	INICISUNIFIED   PgProvider = "INICIS_UNIFIED"
	INICISV2        PgProvider = "INICIS_V2"
	JTNET           PgProvider = "JTNET"
	KAKAO           PgProvider = "KAKAO"
	KAKAOPAY        PgProvider = "KAKAOPAY"
	KCP             PgProvider = "KCP"
	KCPBILLING      PgProvider = "KCP_BILLING"
	KCPDIRECT       PgProvider = "KCP_DIRECT"
	KCPQUICK        PgProvider = "KCP_QUICK"
	KCPV2           PgProvider = "KCP_V2"
	KICC            PgProvider = "KICC"
	KPN             PgProvider = "KPN"
	KSNET           PgProvider = "KSNET"
	MOBILIANS       PgProvider = "MOBILIANS"
	NAVERCO         PgProvider = "NAVERCO"
	NAVERPAY        PgProvider = "NAVERPAY"
	NICE            PgProvider = "NICE"
	NICEV2          PgProvider = "NICE_V2"
	PAYCO           PgProvider = "PAYCO"
	PAYLETTERGLOBAL PgProvider = "PAYLETTER_GLOBAL"
	PAYMENTWALL     PgProvider = "PAYMENTWALL"
	PAYPAL          PgProvider = "PAYPAL"
	PAYPALV2        PgProvider = "PAYPAL_V2"
	PAYPLE          PgProvider = "PAYPLE"
	PINPAY          PgProvider = "PINPAY"
	SETTLE          PgProvider = "SETTLE"
	SETTLEACC       PgProvider = "SETTLE_ACC"
	SETTLEFIRM      PgProvider = "SETTLE_FIRM"
	SMARTRO         PgProvider = "SMARTRO"
	SMARTROV2       PgProvider = "SMARTRO_V2"
	SMILEPAY        PgProvider = "SMILEPAY"
	SYRUP           PgProvider = "SYRUP"
	TOSSBRANDPAY    PgProvider = "TOSS_BRANDPAY"
	TOSSPAY         PgProvider = "TOSSPAY"
	TOSSPAYMENTS    PgProvider = "TOSSPAYMENTS"
	TOSSPAYV2       PgProvider = "TOSSPAY_V2"
	UPLUS           PgProvider = "UPLUS"
	WELCOME         PgProvider = "WELCOME"
)

// Defines values for PlatformAccountStatus.
const (
	PlatformAccountStatusNOTVERIFIED  PlatformAccountStatus = "NOT_VERIFIED"
	PlatformAccountStatusUNKNOWN      PlatformAccountStatus = "UNKNOWN"
	PlatformAccountStatusVERIFIED     PlatformAccountStatus = "VERIFIED"
	PlatformAccountStatusVERIFYERROR  PlatformAccountStatus = "VERIFY_ERROR"
	PlatformAccountStatusVERIFYFAILED PlatformAccountStatus = "VERIFY_FAILED"
)

// Defines values for PlatformAccountTransferStatus.
const (
	PlatformAccountTransferStatusASYNCPROCESSING PlatformAccountTransferStatus = "ASYNC_PROCESSING"
	PlatformAccountTransferStatusCANCELLED       PlatformAccountTransferStatus = "CANCELLED"
	PlatformAccountTransferStatusFAILED          PlatformAccountTransferStatus = "FAILED"
	PlatformAccountTransferStatusPREPARED        PlatformAccountTransferStatus = "PREPARED"
	PlatformAccountTransferStatusPROCESSING      PlatformAccountTransferStatus = "PROCESSING"
	PlatformAccountTransferStatusSCHEDULED       PlatformAccountTransferStatus = "SCHEDULED"
	PlatformAccountTransferStatusSTOPPED         PlatformAccountTransferStatus = "STOPPED"
	PlatformAccountTransferStatusSUCCEEDED       PlatformAccountTransferStatus = "SUCCEEDED"
)

// Defines values for PlatformAccountTransferType.
const (
	DEPOSIT    PlatformAccountTransferType = "DEPOSIT"
	WITHDRAWAL PlatformAccountTransferType = "WITHDRAWAL"
)

// Defines values for PlatformAmountExceededType.
const (
	DISCOUNTTAXFREETHANDISCOUNT     PlatformAmountExceededType = "DISCOUNT_TAX_FREE_THAN_DISCOUNT"
	DISCOUNTTAXFREETHANORDERTAXFREE PlatformAmountExceededType = "DISCOUNT_TAX_FREE_THAN_ORDER_TAX_FREE"
	DISCOUNTTHANORDER               PlatformAmountExceededType = "DISCOUNT_THAN_ORDER"
	PAYMENTTAXFREETHANPAYMENT       PlatformAmountExceededType = "PAYMENT_TAX_FREE_THAN_PAYMENT"
)

// Defines values for PlatformBulkAccountTransferStatus.
const (
	PlatformBulkAccountTransferStatusCOMPLETED PlatformBulkAccountTransferStatus = "COMPLETED"
	PlatformBulkAccountTransferStatusONGOING   PlatformBulkAccountTransferStatus = "ONGOING"
	PlatformBulkAccountTransferStatusPREPARED  PlatformBulkAccountTransferStatus = "PREPARED"
	PlatformBulkAccountTransferStatusSCHEDULED PlatformBulkAccountTransferStatus = "SCHEDULED"
)

// Defines values for PlatformBulkPayoutStatus.
const (
	PlatformBulkPayoutStatusCANCELLED          PlatformBulkPayoutStatus = "CANCELLED"
	PlatformBulkPayoutStatusCOMPLETED          PlatformBulkPayoutStatus = "COMPLETED"
	PlatformBulkPayoutStatusONGOING            PlatformBulkPayoutStatus = "ONGOING"
	PlatformBulkPayoutStatusPOSTPROCESSPENDING PlatformBulkPayoutStatus = "POST_PROCESS_PENDING"
	PlatformBulkPayoutStatusPREPARED           PlatformBulkPayoutStatus = "PREPARED"
	PlatformBulkPayoutStatusPREPARING          PlatformBulkPayoutStatus = "PREPARING"
)

// Defines values for PlatformBulkTaskStatus.
const (
	PlatformBulkTaskStatusCANCELED   PlatformBulkTaskStatus = "CANCELED"
	PlatformBulkTaskStatusCOMPLETED  PlatformBulkTaskStatus = "COMPLETED"
	PlatformBulkTaskStatusPREPARED   PlatformBulkTaskStatus = "PREPARED"
	PlatformBulkTaskStatusPROCESSING PlatformBulkTaskStatus = "PROCESSING"
)

// Defines values for PlatformBulkTaskType.
const (
	CONNECTMEMBERCOMPANIES         PlatformBulkTaskType = "CONNECT_MEMBER_COMPANIES"
	CREATEPARTNERS                 PlatformBulkTaskType = "CREATE_PARTNERS"
	CREATETRANSFERS                PlatformBulkTaskType = "CREATE_TRANSFERS"
	DISCONNECTMEMBERCOMPANIES      PlatformBulkTaskType = "DISCONNECT_MEMBER_COMPANIES"
	SENDPAYOUTSETTLEMENTSTATEMENTS PlatformBulkTaskType = "SEND_PAYOUT_SETTLEMENT_STATEMENTS"
)

// Defines values for PlatformBusinessStatus.
const (
	PlatformBusinessStatusCLOSED     PlatformBusinessStatus = "CLOSED"
	PlatformBusinessStatusINBUSINESS PlatformBusinessStatus = "IN_BUSINESS"
	PlatformBusinessStatusSUSPENDED  PlatformBusinessStatus = "SUSPENDED"
)

// Defines values for PlatformCancellableAmountType.
const (
	PlatformCancellableAmountTypeSUPPLYWITHVAT PlatformCancellableAmountType = "SUPPLY_WITH_VAT"
	PlatformCancellableAmountTypeTAXFREE       PlatformCancellableAmountType = "TAX_FREE"
)

// Defines values for PlatformPartnerBusinessStatus.
const (
	PlatformPartnerBusinessStatusCLOSED      PlatformPartnerBusinessStatus = "CLOSED"
	PlatformPartnerBusinessStatusINBUSINESS  PlatformPartnerBusinessStatus = "IN_BUSINESS"
	PlatformPartnerBusinessStatusNOTFOUND    PlatformPartnerBusinessStatus = "NOT_FOUND"
	PlatformPartnerBusinessStatusNOTVERIFIED PlatformPartnerBusinessStatus = "NOT_VERIFIED"
	PlatformPartnerBusinessStatusSUSPENDED   PlatformPartnerBusinessStatus = "SUSPENDED"
	PlatformPartnerBusinessStatusVERIFYERROR PlatformPartnerBusinessStatus = "VERIFY_ERROR"
)

// Defines values for PlatformPartnerMemberCompanyConnectionStatus.
const (
	CONNECTED         PlatformPartnerMemberCompanyConnectionStatus = "CONNECTED"
	CONNECTFAILED     PlatformPartnerMemberCompanyConnectionStatus = "CONNECT_FAILED"
	CONNECTPENDING    PlatformPartnerMemberCompanyConnectionStatus = "CONNECT_PENDING"
	DISCONNECTPENDING PlatformPartnerMemberCompanyConnectionStatus = "DISCONNECT_PENDING"
	NOTCONNECTED      PlatformPartnerMemberCompanyConnectionStatus = "NOT_CONNECTED"
)

// Defines values for PlatformPartnerSettlementStatus.
const (
	PlatformPartnerSettlementStatusCANCELLED       PlatformPartnerSettlementStatus = "CANCELLED"
	PlatformPartnerSettlementStatusCONFIRMED       PlatformPartnerSettlementStatus = "CONFIRMED"
	PlatformPartnerSettlementStatusINPAYOUT        PlatformPartnerSettlementStatus = "IN_PAYOUT"
	PlatformPartnerSettlementStatusPAIDOUT         PlatformPartnerSettlementStatus = "PAID_OUT"
	PlatformPartnerSettlementStatusPAYOUTFAILED    PlatformPartnerSettlementStatus = "PAYOUT_FAILED"
	PlatformPartnerSettlementStatusPAYOUTPREPARED  PlatformPartnerSettlementStatus = "PAYOUT_PREPARED"
	PlatformPartnerSettlementStatusPAYOUTSCHEDULED PlatformPartnerSettlementStatus = "PAYOUT_SCHEDULED"
	PlatformPartnerSettlementStatusPAYOUTWITHHELD  PlatformPartnerSettlementStatus = "PAYOUT_WITHHELD"
)

// Defines values for PlatformPartnerSettlementType.
const (
	PlatformPartnerSettlementTypeMANUAL      PlatformPartnerSettlementType = "MANUAL"
	PlatformPartnerSettlementTypeORDER       PlatformPartnerSettlementType = "ORDER"
	PlatformPartnerSettlementTypeORDERCANCEL PlatformPartnerSettlementType = "ORDER_CANCEL"
)

// Defines values for PlatformPartnerStatus.
const (
	APPROVED PlatformPartnerStatus = "APPROVED"
	PENDING  PlatformPartnerStatus = "PENDING"
	REJECTED PlatformPartnerStatus = "REJECTED"
)

// Defines values for PlatformPartnerTaxationType.
const (
	PlatformPartnerTaxationTypeNORMAL                 PlatformPartnerTaxationType = "NORMAL"
	PlatformPartnerTaxationTypeSIMPLE                 PlatformPartnerTaxationType = "SIMPLE"
	PlatformPartnerTaxationTypeSIMPLETAXINVOICEISSUER PlatformPartnerTaxationType = "SIMPLE_TAX_INVOICE_ISSUER"
	PlatformPartnerTaxationTypeTAXFREE                PlatformPartnerTaxationType = "TAX_FREE"
)

// Defines values for PlatformPartnerTypeName.
const (
	PlatformPartnerTypeNameBUSINESS    PlatformPartnerTypeName = "BUSINESS"
	PlatformPartnerTypeNameNONWHTPAYER PlatformPartnerTypeName = "NON_WHT_PAYER"
	PlatformPartnerTypeNameWHTPAYER    PlatformPartnerTypeName = "WHT_PAYER"
)

// Defines values for PlatformPayer.
const (
	MERCHANT PlatformPayer = "MERCHANT"
	PARTNER  PlatformPayer = "PARTNER"
)

// Defines values for PlatformPayoutMethod.
const (
	AGENCY PlatformPayoutMethod = "AGENCY"
	DIRECT PlatformPayoutMethod = "DIRECT"
)

// Defines values for PlatformPayoutSettlementStatementStatus.
const (
	SENDFAILED   PlatformPayoutSettlementStatementStatus = "SEND_FAILED"
	SENDPREPARED PlatformPayoutSettlementStatementStatus = "SEND_PREPARED"
	SENT         PlatformPayoutSettlementStatementStatus = "SENT"
	UNSENT       PlatformPayoutSettlementStatementStatus = "UNSENT"
)

// Defines values for PlatformPayoutStatus.
const (
	PlatformPayoutStatusCANCELLED  PlatformPayoutStatus = "CANCELLED"
	PlatformPayoutStatusCONFIRMED  PlatformPayoutStatus = "CONFIRMED"
	PlatformPayoutStatusFAILED     PlatformPayoutStatus = "FAILED"
	PlatformPayoutStatusPREPARED   PlatformPayoutStatus = "PREPARED"
	PlatformPayoutStatusPROCESSING PlatformPayoutStatus = "PROCESSING"
	PlatformPayoutStatusSCHEDULED  PlatformPayoutStatus = "SCHEDULED"
	PlatformPayoutStatusSTOPPED    PlatformPayoutStatus = "STOPPED"
	PlatformPayoutStatusSUCCEEDED  PlatformPayoutStatus = "SUCCEEDED"
)

// Defines values for PlatformPayoutTaxInvoiceStatus.
const (
	PlatformPayoutTaxInvoiceStatusBEFORESENDING     PlatformPayoutTaxInvoiceStatus = "BEFORE_SENDING"
	PlatformPayoutTaxInvoiceStatusDRAFTED           PlatformPayoutTaxInvoiceStatus = "DRAFTED"
	PlatformPayoutTaxInvoiceStatusDRAFTFAILED       PlatformPayoutTaxInvoiceStatus = "DRAFT_FAILED"
	PlatformPayoutTaxInvoiceStatusDRAFTPENDING      PlatformPayoutTaxInvoiceStatus = "DRAFT_PENDING"
	PlatformPayoutTaxInvoiceStatusISSUANCECANCELLED PlatformPayoutTaxInvoiceStatus = "ISSUANCE_CANCELLED"
	PlatformPayoutTaxInvoiceStatusISSUED            PlatformPayoutTaxInvoiceStatus = "ISSUED"
	PlatformPayoutTaxInvoiceStatusNONE              PlatformPayoutTaxInvoiceStatus = "NONE"
	PlatformPayoutTaxInvoiceStatusREQUESTCANCELLED  PlatformPayoutTaxInvoiceStatus = "REQUEST_CANCELLED"
	PlatformPayoutTaxInvoiceStatusREQUESTED         PlatformPayoutTaxInvoiceStatus = "REQUESTED"
	PlatformPayoutTaxInvoiceStatusREQUESTFAILED     PlatformPayoutTaxInvoiceStatus = "REQUEST_FAILED"
	PlatformPayoutTaxInvoiceStatusREQUESTPENDING    PlatformPayoutTaxInvoiceStatus = "REQUEST_PENDING"
	PlatformPayoutTaxInvoiceStatusREQUESTREFUSED    PlatformPayoutTaxInvoiceStatus = "REQUEST_REFUSED"
	PlatformPayoutTaxInvoiceStatusSENDING           PlatformPayoutTaxInvoiceStatus = "SENDING"
	PlatformPayoutTaxInvoiceStatusSENDINGCOMPLETED  PlatformPayoutTaxInvoiceStatus = "SENDING_COMPLETED"
	PlatformPayoutTaxInvoiceStatusSENDINGFAILED     PlatformPayoutTaxInvoiceStatus = "SENDING_FAILED"
	PlatformPayoutTaxInvoiceStatusWAITINGSENDING    PlatformPayoutTaxInvoiceStatus = "WAITING_SENDING"
)

// Defines values for PlatformPortOnePaymentCancelAmountType.
const (
	PlatformPortOnePaymentCancelAmountTypeSUPPLYWITHVAT PlatformPortOnePaymentCancelAmountType = "SUPPLY_WITH_VAT"
	PlatformPortOnePaymentCancelAmountTypeTAXFREE       PlatformPortOnePaymentCancelAmountType = "TAX_FREE"
)

// Defines values for PlatformSettlementCycleDatePolicy.
const (
	CALENDARDAY   PlatformSettlementCycleDatePolicy = "CALENDAR_DAY"
	HOLIDAYAFTER  PlatformSettlementCycleDatePolicy = "HOLIDAY_AFTER"
	HOLIDAYBEFORE PlatformSettlementCycleDatePolicy = "HOLIDAY_BEFORE"
)

// Defines values for PlatformSettlementCycleType.
const (
	DAILY       PlatformSettlementCycleType = "DAILY"
	MANUALDATES PlatformSettlementCycleType = "MANUAL_DATES"
	MONTHLY     PlatformSettlementCycleType = "MONTHLY"
	WEEKLY      PlatformSettlementCycleType = "WEEKLY"
)

// Defines values for PlatformTaxationType.
const (
	PlatformTaxationTypeASSIGNEDIDNUMBER       PlatformTaxationType = "ASSIGNED_ID_NUMBER"
	PlatformTaxationTypeNORMAL                 PlatformTaxationType = "NORMAL"
	PlatformTaxationTypeSIMPLE                 PlatformTaxationType = "SIMPLE"
	PlatformTaxationTypeSIMPLETAXINVOICEISSUER PlatformTaxationType = "SIMPLE_TAX_INVOICE_ISSUER"
	PlatformTaxationTypeSPECIAL                PlatformTaxationType = "SPECIAL"
	PlatformTaxationTypeTAXFREE                PlatformTaxationType = "TAX_FREE"
)

// Defines values for PlatformTransferStatus.
const (
	PlatformTransferStatusINPAYOUT  PlatformTransferStatus = "IN_PAYOUT"
	PlatformTransferStatusINPROCESS PlatformTransferStatus = "IN_PROCESS"
	PlatformTransferStatusPAIDOUT   PlatformTransferStatus = "PAID_OUT"
	PlatformTransferStatusSCHEDULED PlatformTransferStatus = "SCHEDULED"
	PlatformTransferStatusSETTLED   PlatformTransferStatus = "SETTLED"
)

// Defines values for PlatformTransferSummaryPartnerType.
const (
	PlatformTransferSummaryPartnerTypeBUSINESS    PlatformTransferSummaryPartnerType = "BUSINESS"
	PlatformTransferSummaryPartnerTypeNONWHTPAYER PlatformTransferSummaryPartnerType = "NON_WHT_PAYER"
	PlatformTransferSummaryPartnerTypeWHTPAYER    PlatformTransferSummaryPartnerType = "WHT_PAYER"
)

// Defines values for PlatformTransferType.
const (
	MANUAL      PlatformTransferType = "MANUAL"
	ORDER       PlatformTransferType = "ORDER"
	ORDERCANCEL PlatformTransferType = "ORDER_CANCEL"
)

// Defines values for PortOneVersion.
const (
	V1 PortOneVersion = "V1"
	V2 PortOneVersion = "V2"
)

// Defines values for PromotionCardCompany.
const (
	BCCARD      PromotionCardCompany = "BC_CARD"
	HANACARD    PromotionCardCompany = "HANA_CARD"
	HYUNDAICARD PromotionCardCompany = "HYUNDAI_CARD"
	KOOKMINCARD PromotionCardCompany = "KOOKMIN_CARD"
	LOTTECARD   PromotionCardCompany = "LOTTE_CARD"
	NHCARD      PromotionCardCompany = "NH_CARD"
	SAMSUNGCARD PromotionCardCompany = "SAMSUNG_CARD"
	SHINHANCARD PromotionCardCompany = "SHINHAN_CARD"
	WOORICARD   PromotionCardCompany = "WOORI_CARD"
)

// Defines values for PromotionDiscountRetainOption.
const (
	RELEASE PromotionDiscountRetainOption = "RELEASE"
	RETAIN  PromotionDiscountRetainOption = "RETAIN"
)

// Defines values for PromotionStatus.
const (
	PromotionStatusBUDGETEXHAUSTED PromotionStatus = "BUDGET_EXHAUSTED"
	PromotionStatusCOMPLETED       PromotionStatus = "COMPLETED"
	PromotionStatusINPROGRESS      PromotionStatus = "IN_PROGRESS"
	PromotionStatusPAUSED          PromotionStatus = "PAUSED"
	PromotionStatusSCHEDULED       PromotionStatus = "SCHEDULED"
	PromotionStatusTERMINATED      PromotionStatus = "TERMINATED"
)

// Defines values for SelectedChannelType.
const (
	LIVE SelectedChannelType = "LIVE"
	TEST SelectedChannelType = "TEST"
)

// Defines values for SettlementAmountType.
const (
	GROSS SettlementAmountType = "GROSS"
	NET   SettlementAmountType = "NET"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// Defines values for TaxInvoicesSheetField.
const (
	TaxInvoicesSheetFieldBULKTAXINVOICEID         TaxInvoicesSheetField = "BULK_TAX_INVOICE_ID"
	TaxInvoicesSheetFieldCANCELREASON             TaxInvoicesSheetField = "CANCEL_REASON"
	TaxInvoicesSheetFieldDOCUMENTMODIFICATIONTYPE TaxInvoicesSheetField = "DOCUMENT_MODIFICATION_TYPE"
	TaxInvoicesSheetFieldISDELAYED                TaxInvoicesSheetField = "IS_DELAYED"
	TaxInvoicesSheetFieldISSUANCEDUEDATE          TaxInvoicesSheetField = "ISSUANCE_DUE_DATE"
	TaxInvoicesSheetFieldISSUANCETYPE             TaxInvoicesSheetField = "ISSUANCE_TYPE"
	TaxInvoicesSheetFieldISSUEDAT                 TaxInvoicesSheetField = "ISSUED_AT"
	TaxInvoicesSheetFieldITEMS                    TaxInvoicesSheetField = "ITEMS"
	TaxInvoicesSheetFieldMEMO                     TaxInvoicesSheetField = "MEMO"
	TaxInvoicesSheetFieldNTSSENTAT                TaxInvoicesSheetField = "NTS_SENT_AT"
	TaxInvoicesSheetFieldPARTNERBRN               TaxInvoicesSheetField = "PARTNER_BRN"
	TaxInvoicesSheetFieldPARTNERNAME              TaxInvoicesSheetField = "PARTNER_NAME"
	TaxInvoicesSheetFieldPAYOUTID                 TaxInvoicesSheetField = "PAYOUT_ID"
	TaxInvoicesSheetFieldPLAINID                  TaxInvoicesSheetField = "PLAIN_ID"
	TaxInvoicesSheetFieldPURPOSETYPE              TaxInvoicesSheetField = "PURPOSE_TYPE"
	TaxInvoicesSheetFieldRECIPIENTDOCUMENTKEY     TaxInvoicesSheetField = "RECIPIENT_DOCUMENT_KEY"
	TaxInvoicesSheetFieldREQUESTEDAT              TaxInvoicesSheetField = "REQUESTED_AT"
	TaxInvoicesSheetFieldSTATUS                   TaxInvoicesSheetField = "STATUS"
	TaxInvoicesSheetFieldSTATUSUPDATEDAT          TaxInvoicesSheetField = "STATUS_UPDATED_AT"
	TaxInvoicesSheetFieldSUPPLIERDOCUMENTKEY      TaxInvoicesSheetField = "SUPPLIER_DOCUMENT_KEY"
	TaxInvoicesSheetFieldTAXATIONTYPE             TaxInvoicesSheetField = "TAXATION_TYPE"
	TaxInvoicesSheetFieldTOTALAMOUNT              TaxInvoicesSheetField = "TOTAL_AMOUNT"
	TaxInvoicesSheetFieldTOTALSUPPLYAMOUNT        TaxInvoicesSheetField = "TOTAL_SUPPLY_AMOUNT"
	TaxInvoicesSheetFieldTOTALTAXAMOUNT           TaxInvoicesSheetField = "TOTAL_TAX_AMOUNT"
	TaxInvoicesSheetFieldWRITEDATE                TaxInvoicesSheetField = "WRITE_DATE"
)

// Defines values for Trigger.
const (
	TriggerAPI          Trigger = "API"
	TriggerCHARGEBACK   Trigger = "CHARGEBACK"
	TriggerCONSOLE      Trigger = "CONSOLE"
	TriggerPORTONEADMIN Trigger = "PORTONE_ADMIN"
)

// Defines values for Type.
const (
	PARTNERPAYOUT Type = "PARTNER_PAYOUT"
	REMIT         Type = "REMIT"
)

// Address   
//
// oneLine(   )   .
type Address struct {
	union json.RawMessage
}

// AlreadyPaidError    
type AlreadyPaidError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// AlreadyPaidOrWaitingError     
type AlreadyPaidOrWaitingError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// ApplyEscrowLogisticsError defines model for ApplyEscrowLogisticsError.
type ApplyEscrowLogisticsError struct {
	union json.RawMessage
}

// ApplyEscrowLogisticsResponse      
type ApplyEscrowLogisticsResponse struct {
	AppliedAt     time.Time `json:"appliedAt"`
	InvoiceNumber string    `json:"invoiceNumber"`
	SentAt        time.Time `json:"sentAt"`
}

// ArchivePlatformAdditionalFeePolicyError defines model for ArchivePlatformAdditionalFeePolicyError.
type ArchivePlatformAdditionalFeePolicyError struct {
	union json.RawMessage
}

// ArchivePlatformAdditionalFeePolicyResponse      
type ArchivePlatformAdditionalFeePolicyResponse struct {
	// AdditionalFeePolicy   
	//
	//           .     ,  ,    .
	AdditionalFeePolicy PlatformAdditionalFeePolicy `json:"additionalFeePolicy"`
}

// ArchivePlatformContractError defines model for ArchivePlatformContractError.
type ArchivePlatformContractError struct {
	union json.RawMessage
}

// ArchivePlatformContractResponse    
type ArchivePlatformContractResponse struct {
	// Contract 
	//
	//           .
	//             .
	Contract PlatformContract `json:"contract"`
}

// ArchivePlatformDiscountSharePolicyError defines model for ArchivePlatformDiscountSharePolicyError.
type ArchivePlatformDiscountSharePolicyError struct {
	union json.RawMessage
}

// ArchivePlatformDiscountSharePolicyResponse     
type ArchivePlatformDiscountSharePolicyResponse struct {
	// DiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	DiscountSharePolicy PlatformDiscountSharePolicy `json:"discountSharePolicy"`
}

// ArchivePlatformPartnerError defines model for ArchivePlatformPartnerError.
type ArchivePlatformPartnerError struct {
	union json.RawMessage
}

// ArchivePlatformPartnerResponse    
type ArchivePlatformPartnerResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// AttachB2bTaxInvoiceFileBody    
type AttachB2bTaxInvoiceFileBody struct {
	FileId string `json:"fileId"`
}

// AttachB2bTaxInvoiceFileError defines model for AttachB2bTaxInvoiceFileError.
type AttachB2bTaxInvoiceFileError struct {
	union json.RawMessage
}

// B2BCannotChangeTaxTypeError       
type B2BCannotChangeTaxTypeError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2BTaxInvoiceStatusNotSendingCompletedError      
type B2BTaxInvoiceStatusNotSendingCompletedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bBulkTaxInvoice defines model for B2bBulkTaxInvoice.
type B2bBulkTaxInvoice struct {
	CreatedAt time.Time `json:"createdAt"`
	GraphqlId string    `json:"graphqlId"`
	Id        string    `json:"id"`

	// IssuanceType  
	IssuanceType B2bTaxInvoiceIssuanceType `json:"issuanceType"`
	Name         *string                   `json:"name,omitempty"`
	RequestedAt  *time.Time                `json:"requestedAt,omitempty"`
	ScheduledAt  *time.Time                `json:"scheduledAt,omitempty"`

	// SourceType   
	SourceType B2bBulkTaxInvoiceSourceType `json:"sourceType"`
	Stats      MapStat                     `json:"stats"`

	// Status   
	Status            B2bBulkTaxInvoiceStatus `json:"status"`
	StatusUpdatedAt   time.Time               `json:"statusUpdatedAt"`
	TotalAmount       int64                   `json:"totalAmount"`
	TotalInvoiceCount int32                   `json:"totalInvoiceCount"`
}

// B2bBulkTaxInvoiceNotFoundError     
type B2bBulkTaxInvoiceNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bBulkTaxInvoiceSourceType   
type B2bBulkTaxInvoiceSourceType string

// B2bBulkTaxInvoiceStat    
type B2bBulkTaxInvoiceStat struct {
	AmountSum int64 `json:"amountSum"`
	Count     int32 `json:"count"`
}

// B2bBulkTaxInvoiceStatus   
type B2bBulkTaxInvoiceStatus string

// B2bBusinessInfo  
type B2bBusinessInfo struct {
	Address                    string  `json:"address"`
	Brn                        string  `json:"brn"`
	BusinessCategoryCode       string  `json:"businessCategoryCode"`
	BusinessClass              string  `json:"businessClass"`
	BusinessEntityType         string  `json:"businessEntityType"`
	BusinessStatus             string  `json:"businessStatus"`
	BusinessType               string  `json:"businessType"`
	CeoName                    string  `json:"ceoName"`
	ClosingDate                *string `json:"closingDate,omitempty"`
	CorpRegNo                  *string `json:"corpRegNo,omitempty"`
	Name                       string  `json:"name"`
	OpeningDate                string  `json:"openingDate"`
	PhoneNumber                *string `json:"phoneNumber,omitempty"`
	SimplifiedTaxationTypeDate *string `json:"simplifiedTaxationTypeDate,omitempty"`
	TaxOfficeCode              *string `json:"taxOfficeCode,omitempty"`
	TaxOfficeName              *string `json:"taxOfficeName,omitempty"`
	TaxationType               string  `json:"taxationType"`
	ZipCode                    string  `json:"zipCode"`
}

// B2bBusinessInfoResult   
type B2bBusinessInfoResult struct {
	Brn string `json:"brn"`

	// BusinessInfo  
	BusinessInfo *B2bBusinessInfo `json:"businessInfo,omitempty"`
	Error        *string          `json:"error,omitempty"`
}

// B2bCompanyStateBusinessStatus  
type B2bCompanyStateBusinessStatus string

// B2bDocumentKeyCannotBeChangedError    
type B2bDocumentKeyCannotBeChangedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bExternalServiceError     
type B2bExternalServiceError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bFileNotFoundError      
type B2bFileNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bIdAlreadyExistsError ID   
type B2bIdAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bIssuanceTypeMismatchError      
type B2bIssuanceTypeMismatchError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bModificationNotProvidedError        
type B2bModificationNotProvidedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bNotEnabledError B2B    
type B2bNotEnabledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bOriginalTaxInvoiceNotFoundError     
type B2bOriginalTaxInvoiceNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bRecipientNotFoundError    
type B2bRecipientNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bSearchDateType  
type B2bSearchDateType string

// B2bSupplierNotFoundError    
type B2bSupplierNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoice 
type B2bTaxInvoice struct {
	// AdditionalContacts  3
	AdditionalContacts []B2bTaxInvoiceAdditionalContact `json:"additionalContacts"`

	// BookIssue  (4) : 0 ~ 9999
	BookIssue *int32 `json:"bookIssue,omitempty"`

	// BookVolume  (4) : 0 ~ 9999
	BookVolume       *int32     `json:"bookVolume,omitempty"`
	BulkTaxInvoiceId *string    `json:"bulkTaxInvoiceId,omitempty"`
	CashAmount       *int64     `json:"cashAmount,omitempty"`
	CheckAmount      *int64     `json:"checkAmount,omitempty"`
	CreditAmount     *int64     `json:"creditAmount,omitempty"`
	DeletedAt        *time.Time `json:"deletedAt,omitempty"`

	// DocumentModificationType     
	DocumentModificationType B2bTaxInvoiceDocumentModificationType `json:"documentModificationType"`
	DraftedAt                *time.Time                            `json:"draftedAt,omitempty"`
	Id                       string                                `json:"id"`
	IsDelayed                *bool                                 `json:"isDelayed,omitempty"`

	// IssuanceDueDate   , `yyyy-MM-dd`  .
	IssuanceDueDate openapi_types.Date `json:"issuanceDueDate"`

	// IssuanceType  
	IssuanceType B2bTaxInvoiceIssuanceType `json:"issuanceType"`
	IssuedAt     *time.Time                `json:"issuedAt,omitempty"`

	// Items  99
	Items []B2bTaxInvoiceItem `json:"items"`
	Memo  *string             `json:"memo,omitempty"`

	// Modification   
	Modification *B2bTaxInvoiceModification `json:"modification,omitempty"`
	NoteAmount   *int64                     `json:"noteAmount,omitempty"`

	// NtsApprovalNumber  ()   
	NtsApprovalNumber *string `json:"ntsApprovalNumber,omitempty"`
	NtsResult         *string `json:"ntsResult,omitempty"`

	// NtsResultCode      3 +  3 
	NtsResultCode       *string    `json:"ntsResultCode,omitempty"`
	NtsResultReceivedAt *time.Time `json:"ntsResultReceivedAt,omitempty"`
	NtsSentAt           *time.Time `json:"ntsSentAt,omitempty"`

	// PurposeType /
	PurposeType          B2bTaxInvoicePurposeType `json:"purposeType"`
	Recipient            B2bTaxInvoiceCompany     `json:"recipient"`
	RecipientDocumentKey *string                  `json:"recipientDocumentKey,omitempty"`

	// Remarks  3
	Remarks             []string             `json:"remarks"`
	RequestedAt         *time.Time           `json:"requestedAt,omitempty"`
	SendSms             *bool                `json:"sendSms,omitempty"`
	SerialNumber        *string              `json:"serialNumber,omitempty"`
	Status              B2bTaxInvoiceStatus  `json:"status"`
	StatusUpdatedAt     *time.Time           `json:"statusUpdatedAt,omitempty"`
	Supplier            B2bTaxInvoiceCompany `json:"supplier"`
	SupplierDocumentKey *string              `json:"supplierDocumentKey,omitempty"`

	// TaxationType  
	TaxationType      B2bTaxInvoiceTaxationType `json:"taxationType"`
	TotalAmount       int64                     `json:"totalAmount"`
	TotalSupplyAmount int64                     `json:"totalSupplyAmount"`
	TotalTaxAmount    int64                     `json:"totalTaxAmount"`

	// WriteDate   , `yyyy-MM-dd`  .
	WriteDate openapi_types.Date `json:"writeDate"`
}

// B2bTaxInvoiceAdditionalContact  
type B2bTaxInvoiceAdditionalContact struct {
	Email string `json:"email"`

	// Name  100
	Name *string `json:"name,omitempty"`
}

// B2bTaxInvoiceAttachment  
type B2bTaxInvoiceAttachment struct {
	AttachedAt time.Time `json:"attachedAt"`
	Id         string    `json:"id"`
	Name       string    `json:"name"`
}

// B2bTaxInvoiceAttachmentNotFoundError      
type B2bTaxInvoiceAttachmentNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceCompany defines model for B2bTaxInvoiceCompany.
type B2bTaxInvoiceCompany struct {
	// Address  300
	Address *string `json:"address,omitempty"`

	// Brn `-`  10
	Brn string `json:"brn"`

	// BusinessClass  100
	BusinessClass *string `json:"businessClass,omitempty"`

	// BusinessType  100
	BusinessType *string `json:"businessType,omitempty"`

	// Contact  
	Contact B2bTaxInvoiceContact `json:"contact"`

	// Name  200
	Name string `json:"name"`

	// RepresentativeName  100
	RepresentativeName string `json:"representativeName"`

	// TaxRegistrationId 4 
	TaxRegistrationId *string `json:"taxRegistrationId,omitempty"`
}

// B2bTaxInvoiceContact  
type B2bTaxInvoiceContact struct {
	Department        *string `json:"department,omitempty"`
	Email             string  `json:"email"`
	MobilePhoneNumber *string `json:"mobilePhoneNumber,omitempty"`
	Name              *string `json:"name,omitempty"`
	PhoneNumber       *string `json:"phoneNumber,omitempty"`
}

// B2bTaxInvoiceDocumentModificationType     
type B2bTaxInvoiceDocumentModificationType string

// B2bTaxInvoiceInput    
type B2bTaxInvoiceInput struct {
	// AdditionalContacts  3
	AdditionalContacts *[]B2bTaxInvoiceAdditionalContact `json:"additionalContacts,omitempty"`
	BookIssue          *int32                            `json:"bookIssue,omitempty"`
	BookVolume         *int32                            `json:"bookVolume,omitempty"`
	CashAmount         *int64                            `json:"cashAmount,omitempty"`
	CheckAmount        *int64                            `json:"checkAmount,omitempty"`
	CreditAmount       *int64                            `json:"creditAmount,omitempty"`

	// IssuanceType  
	IssuanceType *B2bTaxInvoiceIssuanceType `json:"issuanceType,omitempty"`

	// Items  99
	Items      *[]B2bTaxInvoiceItem `json:"items,omitempty"`
	NoteAmount *int64               `json:"noteAmount,omitempty"`

	// PurposeType /
	PurposeType B2bTaxInvoicePurposeType `json:"purposeType"`
	Recipient   B2bTaxInvoiceCompany     `json:"recipient"`

	// RecipientDocumentKey  , , ('-','_')  
	RecipientDocumentKey *string `json:"recipientDocumentKey,omitempty"`

	// Remarks  3
	Remarks *[]string `json:"remarks,omitempty"`

	// SendSms    {supplier.contact.mobile_phone_number}      ,     false
	SendSms      *bool                `json:"sendSms,omitempty"`
	SerialNumber *string              `json:"serialNumber,omitempty"`
	Supplier     B2bTaxInvoiceCompany `json:"supplier"`

	// SupplierDocumentKey  , , ('-','_')  
	SupplierDocumentKey *string `json:"supplierDocumentKey,omitempty"`

	// TaxationType  
	TaxationType      B2bTaxInvoiceTaxationType `json:"taxationType"`
	TotalAmount       int64                     `json:"totalAmount"`
	TotalSupplyAmount int64                     `json:"totalSupplyAmount"`
	TotalTaxAmount    int64                     `json:"totalTaxAmount"`

	// WriteDate   , `yyyy-MM-dd`  .
	WriteDate openapi_types.Date `json:"writeDate"`
}

// B2bTaxInvoiceIssuanceType  
type B2bTaxInvoiceIssuanceType string

// B2bTaxInvoiceItem 
type B2bTaxInvoiceItem struct {
	// Name  100
	Name *string `json:"name,omitempty"`

	// PurchaseDate   , `yyyy-MM-dd`  .
	PurchaseDate *openapi_types.Date `json:"purchaseDate,omitempty"`

	// Quantity BigDecimal 
	Quantity *Decimal `json:"quantity,omitempty"`
	Remark   *string  `json:"remark,omitempty"`

	// Spec  100
	Spec             *string `json:"spec,omitempty"`
	SupplyCostAmount *int64  `json:"supplyCostAmount,omitempty"`
	TaxAmount        *int64  `json:"taxAmount,omitempty"`

	// UnitCostAmount BigDecimal 
	UnitCostAmount *Decimal `json:"unitCostAmount,omitempty"`
}

// B2bTaxInvoiceKeyType   
type B2bTaxInvoiceKeyType string

// B2bTaxInvoiceModification   
type B2bTaxInvoiceModification struct {
	OriginalNtsApprovalNumber string `json:"originalNtsApprovalNumber"`
	OriginalTaxInvoiceId      string `json:"originalTaxInvoiceId"`
	RootTaxInvoiceId          string `json:"rootTaxInvoiceId"`

	// Type  
	Type B2bTaxInvoiceModificationType `json:"type"`
}

// B2bTaxInvoiceModificationCreateBody     
type B2bTaxInvoiceModificationCreateBody struct {
	// Brn taxInvoiceKeyType TAX_INVOICE_ID    .
	Brn           *string `json:"brn,omitempty"`
	TaxInvoiceKey string  `json:"taxInvoiceKey"`

	// TaxInvoiceKeyType   
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `json:"taxInvoiceKeyType,omitempty"`

	// Type  
	Type B2bTaxInvoiceModificationType `json:"type"`
}

// B2bTaxInvoiceModificationType  
type B2bTaxInvoiceModificationType string

// B2bTaxInvoiceNoRecipientDocumentKeyError       
type B2bTaxInvoiceNoRecipientDocumentKeyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNoSupplierDocumentKeyError       
type B2bTaxInvoiceNoSupplierDocumentKeyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNonDeletableStatusError      
//
//    `DRAFTED`, `ISSUE_REFUSED`, `REQUEST_CANCELLED_BY_RECIPIENT`, `ISSUE_CANCELLED_BY_SUPPLIER`, `SENDING_FAILED` .
type B2bTaxInvoiceNonDeletableStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNotDraftedStatusError      
type B2bTaxInvoiceNotDraftedStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNotFoundError    
type B2bTaxInvoiceNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNotIssuedStatusError  (ISSUED)   
type B2bTaxInvoiceNotIssuedStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceNotRequestedStatusError      
type B2bTaxInvoiceNotRequestedStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoicePurposeType /
type B2bTaxInvoicePurposeType string

// B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError         
type B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceStatus defines model for B2bTaxInvoiceStatus.
type B2bTaxInvoiceStatus string

// B2bTaxInvoiceSummary  
type B2bTaxInvoiceSummary struct {
	BulkTaxInvoiceId *string `json:"bulkTaxInvoiceId,omitempty"`

	// DocumentModificationType     
	DocumentModificationType B2bTaxInvoiceDocumentModificationType `json:"documentModificationType"`
	DraftedAt                *time.Time                            `json:"draftedAt,omitempty"`
	Id                       string                                `json:"id"`
	IsDelayed                *bool                                 `json:"isDelayed,omitempty"`

	// IssuanceDueDate   , `yyyy-MM-dd`  .
	IssuanceDueDate openapi_types.Date `json:"issuanceDueDate"`

	// IssuanceType  
	IssuanceType B2bTaxInvoiceIssuanceType `json:"issuanceType"`
	IssuedAt     *time.Time                `json:"issuedAt,omitempty"`

	// Items  99
	Items []B2bTaxInvoiceItem `json:"items"`
	Memo  *string             `json:"memo,omitempty"`

	// NtsApprovalNumber  ()   
	NtsApprovalNumber *string `json:"ntsApprovalNumber,omitempty"`
	NtsResult         *string `json:"ntsResult,omitempty"`

	// NtsResultCode      3 +  3 
	NtsResultCode       *string    `json:"ntsResultCode,omitempty"`
	NtsResultReceivedAt *time.Time `json:"ntsResultReceivedAt,omitempty"`
	NtsSentAt           *time.Time `json:"ntsSentAt,omitempty"`
	OpenedAt            *time.Time `json:"openedAt,omitempty"`
	PayoutId            *string    `json:"payoutId,omitempty"`

	// PurposeType /
	PurposeType  B2bTaxInvoicePurposeType `json:"purposeType"`
	RecipientBrn string                   `json:"recipientBrn"`

	// RecipientBusinessStatus  
	RecipientBusinessStatus *B2bCompanyStateBusinessStatus `json:"recipientBusinessStatus,omitempty"`

	// RecipientClosedSuspendedDate  CLOSED, SUSPENDED    
	RecipientClosedSuspendedDate *openapi_types.Date `json:"recipientClosedSuspendedDate,omitempty"`
	RecipientDocumentKey         *string             `json:"recipientDocumentKey,omitempty"`
	RecipientName                string              `json:"recipientName"`
	RecipientRepresentativeName  string              `json:"recipientRepresentativeName"`
	RequestedAt                  *time.Time          `json:"requestedAt,omitempty"`
	Status                       B2bTaxInvoiceStatus `json:"status"`
	StatusUpdatedAt              time.Time           `json:"statusUpdatedAt"`
	SupplierBrn                  string              `json:"supplierBrn"`
	SupplierDocumentKey          *string             `json:"supplierDocumentKey,omitempty"`
	SupplierName                 string              `json:"supplierName"`
	SupplierRepresentativeName   string              `json:"supplierRepresentativeName"`

	// TaxationType  
	TaxationType      B2bTaxInvoiceTaxationType `json:"taxationType"`
	TotalAmount       int64                     `json:"totalAmount"`
	TotalSupplyAmount int64                     `json:"totalSupplyAmount"`
	TotalTaxAmount    int64                     `json:"totalTaxAmount"`

	// WriteDate   , `yyyy-MM-dd`  .
	WriteDate openapi_types.Date `json:"writeDate"`
}

// B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError        
type B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// B2bTaxInvoiceTaxationType  
type B2bTaxInvoiceTaxationType string

// Bank 
type Bank string

// BankInfo  
type BankInfo struct {
	// Bank 
	Bank Bank `json:"bank"`

	// Name  
	Name BankInfoName `json:"name"`
}

// BankInfoName  
type BankInfoName struct {
	Ko string `json:"ko"`
}

// BeforeRegisteredPaymentEscrow    
type BeforeRegisteredPaymentEscrow struct {
	Status string `json:"status"`
}

// BillingKeyAlreadyDeletedError    
type BillingKeyAlreadyDeletedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// BillingKeyAlreadyIssuedError defines model for BillingKeyAlreadyIssuedError.
type BillingKeyAlreadyIssuedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// BillingKeyDeleteRequester    
type BillingKeyDeleteRequester string

// BillingKeyFailure    
type BillingKeyFailure struct {
	FailedAt  time.Time `json:"failedAt"`
	Message   *string   `json:"message,omitempty"`
	PgCode    *string   `json:"pgCode,omitempty"`
	PgMessage *string   `json:"pgMessage,omitempty"`
}

// BillingKeyFilterInput      
type BillingKeyFilterInput struct {
	// ChannelGroupIds          .
	ChannelGroupIds *[]string `json:"channelGroupIds,omitempty"`
	CustomerId      *string   `json:"customerId,omitempty"`

	// From    end 90  .
	From *time.Time `json:"from,omitempty"`

	// Methods       .
	Methods *[]BillingKeyPaymentMethodType `json:"methods,omitempty"`

	// PgCompanies    PG   .
	PgCompanies *[]PgCompany `json:"pgCompanies,omitempty"`

	// PgProviders    PG     .
	PgProviders *[]PgProvider `json:"pgProviders,omitempty"`

	// PlatformType    
	PlatformType *PaymentClientType `json:"platformType,omitempty"`

	// Status        .
	Status *[]BillingKeyStatus `json:"status,omitempty"`

	// StoreId Merchant  ,       .
	StoreId *string `json:"storeId,omitempty"`

	// TextSearch   
	TextSearch *BillingKeyTextSearch `json:"textSearch,omitempty"`

	// TimeRangeField    ,    
	TimeRangeField *BillingKeyTimeRangeField `json:"timeRangeField,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`

	// Version  
	Version *PortOneVersion `json:"version,omitempty"`
}

// BillingKeyInfo  
type BillingKeyInfo struct {
	union json.RawMessage
}

// BillingKeyInfoSummary defines model for BillingKeyInfoSummary.
type BillingKeyInfoSummary struct {
	BillingKey string             `json:"billingKey"`
	Channels   *[]SelectedChannel `json:"channels,omitempty"`
	IssuedAt   time.Time          `json:"issuedAt"`
}

// BillingKeyNotFoundError    
type BillingKeyNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// BillingKeyNotIssuedError defines model for BillingKeyNotIssuedError.
type BillingKeyNotIssuedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// BillingKeyPaymentInput     
type BillingKeyPaymentInput struct {
	// Amount    
	Amount     PaymentAmountInput      `json:"amount"`
	BillingKey string                  `json:"billingKey"`
	Bypass     *map[string]interface{} `json:"bypass,omitempty"`

	// CashReceipt   
	CashReceipt *CashReceiptInput `json:"cashReceipt,omitempty"`

	// ChannelKey      ,      
	ChannelKey *string `json:"channelKey,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer    
	Customer         *CustomerInput `json:"customer,omitempty"`
	InstallmentMonth *int32         `json:"installmentMonth,omitempty"`

	// Locale  
	Locale *Locale `json:"locale,omitempty"`

	// NoticeUrls  /     .
	//      .
	//   .
	NoticeUrls   *[]string `json:"noticeUrls,omitempty"`
	OrderName    string    `json:"orderName"`
	ProductCount *int32    `json:"productCount,omitempty"`

	// ProductType  
	ProductType *PaymentProductType `json:"productType,omitempty"`

	// Products       .
	Products    *[]PaymentProduct `json:"products,omitempty"`
	PromotionId *string           `json:"promotionId,omitempty"`

	// ShippingAddress     
	ShippingAddress *SeparatedAddressInput `json:"shippingAddress,omitempty"`

	// StoreId       ,      .
	StoreId                     *string `json:"storeId,omitempty"`
	UseCardPoint                *bool   `json:"useCardPoint,omitempty"`
	UseFreeInterestFromMerchant *bool   `json:"useFreeInterestFromMerchant,omitempty"`
}

// BillingKeyPaymentMethod    
type BillingKeyPaymentMethod struct {
	union json.RawMessage
}

// BillingKeyPaymentMethodCard  
type BillingKeyPaymentMethodCard struct {
	// Card   
	Card *Card  `json:"card,omitempty"`
	Type string `json:"type"`
}

// BillingKeyPaymentMethodEasyPay   
type BillingKeyPaymentMethodEasyPay struct {
	// Method   
	Method *BillingKeyPaymentMethodEasyPayMethod `json:"method,omitempty"`

	// Provider  
	Provider *EasyPayProvider `json:"provider,omitempty"`
	Type     string           `json:"type"`
}

// BillingKeyPaymentMethodEasyPayCharge    
type BillingKeyPaymentMethodEasyPayCharge struct {
	Type string `json:"type"`
}

// BillingKeyPaymentMethodEasyPayMethod   
type BillingKeyPaymentMethodEasyPayMethod struct {
	union json.RawMessage
}

// BillingKeyPaymentMethodMobile  
type BillingKeyPaymentMethodMobile struct {
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Type        string  `json:"type"`
}

// BillingKeyPaymentMethodPaypal  
type BillingKeyPaymentMethodPaypal struct {
	Type string `json:"type"`
}

// BillingKeyPaymentMethodTransfer  
type BillingKeyPaymentMethodTransfer struct {
	AccountNumber *string `json:"accountNumber,omitempty"`

	// Bank 
	Bank *Bank  `json:"bank,omitempty"`
	Type string `json:"type"`
}

// BillingKeyPaymentMethodType   
type BillingKeyPaymentMethodType string

// BillingKeyPaymentSummary       
type BillingKeyPaymentSummary struct {
	PaidAt time.Time `json:"paidAt"`
	PgTxId string    `json:"pgTxId"`
}

// BillingKeySortBy   
type BillingKeySortBy string

// BillingKeySortInput      
type BillingKeySortInput struct {
	// By   
	By *BillingKeySortBy `json:"by,omitempty"`

	// Order  
	Order *SortOrder `json:"order,omitempty"`
}

// BillingKeyStatus  
type BillingKeyStatus string

// BillingKeyTextSearch   
type BillingKeyTextSearch struct {
	// Field  
	Field BillingKeyTextSearchField `json:"field"`
	Value string                    `json:"value"`
}

// BillingKeyTextSearchField  
type BillingKeyTextSearchField string

// BillingKeyTimeRangeField    ,    
type BillingKeyTimeRangeField string

// CancelAmountExceedsCancellableAmountError        
type CancelAmountExceedsCancellableAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CancelB2bTaxInvoiceIssuanceBody   
type CancelB2bTaxInvoiceIssuanceBody struct {
	Memo *string `json:"memo,omitempty"`
}

// CancelB2bTaxInvoiceIssuanceError defines model for CancelB2bTaxInvoiceIssuanceError.
type CancelB2bTaxInvoiceIssuanceError struct {
	union json.RawMessage
}

// CancelB2bTaxInvoiceIssuanceResponse   
type CancelB2bTaxInvoiceIssuanceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// CancelB2bTaxInvoiceRequestBody     
type CancelB2bTaxInvoiceRequestBody struct {
	Memo *string `json:"memo,omitempty"`
}

// CancelB2bTaxInvoiceRequestError defines model for CancelB2bTaxInvoiceRequestError.
type CancelB2bTaxInvoiceRequestError struct {
	union json.RawMessage
}

// CancelB2bTaxInvoiceRequestResponse     
type CancelB2bTaxInvoiceRequestResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// CancelCashReceiptError defines model for CancelCashReceiptError.
type CancelCashReceiptError struct {
	union json.RawMessage
}

// CancelCashReceiptResponse     
type CancelCashReceiptResponse struct {
	CancelledAmount int64     `json:"cancelledAmount"`
	CancelledAt     time.Time `json:"cancelledAt"`
}

// CancelPaymentBody     
type CancelPaymentBody struct {
	// Amount     .
	Amount *int64 `json:"amount,omitempty"`

	// CurrentCancellableAmount       ,       .        .
	CurrentCancellableAmount      *int64                         `json:"currentCancellableAmount,omitempty"`
	PromotionDiscountRetainOption *PromotionDiscountRetainOption `json:"promotionDiscountRetainOption,omitempty"`
	Reason                        string                         `json:"reason"`

	// RefundAccount    
	RefundAccount *CancelPaymentBodyRefundAccount `json:"refundAccount,omitempty"`

	// Requester    
	Requester *CancelRequester `json:"requester,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// TaxFreeAmount      .
	TaxFreeAmount *int64 `json:"taxFreeAmount,omitempty"`

	// VatAmount     .
	VatAmount *int64 `json:"vatAmount,omitempty"`
}

// CancelPaymentBodyRefundAccount    
type CancelPaymentBodyRefundAccount struct {
	// Bank 
	Bank              Bank    `json:"bank"`
	HolderName        string  `json:"holderName"`
	HolderPhoneNumber *string `json:"holderPhoneNumber,omitempty"`
	Number            string  `json:"number"`
}

// CancelPaymentError defines model for CancelPaymentError.
type CancelPaymentError struct {
	union json.RawMessage
}

// CancelPaymentResponse    
type CancelPaymentResponse struct {
	// Cancellation   
	Cancellation PaymentCancellation `json:"cancellation"`
}

// CancelPlatformAdditionalFeePolicyScheduleError defines model for CancelPlatformAdditionalFeePolicyScheduleError.
type CancelPlatformAdditionalFeePolicyScheduleError struct {
	union json.RawMessage
}

// CancelPlatformAdditionalFeePolicyScheduleResponse        
type CancelPlatformAdditionalFeePolicyScheduleResponse = map[string]interface{}

// CancelPlatformContractScheduleError defines model for CancelPlatformContractScheduleError.
type CancelPlatformContractScheduleError struct {
	union json.RawMessage
}

// CancelPlatformContractScheduleResponse      
type CancelPlatformContractScheduleResponse = map[string]interface{}

// CancelPlatformDiscountSharePolicyScheduleError defines model for CancelPlatformDiscountSharePolicyScheduleError.
type CancelPlatformDiscountSharePolicyScheduleError struct {
	union json.RawMessage
}

// CancelPlatformDiscountSharePolicyScheduleResponse        
type CancelPlatformDiscountSharePolicyScheduleResponse = map[string]interface{}

// CancelPlatformPartnerScheduleError defines model for CancelPlatformPartnerScheduleError.
type CancelPlatformPartnerScheduleError struct {
	union json.RawMessage
}

// CancelPlatformPartnerScheduleResponse      
type CancelPlatformPartnerScheduleResponse = map[string]interface{}

// CancelRequester    
type CancelRequester string

// CancelTaxAmountExceedsCancellableTaxAmountError         
type CancelTaxAmountExceedsCancellableTaxAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError         
type CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CancellableAmountConsistencyBrokenError      
type CancellableAmountConsistencyBrokenError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CancelledCashReceipt  
type CancelledCashReceipt struct {
	Amount      int64     `json:"amount"`
	CancelledAt time.Time `json:"cancelledAt"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// Currency  
	Currency        Currency   `json:"currency"`
	IsManual        bool       `json:"isManual"`
	IssueNumber     string     `json:"issueNumber"`
	IssuedAt        time.Time  `json:"issuedAt"`
	MerchantId      string     `json:"merchantId"`
	OrderName       string     `json:"orderName"`
	PaymentId       string     `json:"paymentId"`
	PgReceiptId     *string    `json:"pgReceiptId,omitempty"`
	Status          string     `json:"status"`
	StatusUpdatedAt *time.Time `json:"statusUpdatedAt,omitempty"`
	StoreId         string     `json:"storeId"`
	TaxFreeAmount   *int64     `json:"taxFreeAmount,omitempty"`

	// Type  
	Type      *CashReceiptType `json:"type,omitempty"`
	Url       *string          `json:"url,omitempty"`
	VatAmount *int64           `json:"vatAmount,omitempty"`
}

// CancelledPayment    
type CancelledPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey    *string               `json:"billingKey,omitempty"`
	Cancellations []PaymentCancellation `json:"cancellations"`
	CancelledAt   time.Time             `json:"cancelledAt"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       *time.Time        `json:"paidAt,omitempty"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// CancelledPaymentCashReceipt  
type CancelledPaymentCashReceipt struct {
	CancelledAt time.Time `json:"cancelledAt"`

	// Currency  
	Currency      Currency  `json:"currency"`
	IssueNumber   string    `json:"issueNumber"`
	IssuedAt      time.Time `json:"issuedAt"`
	PgReceiptId   *string   `json:"pgReceiptId,omitempty"`
	Status        string    `json:"status"`
	TaxFreeAmount *int64    `json:"taxFreeAmount,omitempty"`
	TotalAmount   int64     `json:"totalAmount"`

	// Type  
	Type *CashReceiptType `json:"type,omitempty"`
	Url  *string          `json:"url,omitempty"`
}

// CancelledPaymentEscrow  
type CancelledPaymentEscrow struct {
	AppliedAt     *time.Time `json:"appliedAt,omitempty"`
	Company       string     `json:"company"`
	InvoiceNumber string     `json:"invoiceNumber"`
	SentAt        *time.Time `json:"sentAt,omitempty"`
	Status        string     `json:"status"`
}

// CancelledPaymentEvent    
type CancelledPaymentEvent struct {
	// Cancellation   
	Cancellation *PaymentCancellation `json:"cancellation,omitempty"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country   *Country  `json:"country,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// EventAmount    ,     .
	EventAmount       int64  `json:"eventAmount"`
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId *string `json:"scheduleId,omitempty"`
	StoreId    string  `json:"storeId"`

	// TotalAmount    
	TotalAmount   PaymentAmount `json:"totalAmount"`
	TransactionId string        `json:"transactionId"`
	Type          string        `json:"type"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// CancelledPaymentTransaction    
type CancelledPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey    *string               `json:"billingKey,omitempty"`
	Cancellations []PaymentCancellation `json:"cancellations"`
	CancelledAt   time.Time             `json:"cancelledAt"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       *time.Time        `json:"paidAt,omitempty"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// CapturePaymentBody    
type CapturePaymentBody struct {
	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// CapturePaymentError defines model for CapturePaymentError.
type CapturePaymentError struct {
	union json.RawMessage
}

// CapturePaymentResponse    
type CapturePaymentResponse = map[string]interface{}

// Card   
type Card struct {
	Bin *string `json:"bin,omitempty"`

	// Brand  
	Brand  *CardBrand `json:"brand,omitempty"`
	Issuer *string    `json:"issuer,omitempty"`
	Name   *string    `json:"name,omitempty"`
	Number *string    `json:"number,omitempty"`

	// OwnerType   
	OwnerType *CardOwnerType `json:"ownerType,omitempty"`
	Publisher *string        `json:"publisher,omitempty"`

	// Type  
	Type *CardType `json:"type,omitempty"`
}

// CardBrand  
type CardBrand string

// CardCredential    
type CardCredential struct {
	BirthOrBusinessRegistrationNumber *string `json:"birthOrBusinessRegistrationNumber,omitempty"`
	ExpiryMonth                       string  `json:"expiryMonth"`
	ExpiryYear                        string  `json:"expiryYear"`
	Number                            string  `json:"number"`
	PasswordTwoDigits                 *string `json:"passwordTwoDigits,omitempty"`
}

// CardOwnerType   
type CardOwnerType string

// CardPromotion  
type CardPromotion struct {
	// CardCompany    
	CardCompany PromotionCardCompany `json:"cardCompany"`
	CreatedAt   time.Time            `json:"createdAt"`

	// Currency  
	Currency Currency `json:"currency"`

	// DiscountPolicy   
	DiscountPolicy    PromotionDiscountPolicy `json:"discountPolicy"`
	EndAt             time.Time               `json:"endAt"`
	Id                string                  `json:"id"`
	MaxDiscountAmount *int64                  `json:"maxDiscountAmount,omitempty"`
	Name              string                  `json:"name"`
	RecoverOption     PromotionRecoverOption  `json:"recoverOption"`
	SpentAmount       int64                   `json:"spentAmount"`
	StartAt           time.Time               `json:"startAt"`
	Status            PromotionStatus         `json:"status"`
	StoreId           string                  `json:"storeId"`
	TerminatedAt      *time.Time              `json:"terminatedAt,omitempty"`
	TotalBudget       int64                   `json:"totalBudget"`
	Type              string                  `json:"type"`
}

// CardType  
type CardType string

// Carrier 
type Carrier string

// CashReceipt  
type CashReceipt struct {
	union json.RawMessage
}

// CashReceiptAlreadyIssuedError    
type CashReceiptAlreadyIssuedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CashReceiptFilterInput      
type CashReceiptFilterInput struct {
	// From    end 90  .
	From      *time.Time `json:"from,omitempty"`
	IsManual  *bool      `json:"isManual,omitempty"`
	IsTest    *bool      `json:"isTest,omitempty"`
	OrderName *string    `json:"orderName,omitempty"`
	PaymentId *string    `json:"paymentId,omitempty"`

	// PgCompanies    PG   .
	PgCompanies  *[]PgCompany `json:"pgCompanies,omitempty"`
	PgMerchantId *string      `json:"pgMerchantId,omitempty"`

	// PgProviders    PG     .
	PgProviders *[]PgProvider `json:"pgProviders,omitempty"`
	PgReceiptId *string       `json:"pgReceiptId,omitempty"`

	// Statuses      .
	Statuses *[]CashReceiptStatus `json:"statuses,omitempty"`

	// StoreId Merchant  ,       .
	StoreId *string `json:"storeId,omitempty"`

	// TimeRangeField    ,    
	TimeRangeField *CashReceiptTimeRangeField `json:"timeRangeField,omitempty"`

	// Types      .
	Types *[]CashReceiptType `json:"types,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`

	// Version  
	Version *PortOneVersion `json:"version,omitempty"`
}

// CashReceiptInput   
type CashReceiptInput struct {
	// CustomerIdentityNumber      .
	CustomerIdentityNumber *string `json:"customerIdentityNumber,omitempty"`

	// Type    
	Type CashReceiptInputType `json:"type"`
}

// CashReceiptInputType    
type CashReceiptInputType string

// CashReceiptNotFoundError    
type CashReceiptNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CashReceiptNotIssuedError    
type CashReceiptNotIssuedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// CashReceiptSortBy   
type CashReceiptSortBy string

// CashReceiptSortInput      
type CashReceiptSortInput struct {
	// By   
	By *CashReceiptSortBy `json:"by,omitempty"`

	// Order  
	Order *SortOrder `json:"order,omitempty"`
}

// CashReceiptStatus    
type CashReceiptStatus string

// CashReceiptSummary  
type CashReceiptSummary struct {
	IssueNumber string `json:"issueNumber"`
	PgReceiptId string `json:"pgReceiptId"`
	Url         string `json:"url"`
}

// CashReceiptTimeRangeField    ,    
type CashReceiptTimeRangeField string

// CashReceiptType  
type CashReceiptType string

// ChannelGroupSummary   
type ChannelGroupSummary struct {
	Id        string `json:"id"`
	IsForTest bool   `json:"isForTest"`
	Name      string `json:"name"`
}

// ChannelNotFoundError     
type ChannelNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// ChannelSpecificError    ,     
type ChannelSpecificError struct {
	Failures          []ChannelSpecificFailure `json:"failures"`
	Message           *string                  `json:"message,omitempty"`
	SucceededChannels []SelectedChannel        `json:"succeededChannels"`
	Type              string                   `json:"type"`
}

// ChannelSpecificFailure defines model for ChannelSpecificFailure.
type ChannelSpecificFailure struct {
	union json.RawMessage
}

// ChannelSpecificFailureInvalidRequest      
//
//   ,       .
type ChannelSpecificFailureInvalidRequest struct {
	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`
	Message *string         `json:"message,omitempty"`
	Type    string          `json:"type"`
}

// ChannelSpecificFailurePgProvider PG   
type ChannelSpecificFailurePgProvider struct {
	// Channel (,  )   
	Channel   SelectedChannel `json:"channel"`
	Message   *string         `json:"message,omitempty"`
	PgCode    string          `json:"pgCode"`
	PgMessage string          `json:"pgMessage"`
	Type      string          `json:"type"`
}

// CloseVirtualAccountError defines model for CloseVirtualAccountError.
type CloseVirtualAccountError struct {
	union json.RawMessage
}

// CloseVirtualAccountResponse    
type CloseVirtualAccountResponse struct {
	ClosedAt time.Time `json:"closedAt"`
}

// ConfirmBillingKeyBody     
type ConfirmBillingKeyBody struct {
	// BillingIssueToken       .
	BillingIssueToken string `json:"billingIssueToken"`

	// IsTest  ,         .
	IsTest *bool `json:"isTest,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// ConfirmBillingKeyError defines model for ConfirmBillingKeyError.
type ConfirmBillingKeyError struct {
	union json.RawMessage
}

// ConfirmBillingKeyIssueAndPayBody        
type ConfirmBillingKeyIssueAndPayBody struct {
	// BillingIssueToken          .
	BillingIssueToken string `json:"billingIssueToken"`

	// Currency  
	Currency *Currency `json:"currency,omitempty"`

	// IsTest  ,         .
	IsTest *bool `json:"isTest,omitempty"`

	// PaymentId  ,        .
	PaymentId *string `json:"paymentId,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// TaxFreeAmount  ,         .
	TaxFreeAmount *int64 `json:"taxFreeAmount,omitempty"`

	// TotalAmount  ,         .
	TotalAmount *int64 `json:"totalAmount,omitempty"`
}

// ConfirmBillingKeyIssueAndPayError defines model for ConfirmBillingKeyIssueAndPayError.
type ConfirmBillingKeyIssueAndPayError struct {
	union json.RawMessage
}

// ConfirmEscrowBody     
type ConfirmEscrowBody struct {
	// FromStore        .
	//   ,     (true) .
	FromStore *bool `json:"fromStore,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// ConfirmEscrowError defines model for ConfirmEscrowError.
type ConfirmEscrowError struct {
	union json.RawMessage
}

// ConfirmEscrowResponse     
type ConfirmEscrowResponse struct {
	CompletedAt time.Time `json:"completedAt"`
}

// ConfirmIdentityVerificationBody     
type ConfirmIdentityVerificationBody struct {
	// Otp SMS  .
	Otp *string `json:"otp,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// ConfirmIdentityVerificationError defines model for ConfirmIdentityVerificationError.
type ConfirmIdentityVerificationError struct {
	union json.RawMessage
}

// ConfirmIdentityVerificationResponse    
type ConfirmIdentityVerificationResponse struct {
	// IdentityVerification   
	IdentityVerification VerifiedIdentityVerification `json:"identityVerification"`
}

// ConfirmPaymentBody    
type ConfirmPaymentBody struct {
	// Currency  
	Currency *Currency `json:"currency,omitempty"`

	// IsTest  ,         .   .
	IsTest *bool `json:"isTest,omitempty"`

	// PaymentToken     .
	PaymentToken string `json:"paymentToken"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// TaxFreeAmount  ,         .
	TaxFreeAmount *int64 `json:"taxFreeAmount,omitempty"`

	// TotalAmount  ,         .   .
	TotalAmount *int64 `json:"totalAmount,omitempty"`

	// TxId  ,        .
	TxId *string `json:"txId,omitempty"`
}

// ConfirmPaymentError defines model for ConfirmPaymentError.
type ConfirmPaymentError struct {
	union json.RawMessage
}

// ConfirmedBillingKeyIssueAndPaySummary         
type ConfirmedBillingKeyIssueAndPaySummary struct {
	BillingKey string `json:"billingKey"`
	PaymentId  string `json:"paymentId"`
}

// ConfirmedBillingKeySummary      
type ConfirmedBillingKeySummary struct {
	BillingKey string `json:"billingKey"`
}

// ConfirmedPaymentEscrow  
type ConfirmedPaymentEscrow struct {
	AppliedAt                *time.Time `json:"appliedAt,omitempty"`
	Company                  string     `json:"company"`
	InvoiceNumber            string     `json:"invoiceNumber"`
	IsAutomaticallyConfirmed bool       `json:"isAutomaticallyConfirmed"`
	SentAt                   *time.Time `json:"sentAt,omitempty"`
	Status                   string     `json:"status"`
}

// ConfirmedPaymentSummary        
type ConfirmedPaymentSummary struct {
	PaidAt time.Time `json:"paidAt"`
	PgTxId string    `json:"pgTxId"`
}

// ConnectBulkPartnerMemberCompanyBody      
//
//    .
type ConnectBulkPartnerMemberCompanyBody struct {
	// Filter    
	Filter *PlatformPartnerFilterInput `json:"filter,omitempty"`
}

// ConnectBulkPartnerMemberCompanyError defines model for ConnectBulkPartnerMemberCompanyError.
type ConnectBulkPartnerMemberCompanyError struct {
	union json.RawMessage
}

// ConnectBulkPartnerMemberCompanyResponse     
type ConnectBulkPartnerMemberCompanyResponse struct {
	BulkTask PlatformBulkTask `json:"bulkTask"`
}

// ConnectPartnerMemberCompanyError defines model for ConnectPartnerMemberCompanyError.
type ConnectPartnerMemberCompanyError struct {
	union json.RawMessage
}

// ConnectPartnerMemberCompanyResponse    
type ConnectPartnerMemberCompanyResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// ConvenienceStoreBrand  
type ConvenienceStoreBrand string

// Country 
type Country string

// CreateB2bFileUploadUrlBody   URL   
type CreateB2bFileUploadUrlBody struct {
	FileName string `json:"fileName"`
}

// CreateB2bFileUploadUrlError defines model for CreateB2bFileUploadUrlError.
type CreateB2bFileUploadUrlError struct {
	union json.RawMessage
}

// CreateB2bFileUploadUrlPayload   URL   
type CreateB2bFileUploadUrlPayload struct {
	FileId string `json:"fileId"`
	Url    string `json:"url"`
}

// CreateManualTransferResponse defines model for CreateManualTransferResponse.
type CreateManualTransferResponse struct {
	// Transfer  
	Transfer PlatformManualTransfer `json:"transfer"`
}

// CreateOrderCancelTransferResponse defines model for CreateOrderCancelTransferResponse.
type CreateOrderCancelTransferResponse struct {
	// Transfer   
	Transfer PlatformOrderCancelTransfer `json:"transfer"`
}

// CreateOrderTransferResponse defines model for CreateOrderTransferResponse.
type CreateOrderTransferResponse struct {
	// Transfer  
	Transfer PlatformOrderTransfer `json:"transfer"`
}

// CreatePaymentScheduleBody     
type CreatePaymentScheduleBody struct {
	// Payment     
	Payment   BillingKeyPaymentInput `json:"payment"`
	TimeToPay time.Time              `json:"timeToPay"`
}

// CreatePaymentScheduleError defines model for CreatePaymentScheduleError.
type CreatePaymentScheduleError struct {
	union json.RawMessage
}

// CreatePaymentScheduleResponse    
type CreatePaymentScheduleResponse struct {
	// Schedule   
	Schedule PaymentScheduleSummary `json:"schedule"`
}

// CreatePlatformAdditionalFeePolicyBody       
type CreatePlatformAdditionalFeePolicyBody struct {
	// Fee       
	//
	//      `fixedRate` ,      `fixedAmount`    .
	//         .
	Fee PlatformFeeInput `json:"fee"`

	// Id   id   .
	Id   *string `json:"id,omitempty"`
	Memo *string `json:"memo,omitempty"`
	Name string  `json:"name"`

	// VatPayer   
	//
	//    ,      .
	VatPayer PlatformPayer `json:"vatPayer"`
}

// CreatePlatformAdditionalFeePolicyError defines model for CreatePlatformAdditionalFeePolicyError.
type CreatePlatformAdditionalFeePolicyError struct {
	union json.RawMessage
}

// CreatePlatformAdditionalFeePolicyResponse     
type CreatePlatformAdditionalFeePolicyResponse struct {
	// AdditionalFeePolicy   
	//
	//           .     ,  ,    .
	AdditionalFeePolicy PlatformAdditionalFeePolicy `json:"additionalFeePolicy"`
}

// CreatePlatformContractBody      
type CreatePlatformContractBody struct {
	// Id       .
	Id   *string `json:"id,omitempty"`
	Memo *string `json:"memo,omitempty"`
	Name string  `json:"name"`

	// PlatformFee       
	//
	//      `fixedRate` ,      `fixedAmount`    .
	//         .
	PlatformFee PlatformFeeInput `json:"platformFee"`

	// PlatformFeeVatPayer   
	//
	//    ,      .
	PlatformFeeVatPayer PlatformPayer `json:"platformFeeVatPayer"`

	// SettlementCycle     
	SettlementCycle          PlatformSettlementCycleInput `json:"settlementCycle"`
	SubtractPaymentVatAmount bool                         `json:"subtractPaymentVatAmount"`
}

// CreatePlatformContractError defines model for CreatePlatformContractError.
type CreatePlatformContractError struct {
	union json.RawMessage
}

// CreatePlatformContractResponse     
type CreatePlatformContractResponse struct {
	// Contract 
	//
	//           .
	//             .
	Contract PlatformContract `json:"contract"`
}

// CreatePlatformDiscountSharePolicyBody       
type CreatePlatformDiscountSharePolicyBody struct {
	// Id       .
	Id               *string `json:"id,omitempty"`
	Memo             *string `json:"memo,omitempty"`
	Name             string  `json:"name"`
	PartnerShareRate int32   `json:"partnerShareRate"`
}

// CreatePlatformDiscountSharePolicyError defines model for CreatePlatformDiscountSharePolicyError.
type CreatePlatformDiscountSharePolicyError struct {
	union json.RawMessage
}

// CreatePlatformDiscountSharePolicyResponse      
type CreatePlatformDiscountSharePolicyResponse struct {
	// DiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	DiscountSharePolicy PlatformDiscountSharePolicy `json:"discountSharePolicy"`
}

// CreatePlatformManualTransferBody      
type CreatePlatformManualTransferBody struct {
	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest        *bool   `json:"isForTest,omitempty"`
	Memo             *string `json:"memo,omitempty"`
	PartnerId        string  `json:"partnerId"`
	SettlementAmount int64   `json:"settlementAmount"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate          openapi_types.Date                     `json:"settlementDate"`
	SettlementTaxFreeAmount *int64                                 `json:"settlementTaxFreeAmount,omitempty"`
	UserDefinedProperties   *[]PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties,omitempty"`
}

// CreatePlatformManualTransferError defines model for CreatePlatformManualTransferError.
type CreatePlatformManualTransferError struct {
	union json.RawMessage
}

// CreatePlatformOrderCancelTransferBody       
//
//  payment      (partnerId, paymentId)     .
//  payment       transferId   .
// transferId   (partnerId, paymentId)  .
type CreatePlatformOrderCancelTransferBody struct {
	CancellationId string                                          `json:"cancellationId"`
	Discounts      []CreatePlatformOrderCancelTransferBodyDiscount `json:"discounts"`

	// ExternalCancellationDetail    
	ExternalCancellationDetail *CreatePlatformOrderCancelTransferBodyExternalCancellationDetail `json:"externalCancellationDetail,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool   `json:"isForTest,omitempty"`
	Memo      *string `json:"memo,omitempty"`

	// OrderDetail   
	//
	// orderAmount, orderLines, all    .
	OrderDetail *CreatePlatformOrderCancelTransferBodyOrderDetail `json:"orderDetail,omitempty"`
	PartnerId   *string                                           `json:"partnerId,omitempty"`
	PaymentId   *string                                           `json:"paymentId,omitempty"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate *openapi_types.Date `json:"settlementDate,omitempty"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate *openapi_types.Date `json:"settlementStartDate,omitempty"`

	// TaxFreeAmount                       .
	TaxFreeAmount         *int64                                 `json:"taxFreeAmount,omitempty"`
	TransferId            *string                                `json:"transferId,omitempty"`
	UserDefinedProperties *[]PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties,omitempty"`
}

// CreatePlatformOrderCancelTransferBodyDiscount  
type CreatePlatformOrderCancelTransferBodyDiscount struct {
	Amount        int64  `json:"amount"`
	SharePolicyId string `json:"sharePolicyId"`
	TaxFreeAmount *int64 `json:"taxFreeAmount,omitempty"`
}

// CreatePlatformOrderCancelTransferBodyExternalCancellationDetail    
type CreatePlatformOrderCancelTransferBodyExternalCancellationDetail struct {
	CancelledAt *time.Time `json:"cancelledAt,omitempty"`
}

// CreatePlatformOrderCancelTransferBodyOrderDetail   
//
// orderAmount, orderLines, all    .
type CreatePlatformOrderCancelTransferBodyOrderDetail struct {
	// All   
	All         *CreatePlatformOrderCancelTransferBodyOrderDetailAll `json:"all,omitempty"`
	OrderAmount *int64                                               `json:"orderAmount,omitempty"`
	OrderLines  *[]CreatePlatformOrderCancelTransferBodyOrderLine    `json:"orderLines,omitempty"`
}

// CreatePlatformOrderCancelTransferBodyOrderDetailAll   
type CreatePlatformOrderCancelTransferBodyOrderDetailAll = map[string]interface{}

// CreatePlatformOrderCancelTransferBodyOrderLine    
type CreatePlatformOrderCancelTransferBodyOrderLine struct {
	Discounts []CreatePlatformOrderCancelTransferBodyDiscount `json:"discounts"`
	ProductId string                                          `json:"productId"`
	Quantity  int32                                           `json:"quantity"`
}

// CreatePlatformOrderCancelTransferError defines model for CreatePlatformOrderCancelTransferError.
type CreatePlatformOrderCancelTransferError struct {
	union json.RawMessage
}

// CreatePlatformOrderTransferBody      
type CreatePlatformOrderTransferBody struct {
	AdditionalFees []CreatePlatformOrderTransferBodyAdditionalFee `json:"additionalFees"`

	// ContractId      .
	ContractId *string                                   `json:"contractId,omitempty"`
	Discounts  []CreatePlatformOrderTransferBodyDiscount `json:"discounts"`

	// ExternalPaymentDetail    
	ExternalPaymentDetail *CreatePlatformOrderTransferBodyExternalPaymentDetail `json:"externalPaymentDetail,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool   `json:"isForTest,omitempty"`
	Memo      *string `json:"memo,omitempty"`

	// OrderDetail  
	//
	//        .
	OrderDetail CreatePlatformOrderTransferBodyOrderDetail `json:"orderDetail"`
	Parameters  *TransferParameters                        `json:"parameters,omitempty"`
	PartnerId   string                                     `json:"partnerId"`
	PaymentId   string                                     `json:"paymentId"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate *openapi_types.Date `json:"settlementDate,omitempty"`

	// SettlementStartDate    .
	SettlementStartDate *openapi_types.Date `json:"settlementStartDate,omitempty"`

	// TaxFreeAmount                  .
	TaxFreeAmount         *int64                                 `json:"taxFreeAmount,omitempty"`
	UserDefinedProperties *[]PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties,omitempty"`
}

// CreatePlatformOrderTransferBodyAdditionalFee   
type CreatePlatformOrderTransferBodyAdditionalFee struct {
	PolicyId string `json:"policyId"`
}

// CreatePlatformOrderTransferBodyDiscount  
type CreatePlatformOrderTransferBodyDiscount struct {
	Amount        int64  `json:"amount"`
	SharePolicyId string `json:"sharePolicyId"`
	TaxFreeAmount *int64 `json:"taxFreeAmount,omitempty"`
}

// CreatePlatformOrderTransferBodyExternalPaymentDetail    
type CreatePlatformOrderTransferBodyExternalPaymentDetail struct {
	// Currency  
	Currency Currency `json:"currency"`

	// Method    
	Method    *PlatformPaymentMethodInput `json:"method,omitempty"`
	OrderName *string                     `json:"orderName,omitempty"`
	PaidAt    *time.Time                  `json:"paidAt,omitempty"`
}

// CreatePlatformOrderTransferBodyOrderDetail  
//
//        .
type CreatePlatformOrderTransferBodyOrderDetail struct {
	OrderAmount *int64                                      `json:"orderAmount,omitempty"`
	OrderLines  *[]CreatePlatformOrderTransferBodyOrderLine `json:"orderLines,omitempty"`
}

// CreatePlatformOrderTransferBodyOrderLine  
type CreatePlatformOrderTransferBodyOrderLine struct {
	AdditionalFees []CreatePlatformOrderTransferBodyAdditionalFee `json:"additionalFees"`
	Discounts      []CreatePlatformOrderTransferBodyDiscount      `json:"discounts"`

	// Product 
	Product  CreatePlatformOrderTransferBodyProduct `json:"product"`
	Quantity int32                                  `json:"quantity"`
}

// CreatePlatformOrderTransferBodyProduct 
type CreatePlatformOrderTransferBodyProduct struct {
	Amount        int64   `json:"amount"`
	Id            string  `json:"id"`
	Name          string  `json:"name"`
	Tag           *string `json:"tag,omitempty"`
	TaxFreeAmount *int64  `json:"taxFreeAmount,omitempty"`
}

// CreatePlatformOrderTransferError defines model for CreatePlatformOrderTransferError.
type CreatePlatformOrderTransferError struct {
	union json.RawMessage
}

// CreatePlatformPartnerBody     
type CreatePlatformPartnerBody struct {
	// Account     
	Account CreatePlatformPartnerBodyAccount `json:"account"`

	// Contact   
	Contact CreatePlatformPartnerBodyContact `json:"contact"`

	// DefaultContractId      .
	DefaultContractId string `json:"defaultContractId"`

	// Id          .       .
	Id *string `json:"id,omitempty"`

	// Memo  256   .
	Memo *string `json:"memo,omitempty"`
	Name string  `json:"name"`

	// Tags  10   .
	Tags []string `json:"tags"`

	// Type      
	Type                  CreatePlatformPartnerBodyType `json:"type"`
	UserDefinedProperties *PlatformProperties           `json:"userDefinedProperties,omitempty"`
}

// CreatePlatformPartnerBodyAccount     
type CreatePlatformPartnerBodyAccount struct {
	AccountVerificationId *string `json:"accountVerificationId,omitempty"`

	// Bank 
	Bank Bank `json:"bank"`

	// Currency  
	Currency Currency `json:"currency"`
	Holder   string   `json:"holder"`
	Number   string   `json:"number"`
}

// CreatePlatformPartnerBodyContact   
type CreatePlatformPartnerBodyContact struct {
	Email       string  `json:"email"`
	Name        string  `json:"name"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// CreatePlatformPartnerBodyType      
type CreatePlatformPartnerBodyType struct {
	Business    *CreatePlatformPartnerBodyTypeBusiness    `json:"business,omitempty"`
	NonWhtPayer *CreatePlatformPartnerBodyTypeNonWhtPayer `json:"nonWhtPayer,omitempty"`
	WhtPayer    *CreatePlatformPartnerBodyTypeWhtPayer    `json:"whtPayer,omitempty"`
}

// CreatePlatformPartnerBodyTypeBusiness defines model for CreatePlatformPartnerBodyTypeBusiness.
type CreatePlatformPartnerBodyTypeBusiness struct {
	BusinessClass              *string `json:"businessClass,omitempty"`
	BusinessRegistrationNumber string  `json:"businessRegistrationNumber"`
	BusinessType               *string `json:"businessType,omitempty"`
	CompanyAddress             *string `json:"companyAddress,omitempty"`
	CompanyName                string  `json:"companyName"`
	CompanyVerificationId      *string `json:"companyVerificationId,omitempty"`
	RepresentativeName         string  `json:"representativeName"`

	// TaxationType    
	TaxationType *PlatformPartnerTaxationType `json:"taxationType,omitempty"`
}

// CreatePlatformPartnerBodyTypeNonWhtPayer defines model for CreatePlatformPartnerBodyTypeNonWhtPayer.
type CreatePlatformPartnerBodyTypeNonWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// CreatePlatformPartnerBodyTypeWhtPayer defines model for CreatePlatformPartnerBodyTypeWhtPayer.
type CreatePlatformPartnerBodyTypeWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// CreatePlatformPartnerError defines model for CreatePlatformPartnerError.
type CreatePlatformPartnerError struct {
	union json.RawMessage
}

// CreatePlatformPartnerResponse    
type CreatePlatformPartnerResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// CreatePlatformPartnersBody      
type CreatePlatformPartnersBody struct {
	Partners []CreatePlatformPartnerBody `json:"partners"`
}

// CreatePlatformPartnersError defines model for CreatePlatformPartnersError.
type CreatePlatformPartnersError struct {
	union json.RawMessage
}

// CreatePlatformPartnersResponse     
type CreatePlatformPartnersResponse struct {
	Partners []PlatformPartner `json:"partners"`
}

// Currency  
type Currency string

// Customer  
type Customer struct {
	// Address   
	//
	// oneLine(   )   .
	Address    *Address `json:"address,omitempty"`
	BirthDay   *string  `json:"birthDay,omitempty"`
	BirthMonth *string  `json:"birthMonth,omitempty"`
	BirthYear  *string  `json:"birthYear,omitempty"`
	Email      *string  `json:"email,omitempty"`

	// Gender 
	Gender *Gender `json:"gender,omitempty"`

	// Id     .
	Id          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Zipcode     *string `json:"zipcode,omitempty"`
}

// CustomerInput    
type CustomerInput struct {
	// Address     
	Address                    *SeparatedAddressInput `json:"address,omitempty"`
	BirthDay                   *string                `json:"birthDay,omitempty"`
	BirthMonth                 *string                `json:"birthMonth,omitempty"`
	BirthYear                  *string                `json:"birthYear,omitempty"`
	BusinessRegistrationNumber *string                `json:"businessRegistrationNumber,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`
	Email   *string  `json:"email,omitempty"`

	// Gender 
	Gender *Gender `json:"gender,omitempty"`

	// Id     .
	Id *string `json:"id,omitempty"`

	// Name    
	//
	//         .
	Name        *CustomerNameInput `json:"name,omitempty"`
	PhoneNumber *string            `json:"phoneNumber,omitempty"`
	Zipcode     *string            `json:"zipcode,omitempty"`
}

// CustomerNameInput    
//
//         .
type CustomerNameInput struct {
	Full *string `json:"full,omitempty"`

	// Separated   
	Separated *CustomerSeparatedName `json:"separated,omitempty"`
}

// CustomerSeparatedName   
type CustomerSeparatedName struct {
	First string `json:"first"`
	Last  string `json:"last"`
}

// DateRange defines model for DateRange.
type DateRange struct {
	// From   , `yyyy-MM-dd`  .
	From openapi_types.Date `json:"from"`

	// Until   , `yyyy-MM-dd`  .
	Until openapi_types.Date `json:"until"`
}

// DateRangeOption defines model for DateRangeOption.
type DateRangeOption struct {
	// From   , `yyyy-MM-dd`  .
	From *openapi_types.Date `json:"from,omitempty"`

	// Until   , `yyyy-MM-dd`  .
	Until *openapi_types.Date `json:"until,omitempty"`
}

// DateTimeRange  
type DateTimeRange struct {
	From  time.Time `json:"from"`
	Until time.Time `json:"until"`
}

// DayOfWeek 
type DayOfWeek string

// Decimal BigDecimal 
type Decimal struct {
	// Scale      .  0.  , 123.45  2 .
	Scale *int32 `json:"scale,omitempty"`

	// Value   (unscaled)   .  , 123.45  12345 .
	Value int64 `json:"value"`
}

// DeleteB2bTaxInvoiceAttachmentError defines model for DeleteB2bTaxInvoiceAttachmentError.
type DeleteB2bTaxInvoiceAttachmentError struct {
	union json.RawMessage
}

// DeleteB2bTaxInvoiceError defines model for DeleteB2bTaxInvoiceError.
type DeleteB2bTaxInvoiceError struct {
	union json.RawMessage
}

// DeleteB2bTaxInvoiceResponse defines model for DeleteB2bTaxInvoiceResponse.
type DeleteB2bTaxInvoiceResponse = map[string]interface{}

// DeleteBillingKeyError defines model for DeleteBillingKeyError.
type DeleteBillingKeyError struct {
	union json.RawMessage
}

// DeleteBillingKeyResponse    
type DeleteBillingKeyResponse struct {
	DeletedAt time.Time `json:"deletedAt"`
}

// DeletePlatformTransferError defines model for DeletePlatformTransferError.
type DeletePlatformTransferError struct {
	union json.RawMessage
}

// DeletePlatformTransferResponse defines model for DeletePlatformTransferResponse.
type DeletePlatformTransferResponse = map[string]interface{}

// DeletedBillingKeyInfo     
type DeletedBillingKeyInfo struct {
	BillingKey string `json:"billingKey"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Channels           .
	Channels   []SelectedChannel `json:"channels"`
	CustomData *string           `json:"customData,omitempty"`

	// Customer  
	Customer   Customer  `json:"customer"`
	DeletedAt  time.Time `json:"deletedAt"`
	IssueId    *string   `json:"issueId,omitempty"`
	IssueName  *string   `json:"issueName,omitempty"`
	IssuedAt   time.Time `json:"issuedAt"`
	MerchantId string    `json:"merchantId"`

	// Methods           .
	Methods *[]BillingKeyPaymentMethod `json:"methods,omitempty"`

	// PgBillingKeyIssueResponses  ,          .
	PgBillingKeyIssueResponses *[]PgBillingKeyIssueResponse `json:"pgBillingKeyIssueResponses,omitempty"`
	RequestedAt                *time.Time                   `json:"requestedAt,omitempty"`
	Status                     string                       `json:"status"`
	StoreId                    string                       `json:"storeId"`
}

// DeliveredPaymentEscrow  
type DeliveredPaymentEscrow struct {
	AppliedAt     *time.Time `json:"appliedAt,omitempty"`
	Company       string     `json:"company"`
	InvoiceNumber string     `json:"invoiceNumber"`
	SentAt        *time.Time `json:"sentAt,omitempty"`
	Status        string     `json:"status"`
}

// DisconnectBulkPartnerMemberCompanyBody       
//
//     .
type DisconnectBulkPartnerMemberCompanyBody struct {
	// Filter    
	Filter *PlatformPartnerFilterInput `json:"filter,omitempty"`
}

// DisconnectBulkPartnerMemberCompanyError defines model for DisconnectBulkPartnerMemberCompanyError.
type DisconnectBulkPartnerMemberCompanyError struct {
	union json.RawMessage
}

// DisconnectBulkPartnerMemberCompanyResponse      
type DisconnectBulkPartnerMemberCompanyResponse struct {
	BulkTask PlatformBulkTask `json:"bulkTask"`
}

// DisconnectPartnerMemberCompanyError defines model for DisconnectPartnerMemberCompanyError.
type DisconnectPartnerMemberCompanyError struct {
	union json.RawMessage
}

// DisconnectPartnerMemberCompanyResponse     
type DisconnectPartnerMemberCompanyResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// DiscountAmountExceedsTotalAmountError        
type DiscountAmountExceedsTotalAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// Dispute  
type Dispute struct {
	CreatedAt   time.Time  `json:"createdAt"`
	PgDisputeId *string    `json:"pgDisputeId,omitempty"`
	Reason      string     `json:"reason"`
	ResolvedAt  *time.Time `json:"resolvedAt,omitempty"`

	// Status  
	Status DisputeStatus `json:"status"`
}

// DisputeStatus  
type DisputeStatus string

// DownloadB2bTaxInvoicesSheetBody defines model for DownloadB2bTaxInvoicesSheetBody.
type DownloadB2bTaxInvoicesSheetBody struct {
	Fields *[]TaxInvoicesSheetField `json:"fields,omitempty"`

	// Filter    
	Filter *GetB2bTaxInvoicesBodyFilter `json:"filter,omitempty"`
	Test   *bool                        `json:"test,omitempty"`
}

// DownloadB2bTaxInvoicesSheetError defines model for DownloadB2bTaxInvoicesSheetError.
type DownloadB2bTaxInvoicesSheetError struct {
	union json.RawMessage
}

// DownloadPlatformTransferSheetBody defines model for DownloadPlatformTransferSheetBody.
type DownloadPlatformTransferSheetBody struct {
	Fields *[]string `json:"fields,omitempty"`

	// Filter    
	//
	//           .
	Filter *PlatformTransferFilterInput `json:"filter,omitempty"`
}

// DownloadPlatformTransferSheetError defines model for DownloadPlatformTransferSheetError.
type DownloadPlatformTransferSheetError struct {
	union json.RawMessage
}

// DraftB2bTaxInvoiceBody    
type DraftB2bTaxInvoiceBody struct {
	Memo *string `json:"memo,omitempty"`

	// Modification     
	Modification *B2bTaxInvoiceModificationCreateBody `json:"modification,omitempty"`

	// TaxInvoice    
	TaxInvoice B2bTaxInvoiceInput `json:"taxInvoice"`
}

// DraftB2bTaxInvoiceError defines model for DraftB2bTaxInvoiceError.
type DraftB2bTaxInvoiceError struct {
	union json.RawMessage
}

// DraftB2bTaxInvoiceResponse    
type DraftB2bTaxInvoiceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// EasyPayMethodType   
type EasyPayMethodType string

// EasyPayProvider  
type EasyPayProvider string

// FailedIdentityVerification   
type FailedIdentityVerification struct {
	// Channel (,  )   
	Channel    *SelectedChannel `json:"channel,omitempty"`
	CustomData *string          `json:"customData,omitempty"`

	// Failure   
	Failure     IdentityVerificationFailure `json:"failure"`
	Id          string                      `json:"id"`
	RequestedAt time.Time                   `json:"requestedAt"`

	// RequestedCustomer    
	RequestedCustomer IdentityVerificationRequestedCustomer `json:"requestedCustomer"`
	Status            string                                `json:"status"`
	StatusChangedAt   time.Time                             `json:"statusChangedAt"`
	UpdatedAt         time.Time                             `json:"updatedAt"`

	// Version  
	Version PortOneVersion `json:"version"`
}

// FailedPayment    
type FailedPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel *SelectedChannel `json:"channel,omitempty"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow   *PaymentEscrow `json:"escrow,omitempty"`
	FailedAt time.Time      `json:"failedAt"`

	// Failure   
	Failure           PaymentFailure `json:"failure"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// FailedPaymentCancellation   
type FailedPaymentCancellation struct {
	CancelledAt           *time.Time `json:"cancelledAt,omitempty"`
	EasyPayDiscountAmount *int64     `json:"easyPayDiscountAmount,omitempty"`
	Id                    string     `json:"id"`
	PgCancellationId      *string    `json:"pgCancellationId,omitempty"`
	Reason                string     `json:"reason"`
	RequestedAt           time.Time  `json:"requestedAt"`
	Status                string     `json:"status"`
	TaxFreeAmount         int64      `json:"taxFreeAmount"`
	TotalAmount           int64      `json:"totalAmount"`
	Trigger               *Trigger   `json:"trigger,omitempty"`
	VatAmount             int64      `json:"vatAmount"`
}

// FailedPaymentSchedule   
type FailedPaymentSchedule struct {
	BillingKey  string    `json:"billingKey"`
	CompletedAt time.Time `json:"completedAt"`
	CreatedAt   time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	StartedAt         time.Time         `json:"startedAt"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// FailedPaymentTransaction    
type FailedPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel *SelectedChannel `json:"channel,omitempty"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow   *PaymentEscrow `json:"escrow,omitempty"`
	FailedAt time.Time      `json:"failedAt"`

	// Failure   
	Failure PaymentFailure `json:"failure"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// FailedPgBillingKeyIssueResponse     
type FailedPgBillingKeyIssueResponse struct {
	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// Failure    
	Failure BillingKeyFailure `json:"failure"`
	Type    string            `json:"type"`
}

// ForbiddenError   
type ForbiddenError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// Gender 
type Gender string

// GetAccountTransfersBody1 defines model for GetAccountTransfersBody1.
type GetAccountTransfersBody1 struct {
	Filter *PlatformAccountTransferFilter `json:"filter,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetAllPaymentEventsByCursorBody          
type GetAllPaymentEventsByCursorBody struct {
	// Cursor         .      ,       cursor  .
	Cursor *string `json:"cursor,omitempty"`

	// From    end 90  .
	From *time.Time `json:"from,omitempty"`

	// Size    10   1000 
	Size *int32 `json:"size,omitempty"`

	// StoreId Merchant  ,        .
	StoreId *string `json:"storeId,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`
}

// GetAllPaymentEventsByCursorResponse          
type GetAllPaymentEventsByCursorResponse struct {
	Items []PaymentEventWithCursor `json:"items"`
}

// GetAllPaymentEventsError defines model for GetAllPaymentEventsError.
type GetAllPaymentEventsError struct {
	union json.RawMessage
}

// GetAllPaymentsByCursorBody          
type GetAllPaymentsByCursorBody struct {
	// Cursor         .      ,       cursor  .
	Cursor *string `json:"cursor,omitempty"`

	// From    end 90  .
	From *time.Time `json:"from,omitempty"`

	// Size    10   1000 
	Size *int32 `json:"size,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`
}

// GetAllPaymentsByCursorResponse          
type GetAllPaymentsByCursorResponse struct {
	Items []PaymentWithCursor `json:"items"`
}

// GetAllPaymentsError defines model for GetAllPaymentsError.
type GetAllPaymentsError struct {
	union json.RawMessage
}

// GetB2bBulkTaxInvoiceError defines model for GetB2bBulkTaxInvoiceError.
type GetB2bBulkTaxInvoiceError struct {
	union json.RawMessage
}

// GetB2bBusinessInfosBody      
type GetB2bBusinessInfosBody struct {
	BrnList []string `json:"brnList"`
}

// GetB2bBusinessInfosError defines model for GetB2bBusinessInfosError.
type GetB2bBusinessInfosError struct {
	union json.RawMessage
}

// GetB2bBusinessInfosResponse     
type GetB2bBusinessInfosResponse struct {
	Result []B2bBusinessInfoResult `json:"result"`
}

// GetB2bTaxInvoiceAttachmentsError defines model for GetB2bTaxInvoiceAttachmentsError.
type GetB2bTaxInvoiceAttachmentsError struct {
	union json.RawMessage
}

// GetB2bTaxInvoiceAttachmentsResponse      
type GetB2bTaxInvoiceAttachmentsResponse struct {
	Attachments []B2bTaxInvoiceAttachment `json:"attachments"`
}

// GetB2bTaxInvoiceError defines model for GetB2bTaxInvoiceError.
type GetB2bTaxInvoiceError struct {
	union json.RawMessage
}

// GetB2bTaxInvoicePdfDownloadUrlError defines model for GetB2bTaxInvoicePdfDownloadUrlError.
type GetB2bTaxInvoicePdfDownloadUrlError struct {
	union json.RawMessage
}

// GetB2bTaxInvoicePdfDownloadUrlResponse  PDF  URL  
type GetB2bTaxInvoicePdfDownloadUrlResponse struct {
	Url string `json:"url"`
}

// GetB2bTaxInvoicePopupUrlError defines model for GetB2bTaxInvoicePopupUrlError.
type GetB2bTaxInvoicePopupUrlError struct {
	union json.RawMessage
}

// GetB2bTaxInvoicePopupUrlResponse   URL  
type GetB2bTaxInvoicePopupUrlResponse struct {
	Url string `json:"url"`
}

// GetB2bTaxInvoicePrintUrlError defines model for GetB2bTaxInvoicePrintUrlError.
type GetB2bTaxInvoicePrintUrlError struct {
	union json.RawMessage
}

// GetB2bTaxInvoicePrintUrlResponse   URL  
type GetB2bTaxInvoicePrintUrlResponse struct {
	Url string `json:"url"`
}

// GetB2bTaxInvoicesBody       
type GetB2bTaxInvoicesBody struct {
	// Filter    
	Filter *GetB2bTaxInvoicesBodyFilter `json:"filter,omitempty"`

	// PageNumber 0   .   0.
	PageNumber *int32 `json:"pageNumber,omitempty"`

	// PageSize      .   500  1000 .
	PageSize *int32 `json:"pageSize,omitempty"`

	// Test true    , false        .
	Test *bool `json:"test,omitempty"`
}

// GetB2bTaxInvoicesBodyDateFilter   
type GetB2bTaxInvoicesBodyDateFilter struct {
	// DateRange  `dateRange.from`    , `dateRange.until`    .
	DateRange *[]DateRangeOption `json:"dateRange,omitempty"`

	// DateType  
	DateType *B2bSearchDateType `json:"dateType,omitempty"`
}

// GetB2bTaxInvoicesBodyFilter    
type GetB2bTaxInvoicesBodyFilter struct {
	DocumentModificationTypes *[]B2bTaxInvoiceDocumentModificationType `json:"documentModificationTypes,omitempty"`
	IsDelayed                 *bool                                    `json:"isDelayed,omitempty"`
	IssuanceTypes             *[]B2bTaxInvoiceIssuanceType             `json:"issuanceTypes,omitempty"`

	// PartnerBrn    ,      .
	PartnerBrn *string `json:"partnerBrn,omitempty"`

	// PrimaryFilter  
	//
	//       .
	PrimaryFilter *GetB2bTaxInvoicesBodyPrimaryFilter `json:"primaryFilter,omitempty"`
	PurposeTypes  *[]B2bTaxInvoicePurposeType         `json:"purposeTypes,omitempty"`

	// Statuses    .
	Statuses      *[]B2bTaxInvoiceStatus       `json:"statuses,omitempty"`
	SupplierBrn   *string                      `json:"supplierBrn,omitempty"`
	TaxationTypes *[]B2bTaxInvoiceTaxationType `json:"taxationTypes,omitempty"`
}

// GetB2bTaxInvoicesBodyPrimaryFilter  
//
//       .
type GetB2bTaxInvoicesBodyPrimaryFilter struct {
	BulkTaxInvoiceId *string `json:"bulkTaxInvoiceId,omitempty"`

	// DateFilter   
	DateFilter           *GetB2bTaxInvoicesBodyDateFilter `json:"dateFilter,omitempty"`
	NtsApprovalNumber    *string                          `json:"ntsApprovalNumber,omitempty"`
	PayoutId             *string                          `json:"payoutId,omitempty"`
	RecipientDocumentKey *string                          `json:"recipientDocumentKey,omitempty"`
	SupplierDocumentKey  *string                          `json:"supplierDocumentKey,omitempty"`
	TaxInvoiceId         *string                          `json:"taxInvoiceId,omitempty"`
	TaxInvoiceIds        *[]string                        `json:"taxInvoiceIds,omitempty"`
}

// GetB2bTaxInvoicesError defines model for GetB2bTaxInvoicesError.
type GetB2bTaxInvoicesError struct {
	union json.RawMessage
}

// GetB2bTaxInvoicesResponse     
type GetB2bTaxInvoicesResponse struct {
	Items []B2bTaxInvoiceSummary `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetBankInfosError defines model for GetBankInfosError.
type GetBankInfosError struct {
	union json.RawMessage
}

// GetBankInfosResponse      
type GetBankInfosResponse struct {
	Items []BankInfo `json:"items"`
}

// GetBillingKeyInfoError defines model for GetBillingKeyInfoError.
type GetBillingKeyInfoError struct {
	union json.RawMessage
}

// GetBillingKeyInfosBody      
type GetBillingKeyInfosBody struct {
	// Filter      
	Filter *BillingKeyFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`

	// Sort      
	Sort *BillingKeySortInput `json:"sort,omitempty"`
}

// GetBillingKeyInfosError defines model for GetBillingKeyInfosError.
type GetBillingKeyInfosError struct {
	union json.RawMessage
}

// GetBillingKeyInfosResponse      
type GetBillingKeyInfosResponse struct {
	Items []BillingKeyInfo `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetCashReceiptError defines model for GetCashReceiptError.
type GetCashReceiptError struct {
	union json.RawMessage
}

// GetCashReceiptsBody      
type GetCashReceiptsBody struct {
	// Filter      
	Filter *CashReceiptFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`

	// Sort      
	Sort *CashReceiptSortInput `json:"sort,omitempty"`
}

// GetCashReceiptsError defines model for GetCashReceiptsError.
type GetCashReceiptsError struct {
	union json.RawMessage
}

// GetCashReceiptsResponse      
type GetCashReceiptsResponse struct {
	Items []CashReceipt `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetIdentityVerificationError defines model for GetIdentityVerificationError.
type GetIdentityVerificationError struct {
	union json.RawMessage
}

// GetIdentityVerificationsBody       
type GetIdentityVerificationsBody struct {
	// Filter      
	Filter *IdentityVerificationFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`

	// Sort       
	Sort *IdentityVerificationSortInput `json:"sort,omitempty"`
}

// GetIdentityVerificationsError defines model for GetIdentityVerificationsError.
type GetIdentityVerificationsError struct {
	union json.RawMessage
}

// GetIdentityVerificationsResponse       
type GetIdentityVerificationsResponse struct {
	Items []IdentityVerification `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetKakaopayPaymentOrderError defines model for GetKakaopayPaymentOrderError.
type GetKakaopayPaymentOrderError struct {
	union json.RawMessage
}

// GetKakaopayPaymentOrderResponse    
type GetKakaopayPaymentOrderResponse struct {
	Body       string `json:"body"`
	StatusCode int32  `json:"statusCode"`
}

// GetPaymentError defines model for GetPaymentError.
type GetPaymentError struct {
	union json.RawMessage
}

// GetPaymentScheduleError defines model for GetPaymentScheduleError.
type GetPaymentScheduleError struct {
	union json.RawMessage
}

// GetPaymentSchedulesBody       
//
//     (timeToPay)    .
type GetPaymentSchedulesBody struct {
	// Filter        
	Filter *PaymentScheduleFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`

	// Sort        
	Sort *PaymentScheduleSortInput `json:"sort,omitempty"`
}

// GetPaymentSchedulesError defines model for GetPaymentSchedulesError.
type GetPaymentSchedulesError struct {
	union json.RawMessage
}

// GetPaymentSchedulesResponse       
type GetPaymentSchedulesResponse struct {
	Items []PaymentSchedule `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPaymentTransactionsError defines model for GetPaymentTransactionsError.
type GetPaymentTransactionsError struct {
	union json.RawMessage
}

// GetPaymentTransactionsResponse      
type GetPaymentTransactionsResponse struct {
	Items []PaymentTransaction `json:"items"`
}

// GetPaymentsBody      
type GetPaymentsBody struct {
	// Filter      
	Filter *PaymentFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPaymentsError defines model for GetPaymentsError.
type GetPaymentsError struct {
	union json.RawMessage
}

// GetPaymentsResponse       
type GetPaymentsResponse struct {
	Items []Payment `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformAccountHolderError defines model for GetPlatformAccountHolderError.
type GetPlatformAccountHolderError struct {
	union json.RawMessage
}

// GetPlatformAccountTransfersError defines model for GetPlatformAccountTransfersError.
type GetPlatformAccountTransfersError struct {
	union json.RawMessage
}

// GetPlatformAccountTransfersResponse      
type GetPlatformAccountTransfersResponse struct {
	Counts PlatformAccountTransferStatusStats `json:"counts"`
	Items  []PlatformAccountTransfer          `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformAdditionalFeePoliciesBody        
type GetPlatformAdditionalFeePoliciesBody struct {
	// Filter        
	Filter *PlatformAdditionalFeePolicyFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformAdditionalFeePoliciesError defines model for GetPlatformAdditionalFeePoliciesError.
type GetPlatformAdditionalFeePoliciesError struct {
	union json.RawMessage
}

// GetPlatformAdditionalFeePoliciesResponse        
type GetPlatformAdditionalFeePoliciesResponse struct {
	Items []PlatformAdditionalFeePolicy `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformAdditionalFeePolicyError defines model for GetPlatformAdditionalFeePolicyError.
type GetPlatformAdditionalFeePolicyError struct {
	union json.RawMessage
}

// GetPlatformAdditionalFeePolicyScheduleError defines model for GetPlatformAdditionalFeePolicyScheduleError.
type GetPlatformAdditionalFeePolicyScheduleError struct {
	union json.RawMessage
}

// GetPlatformBulkAccountTransfersBody defines model for GetPlatformBulkAccountTransfersBody.
type GetPlatformBulkAccountTransfersBody struct {
	Filter *PlatformBulkAccountTransferFilterInput `json:"filter,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformBulkAccountTransfersError defines model for GetPlatformBulkAccountTransfersError.
type GetPlatformBulkAccountTransfersError struct {
	union json.RawMessage
}

// GetPlatformBulkAccountTransfersResponse defines model for GetPlatformBulkAccountTransfersResponse.
type GetPlatformBulkAccountTransfersResponse struct {
	Counts PlatformBulkAccountTransferStatusStats `json:"counts"`
	Items  []PlatformBulkAccountTransfer          `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformBulkPayoutsBody defines model for GetPlatformBulkPayoutsBody.
type GetPlatformBulkPayoutsBody struct {
	Filter *PlatformBulkPayoutFilterInput `json:"filter,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformBulkPayoutsError defines model for GetPlatformBulkPayoutsError.
type GetPlatformBulkPayoutsError struct {
	union json.RawMessage
}

// GetPlatformBulkPayoutsResponse defines model for GetPlatformBulkPayoutsResponse.
type GetPlatformBulkPayoutsResponse struct {
	Counts PlatformBulkPayoutStatusStats `json:"counts"`
	Items  []PlatformBulkPayout          `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformCompanyStateError defines model for GetPlatformCompanyStateError.
type GetPlatformCompanyStateError struct {
	union json.RawMessage
}

// GetPlatformCompanyStatePayload     
type GetPlatformCompanyStatePayload struct {
	CompanyState          PlatformCompanyState `json:"companyState"`
	CompanyVerificationId string               `json:"companyVerificationId"`
}

// GetPlatformContractError defines model for GetPlatformContractError.
type GetPlatformContractError struct {
	union json.RawMessage
}

// GetPlatformContractScheduleError defines model for GetPlatformContractScheduleError.
type GetPlatformContractScheduleError struct {
	union json.RawMessage
}

// GetPlatformContractsBody      
type GetPlatformContractsBody struct {
	// Filter      
	Filter *PlatformContractFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformContractsError defines model for GetPlatformContractsError.
type GetPlatformContractsError struct {
	union json.RawMessage
}

// GetPlatformContractsResponse     
type GetPlatformContractsResponse struct {
	Items []PlatformContract `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformDiscountSharePoliciesBody        
type GetPlatformDiscountSharePoliciesBody struct {
	// Filter        
	Filter *PlatformDiscountSharePolicyFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformDiscountSharePoliciesError defines model for GetPlatformDiscountSharePoliciesError.
type GetPlatformDiscountSharePoliciesError struct {
	union json.RawMessage
}

// GetPlatformDiscountSharePoliciesResponse        
type GetPlatformDiscountSharePoliciesResponse struct {
	Items []PlatformDiscountSharePolicy `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformDiscountSharePolicyError defines model for GetPlatformDiscountSharePolicyError.
type GetPlatformDiscountSharePolicyError struct {
	union json.RawMessage
}

// GetPlatformDiscountSharePolicyFilterOptionsError defines model for GetPlatformDiscountSharePolicyFilterOptionsError.
type GetPlatformDiscountSharePolicyFilterOptionsError struct {
	union json.RawMessage
}

// GetPlatformDiscountSharePolicyScheduleError defines model for GetPlatformDiscountSharePolicyScheduleError.
type GetPlatformDiscountSharePolicyScheduleError struct {
	union json.RawMessage
}

// GetPlatformPartnerError defines model for GetPlatformPartnerError.
type GetPlatformPartnerError struct {
	union json.RawMessage
}

// GetPlatformPartnerFilterOptionsError defines model for GetPlatformPartnerFilterOptionsError.
type GetPlatformPartnerFilterOptionsError struct {
	union json.RawMessage
}

// GetPlatformPartnerScheduleError defines model for GetPlatformPartnerScheduleError.
type GetPlatformPartnerScheduleError struct {
	union json.RawMessage
}

// GetPlatformPartnerSettlementsBody      
type GetPlatformPartnerSettlementsBody struct {
	Filter PlatformPartnerSettlementFilterInput `json:"filter"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformPartnerSettlementsError defines model for GetPlatformPartnerSettlementsError.
type GetPlatformPartnerSettlementsError struct {
	union json.RawMessage
}

// GetPlatformPartnerSettlementsResponse      
type GetPlatformPartnerSettlementsResponse struct {
	Counts PlatformPartnerSettlementStatusStats `json:"counts"`
	Items  []PlatformPartnerSettlement          `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformPartnersBody      
type GetPlatformPartnersBody struct {
	// Filter    
	Filter *PlatformPartnerFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformPartnersError defines model for GetPlatformPartnersError.
type GetPlatformPartnersError struct {
	union json.RawMessage
}

// GetPlatformPartnersResponse      
type GetPlatformPartnersResponse struct {
	Items []PlatformPartner `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformPayoutsBody defines model for GetPlatformPayoutsBody.
type GetPlatformPayoutsBody struct {
	// Filter     
	Filter *PlatformPayoutFilterInput `json:"filter,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Request Body isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformPayoutsError defines model for GetPlatformPayoutsError.
type GetPlatformPayoutsError struct {
	union json.RawMessage
}

// GetPlatformPayoutsResponse defines model for GetPlatformPayoutsResponse.
type GetPlatformPayoutsResponse struct {
	Counts PlatformPayoutStatusStats `json:"counts"`
	Items  []PlatformPayout          `json:"items"`

	// Page    
	Page PageInfo `json:"page"`
}

// GetPlatformSettingError defines model for GetPlatformSettingError.
type GetPlatformSettingError struct {
	union json.RawMessage
}

// GetPlatformTransferError defines model for GetPlatformTransferError.
type GetPlatformTransferError struct {
	union json.RawMessage
}

// GetPlatformTransferSummariesBody       
type GetPlatformTransferSummariesBody struct {
	// Filter    
	//
	//           .
	Filter *PlatformTransferFilterInput `json:"filter,omitempty"`

	// Page   API     
	Page *PageInput `json:"page,omitempty"`
}

// GetPlatformTransferSummariesError defines model for GetPlatformTransferSummariesError.
type GetPlatformTransferSummariesError struct {
	union json.RawMessage
}

// GetPlatformTransferSummariesResponse defines model for GetPlatformTransferSummariesResponse.
type GetPlatformTransferSummariesResponse struct {
	// Page    
	Page              PageInfo                  `json:"page"`
	TransferSummaries []PlatformTransferSummary `json:"transferSummaries"`
}

// GetPromotionError defines model for GetPromotionError.
type GetPromotionError struct {
	union json.RawMessage
}

// IdentityVerification  
type IdentityVerification struct {
	union json.RawMessage
}

// IdentityVerificationAlreadySentError    API   
type IdentityVerificationAlreadySentError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// IdentityVerificationAlreadyVerifiedError       
type IdentityVerificationAlreadyVerifiedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// IdentityVerificationFailure   
type IdentityVerificationFailure struct {
	PgCode    *string `json:"pgCode,omitempty"`
	PgMessage *string `json:"pgMessage,omitempty"`
	Reason    *string `json:"reason,omitempty"`
}

// IdentityVerificationFilterCustomerInput        
type IdentityVerificationFilterCustomerInput struct {
	BirthDay   *string `json:"birthDay,omitempty"`
	BirthMonth *string `json:"birthMonth,omitempty"`
	BirthYear  *string `json:"birthYear,omitempty"`

	// Gender 
	Gender *Gender `json:"gender,omitempty"`
	Name   *string `json:"name,omitempty"`

	// PhoneNumber  (-)     .
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// IdentityVerificationFilterInput      
type IdentityVerificationFilterInput struct {
	Carriers *[]Carrier `json:"carriers,omitempty"`

	// Customer        
	Customer *IdentityVerificationFilterCustomerInput `json:"customer,omitempty"`

	// From    end 90  .
	From *time.Time `json:"from,omitempty"`

	// IdentityVerificationId V1    `imp_uid` .
	IdentityVerificationId *string `json:"identityVerificationId,omitempty"`

	// IdentityVerificationTxId V1    `imp_uid` .
	IdentityVerificationTxId *string `json:"identityVerificationTxId,omitempty"`
	IsTest                   *bool   `json:"isTest,omitempty"`

	// PgCompanies    PG   .
	PgCompanies  *[]PgCompany `json:"pgCompanies,omitempty"`
	PgMerchantId *string      `json:"pgMerchantId,omitempty"`

	// PgProviders    PG     .
	PgProviders *[]PgProvider `json:"pgProviders,omitempty"`
	PgTxId      *string       `json:"pgTxId,omitempty"`

	// Statuses      .
	Statuses *[]IdentityVerificationStatus `json:"statuses,omitempty"`

	// StoreId Merchant  ,        .
	StoreId *string `json:"storeId,omitempty"`

	// TimeRangeField    ,    
	TimeRangeField *IdentityVerificationTimeRangeField `json:"timeRangeField,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`

	// Version  
	Version *PortOneVersion `json:"version,omitempty"`
}

// IdentityVerificationMethod  
type IdentityVerificationMethod string

// IdentityVerificationNotFoundError      
type IdentityVerificationNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// IdentityVerificationNotSentError   API    
type IdentityVerificationNotSentError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// IdentityVerificationOperator  
type IdentityVerificationOperator string

// IdentityVerificationRequestedCustomer    
type IdentityVerificationRequestedCustomer struct {
	BirthDay   *string `json:"birthDay,omitempty"`
	BirthMonth *string `json:"birthMonth,omitempty"`
	BirthYear  *string `json:"birthYear,omitempty"`
	Id         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`

	// PhoneNumber  (-)     .
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// IdentityVerificationSortBy    
type IdentityVerificationSortBy string

// IdentityVerificationSortInput       
type IdentityVerificationSortInput struct {
	// By    
	By *IdentityVerificationSortBy `json:"by,omitempty"`

	// Order  
	Order *SortOrder `json:"order,omitempty"`
}

// IdentityVerificationStatus  
type IdentityVerificationStatus string

// IdentityVerificationTimeRangeField    ,    
type IdentityVerificationTimeRangeField string

// IdentityVerificationVerifiedCustomer   
type IdentityVerificationVerifiedCustomer struct {
	// BirthDate  V2     .
	BirthDate *openapi_types.Date `json:"birthDate,omitempty"`

	// Ci     .
	// :  .
	// KG:    .
	Ci *string `json:"ci,omitempty"`

	// Di         .
	// :  .
	// KG:  .
	Di *string `json:"di,omitempty"`

	// Gender 
	Gender *Gender `json:"gender,omitempty"`
	Id     *string `json:"id,omitempty"`

	// IsForeigner :   .
	// KG:  .
	IsForeigner *bool  `json:"isForeigner,omitempty"`
	Name        string `json:"name"`

	// Operator  
	Operator *IdentityVerificationOperator `json:"operator,omitempty"`

	// PhoneNumber  (-)     .
	// :   .
	// KG:  .
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// InformationMismatchError    
type InformationMismatchError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// InstantBillingKeyPaymentMethodInput       
//
// `card`   .
type InstantBillingKeyPaymentMethodInput struct {
	// Card     
	Card *InstantBillingKeyPaymentMethodInputCard `json:"card,omitempty"`
}

// InstantBillingKeyPaymentMethodInputCard     
type InstantBillingKeyPaymentMethodInputCard struct {
	// Credential    
	Credential CardCredential `json:"credential"`
}

// InstantPaymentInput    
type InstantPaymentInput struct {
	// Amount    
	Amount PaymentAmountInput `json:"amount"`

	// ChannelGroupId      ID 
	ChannelGroupId *string `json:"channelGroupId,omitempty"`

	// ChannelKey      ID 
	ChannelKey *string `json:"channelKey,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer    
	Customer *CustomerInput `json:"customer,omitempty"`

	// IsCulturalExpense  false .
	IsCulturalExpense *bool `json:"isCulturalExpense,omitempty"`

	// IsEscrow  false .
	IsEscrow *bool `json:"isEscrow,omitempty"`

	// Method     
	//
	//   .
	Method InstantPaymentMethodInput `json:"method"`

	// NoticeUrls   .
	//      .
	//   .
	NoticeUrls   *[]string `json:"noticeUrls,omitempty"`
	OrderName    string    `json:"orderName"`
	ProductCount *int32    `json:"productCount,omitempty"`

	// ProductType  
	ProductType *PaymentProductType `json:"productType,omitempty"`

	// Products       .
	Products    *[]PaymentProduct `json:"products,omitempty"`
	PromotionId *string           `json:"promotionId,omitempty"`

	// ShippingAddress     
	ShippingAddress *SeparatedAddressInput `json:"shippingAddress,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// InstantPaymentMethodInput     
//
//   .
type InstantPaymentMethodInput struct {
	// Card     
	Card *InstantPaymentMethodInputCard `json:"card,omitempty"`

	// VirtualAccount     
	VirtualAccount *InstantPaymentMethodInputVirtualAccount `json:"virtualAccount,omitempty"`
}

// InstantPaymentMethodInputCard     
type InstantPaymentMethodInputCard struct {
	// Credential    
	Credential                  CardCredential `json:"credential"`
	InstallmentMonth            *int32         `json:"installmentMonth,omitempty"`
	UseCardPoint                *bool          `json:"useCardPoint,omitempty"`
	UseFreeInstallmentPlan      *bool          `json:"useFreeInstallmentPlan,omitempty"`
	UseFreeInterestFromMerchant *bool          `json:"useFreeInterestFromMerchant,omitempty"`
}

// InstantPaymentMethodInputVirtualAccount     
type InstantPaymentMethodInputVirtualAccount struct {
	// Bank 
	Bank Bank `json:"bank"`

	// CashReceipt     
	CashReceipt *InstantPaymentMethodInputVirtualAccountCashReceiptInfo `json:"cashReceipt,omitempty"`

	// Expiry   
	//
	// validHours dueDate     .
	Expiry InstantPaymentMethodInputVirtualAccountExpiry `json:"expiry"`

	// Option   
	Option       InstantPaymentMethodInputVirtualAccountOption `json:"option"`
	RemitteeName *string                                       `json:"remitteeName,omitempty"`
}

// InstantPaymentMethodInputVirtualAccountCashReceiptInfo     
type InstantPaymentMethodInputVirtualAccountCashReceiptInfo struct {
	CustomerIdentityNumber string `json:"customerIdentityNumber"`

	// Type    
	Type CashReceiptInputType `json:"type"`
}

// InstantPaymentMethodInputVirtualAccountExpiry   
//
// validHours dueDate     .
type InstantPaymentMethodInputVirtualAccountExpiry struct {
	DueDate *time.Time `json:"dueDate,omitempty"`

	// ValidHours   .
	ValidHours *int32 `json:"validHours,omitempty"`
}

// InstantPaymentMethodInputVirtualAccountOption   
type InstantPaymentMethodInputVirtualAccountOption struct {
	// Fixed    
	//
	// pgAccountId, accountNumber      .
	Fixed *InstantPaymentMethodInputVirtualAccountOptionFixed `json:"fixed,omitempty"`

	// Type   
	Type InstantPaymentMethodInputVirtualAccountOptionType `json:"type"`
}

// InstantPaymentMethodInputVirtualAccountOptionFixed    
//
// pgAccountId, accountNumber      .
type InstantPaymentMethodInputVirtualAccountOptionFixed struct {
	// AccountNumber PG              .
	AccountNumber *string `json:"accountNumber,omitempty"`

	// PgAccountId      PG pgAccountId    .
	//  pgAccountId       .
	PgAccountId *string `json:"pgAccountId,omitempty"`
}

// InstantPaymentMethodInputVirtualAccountOptionType   
type InstantPaymentMethodInputVirtualAccountOptionType string

// InstantPaymentSummary       
type InstantPaymentSummary struct {
	PaidAt time.Time `json:"paidAt"`
	PgTxId string    `json:"pgTxId"`
}

// InvalidPaymentTokenError     
type InvalidPaymentTokenError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// InvalidRequestError      
//
//   ,       .
type InvalidRequestError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// IssueB2bTaxInvoiceBody    
type IssueB2bTaxInvoiceBody struct {
	EmailSubject *string `json:"emailSubject,omitempty"`
	Memo         *string `json:"memo,omitempty"`
}

// IssueB2bTaxInvoiceError defines model for IssueB2bTaxInvoiceError.
type IssueB2bTaxInvoiceError struct {
	union json.RawMessage
}

// IssueB2bTaxInvoiceImmediatelyBody     
type IssueB2bTaxInvoiceImmediatelyBody struct {
	Memo *string `json:"memo,omitempty"`

	// Modification     
	Modification *B2bTaxInvoiceModificationCreateBody `json:"modification,omitempty"`

	// TaxInvoice    
	TaxInvoice B2bTaxInvoiceInput `json:"taxInvoice"`
}

// IssueB2bTaxInvoiceImmediatelyError defines model for IssueB2bTaxInvoiceImmediatelyError.
type IssueB2bTaxInvoiceImmediatelyError struct {
	union json.RawMessage
}

// IssueB2bTaxInvoiceImmediatelyResponse    
type IssueB2bTaxInvoiceImmediatelyResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// IssueB2bTaxInvoiceResponse    
type IssueB2bTaxInvoiceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// IssueBillingKeyBody    
type IssueBillingKeyBody struct {
	Bypass *map[string]interface{} `json:"bypass,omitempty"`

	// ChannelGroupId      ID 
	ChannelGroupId *string `json:"channelGroupId,omitempty"`

	// ChannelKey      ID 
	ChannelKey *string `json:"channelKey,omitempty"`
	CustomData *string `json:"customData,omitempty"`

	// Customer    
	Customer *CustomerInput `json:"customer,omitempty"`

	// Method       
	//
	// `card`   .
	Method InstantBillingKeyPaymentMethodInput `json:"method"`

	// NoticeUrls       .
	//      .
	//       .
	NoticeUrls *[]string `json:"noticeUrls,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// IssueBillingKeyError defines model for IssueBillingKeyError.
type IssueBillingKeyError struct {
	union json.RawMessage
}

// IssueBillingKeyResponse    
type IssueBillingKeyResponse struct {
	BillingKeyInfo          BillingKeyInfoSummary     `json:"billingKeyInfo"`
	ChannelSpecificFailures *[]ChannelSpecificFailure `json:"channelSpecificFailures,omitempty"`
}

// IssueCashReceiptBody    
type IssueCashReceiptBody struct {
	// Amount    
	Amount PaymentAmountInput `json:"amount"`

	// BusinessRegistrationNumber   .
	BusinessRegistrationNumber *string `json:"businessRegistrationNumber,omitempty"`
	ChannelKey                 string  `json:"channelKey"`

	// Currency  
	Currency Currency `json:"currency"`

	// Customer       
	Customer  IssueCashReceiptCustomerInput `json:"customer"`
	OrderName string                        `json:"orderName"`
	PaidAt    *time.Time                    `json:"paidAt,omitempty"`

	// PaymentId       ,    .
	PaymentId string `json:"paymentId"`

	// PaymentMethod     
	PaymentMethod *IssueCashReceiptPaymentMethodType `json:"paymentMethod,omitempty"`

	// ProductType  
	ProductType *PaymentProductType `json:"productType,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// Type  
	Type CashReceiptType `json:"type"`
}

// IssueCashReceiptCustomerInput       
type IssueCashReceiptCustomerInput struct {
	Email          *string `json:"email,omitempty"`
	IdentityNumber string  `json:"identityNumber"`
	Name           *string `json:"name,omitempty"`
	PhoneNumber    *string `json:"phoneNumber,omitempty"`
}

// IssueCashReceiptError defines model for IssueCashReceiptError.
type IssueCashReceiptError struct {
	union json.RawMessage
}

// IssueCashReceiptPaymentMethodType     
type IssueCashReceiptPaymentMethodType string

// IssueCashReceiptResponse     
type IssueCashReceiptResponse struct {
	// CashReceipt  
	CashReceipt CashReceiptSummary `json:"cashReceipt"`
}

// IssueFailedCashReceipt  
type IssueFailedCashReceipt struct {
	// Channel (,  )   
	Channel         *SelectedChannel `json:"channel,omitempty"`
	IsManual        bool             `json:"isManual"`
	MerchantId      string           `json:"merchantId"`
	OrderName       string           `json:"orderName"`
	PaymentId       string           `json:"paymentId"`
	Status          string           `json:"status"`
	StatusUpdatedAt *time.Time       `json:"statusUpdatedAt,omitempty"`
	StoreId         string           `json:"storeId"`
}

// IssuedBillingKeyInfo     
type IssuedBillingKeyInfo struct {
	BillingKey string `json:"billingKey"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Channels           .
	Channels   []SelectedChannel `json:"channels"`
	CustomData *string           `json:"customData,omitempty"`

	// Customer  
	Customer   Customer  `json:"customer"`
	IssueId    *string   `json:"issueId,omitempty"`
	IssueName  *string   `json:"issueName,omitempty"`
	IssuedAt   time.Time `json:"issuedAt"`
	MerchantId string    `json:"merchantId"`

	// Methods           .
	Methods *[]BillingKeyPaymentMethod `json:"methods,omitempty"`

	// PgBillingKeyIssueResponses  ,           .
	PgBillingKeyIssueResponses *[]PgBillingKeyIssueResponse `json:"pgBillingKeyIssueResponses,omitempty"`
	RequestedAt                *time.Time                   `json:"requestedAt,omitempty"`
	Status                     string                       `json:"status"`
	StoreId                    string                       `json:"storeId"`
}

// IssuedCashReceipt  
type IssuedCashReceipt struct {
	Amount int64 `json:"amount"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// Currency  
	Currency        Currency   `json:"currency"`
	IsManual        bool       `json:"isManual"`
	IssueNumber     string     `json:"issueNumber"`
	IssuedAt        time.Time  `json:"issuedAt"`
	MerchantId      string     `json:"merchantId"`
	OrderName       string     `json:"orderName"`
	PaymentId       string     `json:"paymentId"`
	PgReceiptId     *string    `json:"pgReceiptId,omitempty"`
	Status          string     `json:"status"`
	StatusUpdatedAt *time.Time `json:"statusUpdatedAt,omitempty"`
	StoreId         string     `json:"storeId"`
	TaxFreeAmount   *int64     `json:"taxFreeAmount,omitempty"`

	// Type  
	Type      *CashReceiptType `json:"type,omitempty"`
	Url       *string          `json:"url,omitempty"`
	VatAmount *int64           `json:"vatAmount,omitempty"`
}

// IssuedPaymentCashReceipt   
type IssuedPaymentCashReceipt struct {
	// Currency  
	Currency      Currency  `json:"currency"`
	IssueNumber   string    `json:"issueNumber"`
	IssuedAt      time.Time `json:"issuedAt"`
	PgReceiptId   *string   `json:"pgReceiptId,omitempty"`
	Status        string    `json:"status"`
	TaxFreeAmount *int64    `json:"taxFreeAmount,omitempty"`
	TotalAmount   int64     `json:"totalAmount"`

	// Type  
	Type *CashReceiptType `json:"type,omitempty"`
	Url  *string          `json:"url,omitempty"`
}

// IssuedPgBillingKeyIssueResponse     
type IssuedPgBillingKeyIssueResponse struct {
	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// Method    
	Method *BillingKeyPaymentMethod `json:"method,omitempty"`
	PgTxId *string                  `json:"pgTxId,omitempty"`
	Type   string                   `json:"type"`
}

// Locale  
type Locale string

// LoginViaApiSecretBody API Secret    
type LoginViaApiSecretBody struct {
	ApiSecret string `json:"apiSecret"`
}

// LoginViaApiSecretError defines model for LoginViaApiSecretError.
type LoginViaApiSecretError struct {
	union json.RawMessage
}

// LoginViaApiSecretResponse API key   
type LoginViaApiSecretResponse struct {
	// AccessToken 30   .
	AccessToken string `json:"accessToken"`

	// RefreshToken    ,           .
	//               API  .
	RefreshToken string `json:"refreshToken"`
}

// MapStat defines model for Map_Stat.
type MapStat map[string]B2bBulkTaxInvoiceStat

// MaxTransactionCountReachedError        
type MaxTransactionCountReachedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// MaxWebhookRetryCountReachedError  webhook id       
type MaxWebhookRetryCountReachedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// ModifyEscrowLogisticsBody      
type ModifyEscrowLogisticsBody struct {
	// Logistics 
	Logistics PaymentLogistics  `json:"logistics"`
	Products  *[]PaymentProduct `json:"products,omitempty"`

	// Receiver   
	Receiver *PaymentEscrowReceiverInput `json:"receiver,omitempty"`

	// SendEmail        .
	SendEmail *bool `json:"sendEmail,omitempty"`

	// Sender   
	Sender *PaymentEscrowSenderInput `json:"sender,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// ModifyEscrowLogisticsError defines model for ModifyEscrowLogisticsError.
type ModifyEscrowLogisticsError struct {
	union json.RawMessage
}

// ModifyEscrowLogisticsResponse      
type ModifyEscrowLogisticsResponse struct {
	InvoiceNumber string    `json:"invoiceNumber"`
	ModifiedAt    time.Time `json:"modifiedAt"`
	SentAt        time.Time `json:"sentAt"`
}

// MonthDay    
type MonthDay struct {
	Day   int32 `json:"day"`
	Month int32 `json:"month"`
}

// NegativePromotionAdjustedCancelAmountError       
type NegativePromotionAdjustedCancelAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// OneLineAddress    
//
//     .
type OneLineAddress struct {
	OneLine string `json:"oneLine"`
	Type    string `json:"type"`
}

// PageInfo    
type PageInfo struct {
	Number     int32 `json:"number"`
	Size       int32 `json:"size"`
	TotalCount int32 `json:"totalCount"`
}

// PageInput   API     
type PageInput struct {
	Number *int32 `json:"number,omitempty"`
	Size   *int32 `json:"size,omitempty"`
}

// PaidPayment    
type PaidPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer  `json:"customer"`
	Disputes []Dispute `json:"disputes"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       time.Time         `json:"paidAt"`
	PgResponse   *string           `json:"pgResponse,omitempty"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PaidPaymentEvent   
type PaidPaymentEvent struct {
	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country   *Country  `json:"country,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer  `json:"customer"`
	Disputes []Dispute `json:"disputes"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// EventAmount    ,     .
	EventAmount       int64  `json:"eventAmount"`
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	PgResponse   *string           `json:"pgResponse,omitempty"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId *string `json:"scheduleId,omitempty"`
	StoreId    string  `json:"storeId"`

	// TotalAmount    
	TotalAmount   PaymentAmount `json:"totalAmount"`
	TransactionId string        `json:"transactionId"`
	Type          string        `json:"type"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PaidPaymentTransaction    
type PaidPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       time.Time         `json:"paidAt"`
	PaymentId    string            `json:"paymentId"`
	PgResponse   *string           `json:"pgResponse,omitempty"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PartialCancelledPayment     
type PartialCancelledPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey    *string               `json:"billingKey,omitempty"`
	Cancellations []PaymentCancellation `json:"cancellations"`
	CancelledAt   time.Time             `json:"cancelledAt"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       *time.Time        `json:"paidAt,omitempty"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PartialCancelledPaymentEvent     
type PartialCancelledPaymentEvent struct {
	// Cancellation   
	Cancellation *PaymentCancellation `json:"cancellation,omitempty"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country   *Country  `json:"country,omitempty"`
	CreatedAt time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// EventAmount    ,     .
	EventAmount       int64  `json:"eventAmount"`
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId *string `json:"scheduleId,omitempty"`
	StoreId    string  `json:"storeId"`

	// TotalAmount    
	TotalAmount   PaymentAmount `json:"totalAmount"`
	TransactionId string        `json:"transactionId"`
	Type          string        `json:"type"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PartialCancelledPaymentTransaction     
type PartialCancelledPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey    *string               `json:"billingKey,omitempty"`
	Cancellations []PaymentCancellation `json:"cancellations"`
	CancelledAt   time.Time             `json:"cancelledAt"`

	// CashReceipt     
	CashReceipt *PaymentCashReceipt `json:"cashReceipt,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaidAt       *time.Time        `json:"paidAt,omitempty"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	ReceiptUrl   *string           `json:"receiptUrl,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PayInstantlyError defines model for PayInstantlyError.
type PayInstantlyError struct {
	union json.RawMessage
}

// PayInstantlyResponse    
type PayInstantlyResponse struct {
	// Payment       
	Payment InstantPaymentSummary `json:"payment"`
}

// PayPendingPayment     
type PayPendingPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PayPendingPaymentTransaction     
type PayPendingPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// PayWithBillingKeyError defines model for PayWithBillingKeyError.
type PayWithBillingKeyError struct {
	union json.RawMessage
}

// PayWithBillingKeyResponse    
type PayWithBillingKeyResponse struct {
	// Payment       
	Payment BillingKeyPaymentSummary `json:"payment"`
}

// Payment  
type Payment struct {
	union json.RawMessage
}

// PaymentAlreadyCancelledError    
type PaymentAlreadyCancelledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentAmount    
type PaymentAmount struct {
	Cancelled        int64 `json:"cancelled"`
	CancelledTaxFree int64 `json:"cancelledTaxFree"`

	// Discount  ,   ,  (  ,  )  .
	Discount int64  `json:"discount"`
	Paid     int64  `json:"paid"`
	Supply   *int64 `json:"supply,omitempty"`
	TaxFree  int64  `json:"taxFree"`
	Total    int64  `json:"total"`
	Vat      *int64 `json:"vat,omitempty"`
}

// PaymentAmountInput    
type PaymentAmountInput struct {
	TaxFree *int64 `json:"taxFree,omitempty"`
	Total   int64  `json:"total"`

	// Vat      .
	//       1/11   .
	Vat *int64 `json:"vat,omitempty"`
}

// PaymentCancellation   
type PaymentCancellation struct {
	union json.RawMessage
}

// PaymentCashReceipt     
type PaymentCashReceipt struct {
	union json.RawMessage
}

// PaymentCashReceiptStatus    
type PaymentCashReceiptStatus string

// PaymentClientType    
type PaymentClientType string

// PaymentEscrow  
//
// V1     REGISTERED  .
type PaymentEscrow struct {
	union json.RawMessage
}

// PaymentEscrowReceiverInput   
type PaymentEscrowReceiverInput struct {
	// Address     
	Address     *SeparatedAddressInput `json:"address,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PhoneNumber *string                `json:"phoneNumber,omitempty"`
	Zipcode     *string                `json:"zipcode,omitempty"`
}

// PaymentEscrowSenderInput   
type PaymentEscrowSenderInput struct {
	// Address     
	Address      *SeparatedAddressInput `json:"address,omitempty"`
	Name         *string                `json:"name,omitempty"`
	PhoneNumber  *string                `json:"phoneNumber,omitempty"`
	Relationship *string                `json:"relationship,omitempty"`
	Zipcode      *string                `json:"zipcode,omitempty"`
}

// PaymentEvent  
type PaymentEvent struct {
	union json.RawMessage
}

// PaymentEventWithCursor     
type PaymentEventWithCursor struct {
	Cursor string `json:"cursor"`

	// PaymentEvent  
	PaymentEvent PaymentEvent `json:"paymentEvent"`
}

// PaymentFailure   
type PaymentFailure struct {
	PgCode    *string `json:"pgCode,omitempty"`
	PgMessage *string `json:"pgMessage,omitempty"`
	Reason    *string `json:"reason,omitempty"`
}

// PaymentFilterInput      
type PaymentFilterInput struct {
	// CardBrand  
	CardBrand *CardBrand `json:"cardBrand,omitempty"`

	// CardOwnerType   
	CardOwnerType *CardOwnerType `json:"cardOwnerType,omitempty"`

	// CardType  
	CardType *CardType `json:"cardType,omitempty"`

	// CashReceiptCancelledAtRange  
	CashReceiptCancelledAtRange *DateTimeRange `json:"cashReceiptCancelledAtRange,omitempty"`

	// CashReceiptIssuedAtRange  
	CashReceiptIssuedAtRange *DateTimeRange `json:"cashReceiptIssuedAtRange,omitempty"`

	// CashReceiptStatus    
	CashReceiptStatus *PaymentCashReceiptStatus `json:"cashReceiptStatus,omitempty"`

	// CashReceiptType    
	CashReceiptType *CashReceiptInputType `json:"cashReceiptType,omitempty"`

	// Currency  
	Currency *Currency `json:"currency,omitempty"`

	// EscrowStatus  
	EscrowStatus *PaymentFilterInputEscrowStatus `json:"escrowStatus,omitempty"`

	// From    end 90  .
	From *time.Time `json:"from,omitempty"`

	// GiftCertificateType  
	GiftCertificateType *PaymentMethodGiftCertificateType `json:"giftCertificateType,omitempty"`
	IsEscrow            *bool                             `json:"isEscrow,omitempty"`
	IsScheduled         *bool                             `json:"isScheduled,omitempty"`
	IsTest              *bool                             `json:"isTest,omitempty"`
	MerchantId          *string                           `json:"merchantId,omitempty"`

	// Methods       .
	Methods *[]PaymentMethodType `json:"methods,omitempty"`

	// PgProvider    PG     .
	PgProvider *[]PgProvider `json:"pgProvider,omitempty"`

	// PlatformType    
	PlatformType *PaymentClientType `json:"platformType,omitempty"`

	// SortBy    
	SortBy *PaymentSortBy `json:"sortBy,omitempty"`

	// SortOrder  
	SortOrder *SortOrder `json:"sortOrder,omitempty"`

	// Status       .
	Status *[]PaymentStatus `json:"status,omitempty"`

	// StoreId Merchant  ,        .
	StoreId    *string              `json:"storeId,omitempty"`
	TextSearch *[]PaymentTextSearch `json:"textSearch,omitempty"`

	// TimestampType   
	//
	//       .
	// CREATED_AT:      .
	// STATUS_CHANGED_AT:     .         .
	// ready ->    
	// paid ->    
	// cancelled ->    
	// failed ->    
	//    STATUS_CHANGED_AT   .
	TimestampType *PaymentTimestampType `json:"timestampType,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`

	// Version  
	Version *PortOneVersion `json:"version,omitempty"`

	// WebhookStatus   
	WebhookStatus *PaymentWebhookStatus `json:"webhookStatus,omitempty"`
}

// PaymentFilterInputEscrowStatus  
type PaymentFilterInputEscrowStatus string

// PaymentInstallment  
type PaymentInstallment struct {
	IsInterestFree bool  `json:"isInterestFree"`
	Month          int32 `json:"month"`
}

// PaymentLogistics 
type PaymentLogistics struct {
	// Address     
	Address *SeparatedAddressInput `json:"address,omitempty"`

	// Company  
	Company       PaymentLogisticsCompany `json:"company"`
	InvoiceNumber string                  `json:"invoiceNumber"`
	ReceivedAt    *time.Time              `json:"receivedAt,omitempty"`
	SentAt        time.Time               `json:"sentAt"`
}

// PaymentLogisticsCompany  
type PaymentLogisticsCompany string

// PaymentMethod  
type PaymentMethod struct {
	union json.RawMessage
}

// PaymentMethodCard   
type PaymentMethodCard struct {
	ApprovalNumber *string `json:"approvalNumber,omitempty"`

	// Card   
	Card *Card `json:"card,omitempty"`

	// Installment  
	Installment *PaymentInstallment `json:"installment,omitempty"`
	PointUsed   *bool               `json:"pointUsed,omitempty"`
	Type        string              `json:"type"`
}

// PaymentMethodConvenienceStore    
type PaymentMethodConvenienceStore struct {
	ConfirmationNumber *string `json:"confirmationNumber,omitempty"`

	// ConvenienceStoreBrand  
	ConvenienceStoreBrand *ConvenienceStoreBrand `json:"convenienceStoreBrand,omitempty"`
	PaymentDeadline       *time.Time             `json:"paymentDeadline,omitempty"`
	ReceiptNumber         *string                `json:"receiptNumber,omitempty"`
	Type                  string                 `json:"type"`
}

// PaymentMethodEasyPay    
type PaymentMethodEasyPay struct {
	// EasyPayMethod   
	EasyPayMethod *PaymentMethodEasyPayMethod `json:"easyPayMethod,omitempty"`

	// Provider  
	Provider *EasyPayProvider `json:"provider,omitempty"`
	Type     string           `json:"type"`
}

// PaymentMethodEasyPayMethod   
type PaymentMethodEasyPayMethod struct {
	union json.RawMessage
}

// PaymentMethodEasyPayMethodCharge    
type PaymentMethodEasyPayMethodCharge struct {
	// Bank 
	Bank *Bank  `json:"bank,omitempty"`
	Type string `json:"type"`
}

// PaymentMethodGiftCertificate   
type PaymentMethodGiftCertificate struct {
	ApprovalNumber string `json:"approvalNumber"`

	// GiftCertificateType  
	GiftCertificateType *PaymentMethodGiftCertificateType `json:"giftCertificateType,omitempty"`
	Type                string                            `json:"type"`
}

// PaymentMethodGiftCertificateType  
type PaymentMethodGiftCertificateType string

// PaymentMethodMobile   
type PaymentMethodMobile struct {
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Type        string  `json:"type"`
}

// PaymentMethodTransfer    
type PaymentMethodTransfer struct {
	AccountNumber *string `json:"accountNumber,omitempty"`

	// Bank 
	Bank *Bank  `json:"bank,omitempty"`
	Type string `json:"type"`
}

// PaymentMethodType defines model for PaymentMethodType.
type PaymentMethodType string

// PaymentMethodVirtualAccount   
type PaymentMethodVirtualAccount struct {
	AccountNumber string `json:"accountNumber"`

	// AccountType  
	AccountType *PaymentMethodVirtualAccountType `json:"accountType,omitempty"`

	// Bank 
	Bank      *Bank      `json:"bank,omitempty"`
	ExpiredAt *time.Time `json:"expiredAt,omitempty"`
	IssuedAt  *time.Time `json:"issuedAt,omitempty"`

	// RefundStatus   
	RefundStatus *PaymentMethodVirtualAccountRefundStatus `json:"refundStatus,omitempty"`
	RemitteeName *string                                  `json:"remitteeName,omitempty"`
	RemitterName *string                                  `json:"remitterName,omitempty"`
	Type         string                                   `json:"type"`
}

// PaymentMethodVirtualAccountRefundStatus   
type PaymentMethodVirtualAccountRefundStatus string

// PaymentMethodVirtualAccountType  
type PaymentMethodVirtualAccountType string

// PaymentNotFoundError     
type PaymentNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentNotPaidError    
type PaymentNotPaidError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentNotWaitingForDepositError       
type PaymentNotWaitingForDepositError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentProduct  
type PaymentProduct struct {
	Amount int64   `json:"amount"`
	Code   *string `json:"code,omitempty"`

	// Id    .
	Id       string  `json:"id"`
	Link     *string `json:"link,omitempty"`
	Name     string  `json:"name"`
	Quantity int32   `json:"quantity"`

	// Tag     .
	Tag *string `json:"tag,omitempty"`
}

// PaymentProductType  
type PaymentProductType string

// PaymentSchedule   
type PaymentSchedule struct {
	union json.RawMessage
}

// PaymentScheduleAlreadyExistsError     
type PaymentScheduleAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentScheduleAlreadyProcessedError     
type PaymentScheduleAlreadyProcessedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentScheduleAlreadyRevokedError     
type PaymentScheduleAlreadyRevokedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentScheduleFilterInput        
type PaymentScheduleFilterInput struct {
	BillingKey *string `json:"billingKey,omitempty"`

	// From     end 90  .
	From      *time.Time `json:"from,omitempty"`
	IsForTest *bool      `json:"isForTest,omitempty"`

	// Status       .
	Status *[]PaymentScheduleStatus `json:"status,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// Until      .
	Until *time.Time `json:"until,omitempty"`
}

// PaymentScheduleNotFoundError     
type PaymentScheduleNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PaymentScheduleSortBy     
type PaymentScheduleSortBy string

// PaymentScheduleSortInput        
type PaymentScheduleSortInput struct {
	// By     
	By *PaymentScheduleSortBy `json:"by,omitempty"`

	// Order  
	Order *SortOrder `json:"order,omitempty"`
}

// PaymentScheduleStatus    
type PaymentScheduleStatus string

// PaymentScheduleSummary   
type PaymentScheduleSummary struct {
	Id string `json:"id"`
}

// PaymentSortBy    
type PaymentSortBy string

// PaymentStatus   
type PaymentStatus string

// PaymentTextSearch   
type PaymentTextSearch struct {
	// Field  
	Field PaymentTextSearchField `json:"field"`
	Value string                 `json:"value"`
}

// PaymentTextSearchField  
type PaymentTextSearchField string

// PaymentTimestampType   
//
//       .
// CREATED_AT:      .
// STATUS_CHANGED_AT:     .         .
// ready ->    
// paid ->    
// cancelled ->    
// failed ->    
//    STATUS_CHANGED_AT   .
type PaymentTimestampType string

// PaymentTransaction  
type PaymentTransaction struct {
	union json.RawMessage
}

// PaymentWebhook   
type PaymentWebhook struct {
	CurrentExecutionCount *int32 `json:"currentExecutionCount,omitempty"`
	Id                    string `json:"id"`

	// IsAsync V1   ,   .
	IsAsync           *bool  `json:"isAsync,omitempty"`
	MaxExecutionCount *int32 `json:"maxExecutionCount,omitempty"`

	// PaymentStatus      
	PaymentStatus *PaymentWebhookPaymentStatus `json:"paymentStatus,omitempty"`

	// Request   
	Request *PaymentWebhookRequest `json:"request,omitempty"`

	// Response   
	Response *PaymentWebhookResponse `json:"response,omitempty"`

	// Status   
	Status *PaymentWebhookStatus `json:"status,omitempty"`

	// Trigger   
	//
	//   ,  ,          .
	Trigger     *PaymentWebhookTrigger `json:"trigger,omitempty"`
	TriggeredAt *time.Time             `json:"triggeredAt,omitempty"`

	// Url V1   ,   .
	Url string `json:"url"`
}

// PaymentWebhookPaymentStatus      
type PaymentWebhookPaymentStatus string

// PaymentWebhookRequest   
type PaymentWebhookRequest struct {
	Body        string     `json:"body"`
	Header      *string    `json:"header,omitempty"`
	RequestedAt *time.Time `json:"requestedAt,omitempty"`
}

// PaymentWebhookResponse   
type PaymentWebhookResponse struct {
	Body        string    `json:"body"`
	Code        string    `json:"code"`
	Header      string    `json:"header"`
	RespondedAt time.Time `json:"respondedAt"`
}

// PaymentWebhookStatus   
type PaymentWebhookStatus string

// PaymentWebhookTrigger   
//
//   ,  ,          .
type PaymentWebhookTrigger string

// PaymentWithCursor     
type PaymentWithCursor struct {
	Cursor string `json:"cursor"`

	// Payment  
	Payment Payment `json:"payment"`
}

// PendingPaymentSchedule    
type PendingPaymentSchedule struct {
	BillingKey  string    `json:"billingKey"`
	CompletedAt time.Time `json:"completedAt"`
	CreatedAt   time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	StartedAt         time.Time         `json:"startedAt"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// PgBillingKeyIssueResponse     
type PgBillingKeyIssueResponse struct {
	union json.RawMessage
}

// PgCompany PG
type PgCompany string

// PgProvider PG  
type PgProvider string

// PgProviderError PG   
type PgProviderError struct {
	Message   *string `json:"message,omitempty"`
	PgCode    string  `json:"pgCode"`
	PgMessage string  `json:"pgMessage"`
	Type      string  `json:"type"`
}

// PlatformAccount   
//
// `currency`  KRW     API     .       .
type PlatformAccount struct {
	// Bank 
	Bank Bank `json:"bank"`

	// Currency  
	Currency Currency `json:"currency"`
	Holder   string   `json:"holder"`
	Number   string   `json:"number"`

	// Status   
	Status PlatformAccountStatus `json:"status"`
}

// PlatformAccountHolder     
type PlatformAccountHolder struct {
	AccountVerificationId string `json:"accountVerificationId"`
	HolderName            string `json:"holderName"`
}

// PlatformAccountStatus   
type PlatformAccountStatus string

// PlatformAccountTransfer  
//
//       ,      .
type PlatformAccountTransfer struct {
	union json.RawMessage
}

// PlatformAccountTransferFilter defines model for PlatformAccountTransferFilter.
type PlatformAccountTransferFilter struct {
	AccountTransferId     *string   `json:"accountTransferId,omitempty"`
	AccountTransferIds    *[]string `json:"accountTransferIds,omitempty"`
	BankAccountId         *string   `json:"bankAccountId,omitempty"`
	BulkAccountTransferId *string   `json:"bulkAccountTransferId,omitempty"`

	// CreatedTimestampRange  
	CreatedTimestampRange *DateTimeRange `json:"createdTimestampRange,omitempty"`
	DepositAccountHolder  *string        `json:"depositAccountHolder,omitempty"`
	DepositMemo           *string        `json:"depositMemo,omitempty"`
	DepositorName         *string        `json:"depositorName,omitempty"`
	PayoutId              *string        `json:"payoutId,omitempty"`

	// ScheduledTimestampRange  
	ScheduledTimestampRange *DateTimeRange `json:"scheduledTimestampRange,omitempty"`

	// StatusUpdatedTimestampRange  
	StatusUpdatedTimestampRange *DateTimeRange                   `json:"statusUpdatedTimestampRange,omitempty"`
	Statuses                    *[]PlatformAccountTransferStatus `json:"statuses,omitempty"`

	// TradeTimestampRange  
	TradeTimestampRange *DateTimeRange                 `json:"tradeTimestampRange,omitempty"`
	Types               *[]PlatformAccountTransferType `json:"types,omitempty"`
	WithdrawalMemo      *string                        `json:"withdrawalMemo,omitempty"`
}

// PlatformAccountTransferStatus   
type PlatformAccountTransferStatus string

// PlatformAccountTransferStatusStats defines model for PlatformAccountTransferStatusStats.
type PlatformAccountTransferStatusStats struct {
	AsyncProcessing int64 `json:"asyncProcessing"`
	Cancelled       int64 `json:"cancelled"`
	Failed          int64 `json:"failed"`
	Prepared        int64 `json:"prepared"`
	Processing      int64 `json:"processing"`
	Scheduled       int64 `json:"scheduled"`
	Stopped         int64 `json:"stopped"`
	Succeeded       int64 `json:"succeeded"`
}

// PlatformAccountTransferType   
type PlatformAccountTransferType string

// PlatformAccountVerificationAlreadyUsedError       
type PlatformAccountVerificationAlreadyUsedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAccountVerificationFailedError     
type PlatformAccountVerificationFailedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAccountVerificationNotFoundError        
type PlatformAccountVerificationNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAdditionalFeePoliciesNotFoundError defines model for PlatformAdditionalFeePoliciesNotFoundError.
type PlatformAdditionalFeePoliciesNotFoundError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformAdditionalFeePolicy   
//
//           .     ,  ,    .
type PlatformAdditionalFeePolicy struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Fee   
	Fee        PlatformFee `json:"fee"`
	GraphqlId  string      `json:"graphqlId"`
	Id         string      `json:"id"`
	IsArchived bool        `json:"isArchived"`
	IsForTest  bool        `json:"isForTest"`
	Memo       *string     `json:"memo,omitempty"`
	Name       string      `json:"name"`

	// VatPayer   
	//
	//    ,      .
	VatPayer PlatformPayer `json:"vatPayer"`
}

// PlatformAdditionalFeePolicyAlreadyExistsError defines model for PlatformAdditionalFeePolicyAlreadyExistsError.
type PlatformAdditionalFeePolicyAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAdditionalFeePolicyFilterInput        
type PlatformAdditionalFeePolicyFilterInput struct {
	// IsArchived true        , false         .  false .
	IsArchived *bool `json:"isArchived,omitempty"`

	// Keyword    
	//
	//     ,       .        .
	Keyword *PlatformAdditionalFeePolicyFilterInputKeyword `json:"keyword,omitempty"`

	// VatPayers                .
	VatPayers *[]PlatformPayer `json:"vatPayers,omitempty"`
}

// PlatformAdditionalFeePolicyFilterInputKeyword    
//
//     ,       .        .
type PlatformAdditionalFeePolicyFilterInputKeyword struct {
	// Fee          .
	Fee *string `json:"fee,omitempty"`

	// Id    id      .
	Id *string `json:"id,omitempty"`

	// Name    name      .
	Name *string `json:"name,omitempty"`
}

// PlatformAdditionalFeePolicyNotFoundError defines model for PlatformAdditionalFeePolicyNotFoundError.
type PlatformAdditionalFeePolicyNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAdditionalFeePolicyScheduleAlreadyExistsError defines model for PlatformAdditionalFeePolicyScheduleAlreadyExistsError.
type PlatformAdditionalFeePolicyScheduleAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError defines model for PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError.
type PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError struct {
	// FeeCurrency  
	FeeCurrency Currency `json:"feeCurrency"`
	GraphqlId   string   `json:"graphqlId"`
	Id          string   `json:"id"`
	Message     *string  `json:"message,omitempty"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`
	Type               string   `json:"type"`
}

// PlatformAmountExceededType defines model for PlatformAmountExceededType.
type PlatformAmountExceededType string

// PlatformArchivedAdditionalFeePolicyError       
type PlatformArchivedAdditionalFeePolicyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformArchivedContractError     
type PlatformArchivedContractError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformArchivedDiscountSharePolicyError       
type PlatformArchivedDiscountSharePolicyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformArchivedPartnerError     
type PlatformArchivedPartnerError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformArchivedPartnersCannotBeScheduledError      
type PlatformArchivedPartnersCannotBeScheduledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformBtxNotEnabledError BTX        
type PlatformBtxNotEnabledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformBulkAccountTransfer defines model for PlatformBulkAccountTransfer.
type PlatformBulkAccountTransfer struct {
	BankAccountGraphqlId string                            `json:"bankAccountGraphqlId"`
	BankAccountId        string                            `json:"bankAccountId"`
	CreatedAt            time.Time                         `json:"createdAt"`
	CreatorId            string                            `json:"creatorId"`
	GraphqlId            string                            `json:"graphqlId"`
	Id                   string                            `json:"id"`
	ScheduledAt          *time.Time                        `json:"scheduledAt,omitempty"`
	Stats                PlatformBulkAccountTransferStats  `json:"stats"`
	Status               PlatformBulkAccountTransferStatus `json:"status"`
	StatusUpdatedAt      time.Time                         `json:"statusUpdatedAt"`
	TotalAmount          int64                             `json:"totalAmount"`
	UpdatedAt            time.Time                         `json:"updatedAt"`
}

// PlatformBulkAccountTransferFilterInput defines model for PlatformBulkAccountTransferFilterInput.
type PlatformBulkAccountTransferFilterInput struct {
	Criteria *PlatformBulkAccountTransferFilterInputCriteria `json:"criteria,omitempty"`
	Statuses *[]PlatformBulkAccountTransferStatus            `json:"statuses,omitempty"`
}

// PlatformBulkAccountTransferFilterInputCriteria defines model for PlatformBulkAccountTransferFilterInputCriteria.
type PlatformBulkAccountTransferFilterInputCriteria struct {
	BulkAccountTransferId *string `json:"bulkAccountTransferId,omitempty"`

	// StatusUpdatedTimestampRange  
	StatusUpdatedTimestampRange *DateTimeRange `json:"statusUpdatedTimestampRange,omitempty"`

	// TimestampRange  
	TimestampRange *DateTimeRange `json:"timestampRange,omitempty"`
}

// PlatformBulkAccountTransferStats defines model for PlatformBulkAccountTransferStats.
type PlatformBulkAccountTransferStats struct {
	Amount PlatformAccountTransferStatusStats `json:"amount"`
	Count  PlatformAccountTransferStatusStats `json:"count"`
}

// PlatformBulkAccountTransferStatus defines model for PlatformBulkAccountTransferStatus.
type PlatformBulkAccountTransferStatus string

// PlatformBulkAccountTransferStatusStats defines model for PlatformBulkAccountTransferStatusStats.
type PlatformBulkAccountTransferStatusStats struct {
	Completed int64 `json:"completed"`
	Ongoing   int64 `json:"ongoing"`
	Prepared  int64 `json:"prepared"`
	Scheduled int64 `json:"scheduled"`
}

// PlatformBulkPayout defines model for PlatformBulkPayout.
type PlatformBulkPayout struct {
	CreatedAt             time.Time                `json:"createdAt"`
	CreatorId             string                   `json:"creatorId"`
	GraphqlId             string                   `json:"graphqlId"`
	Id                    string                   `json:"id"`
	Method                PlatformPayoutMethod     `json:"method"`
	Name                  string                   `json:"name"`
	PayoutStats           PlatformBulkPayoutStats  `json:"payoutStats"`
	Status                PlatformBulkPayoutStatus `json:"status"`
	StatusUpdatedAt       time.Time                `json:"statusUpdatedAt"`
	TotalPayoutAmount     int64                    `json:"totalPayoutAmount"`
	TotalSettlementAmount int64                    `json:"totalSettlementAmount"`
	UpdatedAt             time.Time                `json:"updatedAt"`
}

// PlatformBulkPayoutFilterInput defines model for PlatformBulkPayoutFilterInput.
type PlatformBulkPayoutFilterInput struct {
	Criteria *PlatformBulkPayoutFilterInputCriteria `json:"criteria,omitempty"`
	Methods  *[]PlatformPayoutMethod                `json:"methods,omitempty"`
	Statuses *[]PlatformBulkPayoutStatus            `json:"statuses,omitempty"`
}

// PlatformBulkPayoutFilterInputCriteria defines model for PlatformBulkPayoutFilterInputCriteria.
type PlatformBulkPayoutFilterInputCriteria struct {
	BulkPayoutId *string `json:"bulkPayoutId,omitempty"`

	// StatusUpdatedTimestampRange  
	StatusUpdatedTimestampRange *DateTimeRange `json:"statusUpdatedTimestampRange,omitempty"`

	// TimestampRange  
	TimestampRange *DateTimeRange `json:"timestampRange,omitempty"`
}

// PlatformBulkPayoutStats defines model for PlatformBulkPayoutStats.
type PlatformBulkPayoutStats struct {
	Amount PlatformPayoutStatusStats `json:"amount"`
	Count  PlatformPayoutStatusStats `json:"count"`
}

// PlatformBulkPayoutStatus defines model for PlatformBulkPayoutStatus.
type PlatformBulkPayoutStatus string

// PlatformBulkPayoutStatusStats defines model for PlatformBulkPayoutStatusStats.
type PlatformBulkPayoutStatusStats struct {
	Cancelled          int64 `json:"cancelled"`
	Completed          int64 `json:"completed"`
	Ongoing            int64 `json:"ongoing"`
	PostProcessPending int64 `json:"postProcessPending"`
	Prepared           int64 `json:"prepared"`
	Preparing          int64 `json:"preparing"`
}

// PlatformBulkTask defines model for PlatformBulkTask.
type PlatformBulkTask struct {
	CreatedAt       time.Time                     `json:"createdAt"`
	GraphqlId       string                        `json:"graphqlId"`
	Id              string                        `json:"id"`
	IsForTest       bool                          `json:"isForTest"`
	ProgressStats   PlatformBulkTaskProgressStats `json:"progressStats"`
	Status          PlatformBulkTaskStatus        `json:"status"`
	StatusUpdatedAt time.Time                     `json:"statusUpdatedAt"`
	Type            PlatformBulkTaskType          `json:"type"`
	UpdatedAt       time.Time                     `json:"updatedAt"`
}

// PlatformBulkTaskProgressStats defines model for PlatformBulkTaskProgressStats.
type PlatformBulkTaskProgressStats struct {
	CanceledCount   int64 `json:"canceledCount"`
	FailedCount     int64 `json:"failedCount"`
	PreparedCount   int64 `json:"preparedCount"`
	ProcessingCount int64 `json:"processingCount"`
	SucceededCount  int64 `json:"succeededCount"`
}

// PlatformBulkTaskStatus defines model for PlatformBulkTaskStatus.
type PlatformBulkTaskStatus string

// PlatformBulkTaskType defines model for PlatformBulkTaskType.
type PlatformBulkTaskType string

// PlatformBusinessStatus   
type PlatformBusinessStatus string

// PlatformCancelOrderTransfersExistsError defines model for PlatformCancelOrderTransfersExistsError.
type PlatformCancelOrderTransfersExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCancellableAmountExceededError     
type PlatformCancellableAmountExceededError struct {
	// AmountType  
	AmountType        PlatformCancellableAmountType `json:"amountType"`
	CancellableAmount int64                         `json:"cancellableAmount"`
	Message           *string                       `json:"message,omitempty"`
	RequestAmount     int64                         `json:"requestAmount"`
	Type              string                        `json:"type"`
}

// PlatformCancellableAmountType  
type PlatformCancellableAmountType string

// PlatformCancellableDiscountAmountExceededError defines model for PlatformCancellableDiscountAmountExceededError.
type PlatformCancellableDiscountAmountExceededError struct {
	CancellableAmount            int64   `json:"cancellableAmount"`
	DiscountSharePolicyGraphqlId string  `json:"discountSharePolicyGraphqlId"`
	DiscountSharePolicyId        string  `json:"discountSharePolicyId"`
	Message                      *string `json:"message,omitempty"`
	ProductId                    *string `json:"productId,omitempty"`
	RequestAmount                int64   `json:"requestAmount"`
	Type                         string  `json:"type"`
}

// PlatformCancellableDiscountTaxFreeAmountExceededError defines model for PlatformCancellableDiscountTaxFreeAmountExceededError.
type PlatformCancellableDiscountTaxFreeAmountExceededError struct {
	CancellableAmount            int64   `json:"cancellableAmount"`
	DiscountSharePolicyGraphqlId string  `json:"discountSharePolicyGraphqlId"`
	DiscountSharePolicyId        string  `json:"discountSharePolicyId"`
	Message                      *string `json:"message,omitempty"`
	ProductId                    *string `json:"productId,omitempty"`
	RequestAmount                int64   `json:"requestAmount"`
	Type                         string  `json:"type"`
}

// PlatformCancellableProductQuantityExceededError defines model for PlatformCancellableProductQuantityExceededError.
type PlatformCancellableProductQuantityExceededError struct {
	CancellableQuantity int64   `json:"cancellableQuantity"`
	Message             *string `json:"message,omitempty"`
	ProductId           string  `json:"productId"`
	Type                string  `json:"type"`
}

// PlatformCancellationAndPaymentTypeMismatchedError defines model for PlatformCancellationAndPaymentTypeMismatchedError.
type PlatformCancellationAndPaymentTypeMismatchedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCancellationNotFoundError defines model for PlatformCancellationNotFoundError.
type PlatformCancellationNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCannotArchiveScheduledAdditionalFeePolicyError         
type PlatformCannotArchiveScheduledAdditionalFeePolicyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCannotArchiveScheduledContractError       
type PlatformCannotArchiveScheduledContractError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCannotArchiveScheduledDiscountSharePolicyError         
type PlatformCannotArchiveScheduledDiscountSharePolicyError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCannotArchiveScheduledPartnerError       
type PlatformCannotArchiveScheduledPartnerError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCannotSpecifyTransferError     
type PlatformCannotSpecifyTransferError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCompanyNotFoundError      
type PlatformCompanyNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformCompanyState defines model for PlatformCompanyState.
type PlatformCompanyState struct {
	// BusinessStatus   
	BusinessStatus PlatformBusinessStatus `json:"businessStatus"`

	// ClosedSuspendedDate   , `yyyy-MM-dd`  .
	ClosedSuspendedDate *openapi_types.Date `json:"closedSuspendedDate,omitempty"`

	// TaxationType   
	TaxationType PlatformTaxationType `json:"taxationType"`

	// TaxationTypeDate   , `yyyy-MM-dd`  .
	TaxationTypeDate *openapi_types.Date `json:"taxationTypeDate,omitempty"`
}

// PlatformCompanyVerificationAlreadyUsedError       
type PlatformCompanyVerificationAlreadyUsedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformContact     
//
//      .
type PlatformContact struct {
	Email       string  `json:"email"`
	Name        string  `json:"name"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// PlatformContract 
//
//           .
//             .
type PlatformContract struct {
	AppliedAt  time.Time `json:"appliedAt"`
	GraphqlId  string    `json:"graphqlId"`
	Id         string    `json:"id"`
	IsArchived bool      `json:"isArchived"`
	IsForTest  bool      `json:"isForTest"`
	Memo       *string   `json:"memo,omitempty"`
	Name       string    `json:"name"`

	// PlatformFee   
	PlatformFee PlatformFee `json:"platformFee"`

	// PlatformFeeVatPayer   
	//
	//    ,      .
	PlatformFeeVatPayer PlatformPayer `json:"platformFeeVatPayer"`

	// SettlementCycle  
	//
	// , ,  ,      .
	SettlementCycle PlatformSettlementCycle `json:"settlementCycle"`

	// SubtractPaymentVatAmount false       , true      .
	SubtractPaymentVatAmount bool `json:"subtractPaymentVatAmount"`
}

// PlatformContractAlreadyExistsError defines model for PlatformContractAlreadyExistsError.
type PlatformContractAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformContractFilterInput      
type PlatformContractFilterInput struct {
	// CycleTypes               .
	CycleTypes *[]PlatformSettlementCycleType `json:"cycleTypes,omitempty"`

	// DatePolicies             .
	DatePolicies *[]PlatformSettlementCycleDatePolicy `json:"datePolicies,omitempty"`

	// IsArchived true    , false     .  false .
	IsArchived *bool `json:"isArchived,omitempty"`

	// Keyword    
	//
	//     ,     .      .
	Keyword *PlatformContractFilterInputKeyword `json:"keyword,omitempty"`

	// PlatformFeePayers              .
	PlatformFeePayers *[]PlatformPayer `json:"platformFeePayers,omitempty"`
}

// PlatformContractFilterInputKeyword    
//
//     ,     .      .
type PlatformContractFilterInputKeyword struct {
	// Id    id    .
	Id *string `json:"id,omitempty"`

	// Name    name    .
	Name *string `json:"name,omitempty"`
}

// PlatformContractNotFoundError defines model for PlatformContractNotFoundError.
type PlatformContractNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError defines model for PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError.
type PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError struct {
	// FeeCurrency  
	FeeCurrency Currency `json:"feeCurrency"`
	GraphqlId   string   `json:"graphqlId"`
	Id          string   `json:"id"`
	Message     *string  `json:"message,omitempty"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`
	Type               string   `json:"type"`
}

// PlatformContractScheduleAlreadyExistsError defines model for PlatformContractScheduleAlreadyExistsError.
type PlatformContractScheduleAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformContractsNotFoundError defines model for PlatformContractsNotFoundError.
type PlatformContractsNotFoundError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformCurrencyNotSupportedError      
type PlatformCurrencyNotSupportedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformDepositAccountTransfer defines model for PlatformDepositAccountTransfer.
type PlatformDepositAccountTransfer struct {
	Amount               int64     `json:"amount"`
	BankAccountGraphqlId string    `json:"bankAccountGraphqlId"`
	BankAccountId        string    `json:"bankAccountId"`
	CreatedAt            time.Time `json:"createdAt"`

	// Currency  
	Currency      Currency `json:"currency"`
	DepositMemo   *string  `json:"depositMemo,omitempty"`
	DepositorName string   `json:"depositorName"`
	Id            string   `json:"id"`
	IsForTest     bool     `json:"isForTest"`

	// Status   
	Status          PlatformAccountTransferStatus `json:"status"`
	StatusUpdatedAt time.Time                     `json:"statusUpdatedAt"`
	TradedAt        *time.Time                    `json:"tradedAt,omitempty"`
	Type            string                        `json:"type"`
	UpdatedAt       time.Time                     `json:"updatedAt"`
}

// PlatformDiscountSharePoliciesNotFoundError defines model for PlatformDiscountSharePoliciesNotFoundError.
type PlatformDiscountSharePoliciesNotFoundError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformDiscountSharePolicy   
//
//           ,         .
//     ,    .
type PlatformDiscountSharePolicy struct {
	AppliedAt  time.Time `json:"appliedAt"`
	GraphqlId  string    `json:"graphqlId"`
	Id         string    `json:"id"`
	IsArchived bool      `json:"isArchived"`
	IsForTest  bool      `json:"isForTest"`
	Memo       *string   `json:"memo,omitempty"`
	Name       string    `json:"name"`

	// PartnerShareRate         (10^-5)    ,    ` * partnerShareRate * 10^5`  .
	PartnerShareRate int32 `json:"partnerShareRate"`
}

// PlatformDiscountSharePolicyAlreadyExistsError defines model for PlatformDiscountSharePolicyAlreadyExistsError.
type PlatformDiscountSharePolicyAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformDiscountSharePolicyFilterInput        
type PlatformDiscountSharePolicyFilterInput struct {
	// IsArchived true      , false       .  false .
	IsArchived *bool `json:"isArchived,omitempty"`

	// Keyword    
	//
	//     ,       .        .
	Keyword *PlatformDiscountSharePolicyFilterInputKeyword `json:"keyword,omitempty"`

	// PartnerShareRates               .
	PartnerShareRates *[]int32 `json:"partnerShareRates,omitempty"`
}

// PlatformDiscountSharePolicyFilterInputKeyword    
//
//     ,       .        .
type PlatformDiscountSharePolicyFilterInputKeyword struct {
	// Id    id      .
	Id *string `json:"id,omitempty"`

	// Name    name     .
	Name *string `json:"name,omitempty"`
}

// PlatformDiscountSharePolicyFilterOptions         
type PlatformDiscountSharePolicyFilterOptions struct {
	PartnerShareRates []int32 `json:"partnerShareRates"`
}

// PlatformDiscountSharePolicyIdDuplicatedError defines model for PlatformDiscountSharePolicyIdDuplicatedError.
type PlatformDiscountSharePolicyIdDuplicatedError struct {
	GraphqlId string  `json:"graphqlId"`
	Id        string  `json:"id"`
	Message   *string `json:"message,omitempty"`
	Type      string  `json:"type"`
}

// PlatformDiscountSharePolicyNotFoundError defines model for PlatformDiscountSharePolicyNotFoundError.
type PlatformDiscountSharePolicyNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformDiscountSharePolicyScheduleAlreadyExistsError defines model for PlatformDiscountSharePolicyScheduleAlreadyExistsError.
type PlatformDiscountSharePolicyScheduleAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformExternalApiFailedError  api 
type PlatformExternalApiFailedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformExternalApiTemporarilyFailedError  api  
type PlatformExternalApiTemporarilyFailedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformExternalPayment   
type PlatformExternalPayment struct {
	// Currency  
	Currency Currency `json:"currency"`
	Id       string   `json:"id"`

	// Method  
	Method    *PlatformPaymentMethod `json:"method,omitempty"`
	OrderName *string                `json:"orderName,omitempty"`
	PaidAt    *time.Time             `json:"paidAt,omitempty"`
	Type      string                 `json:"type"`
}

// PlatformFee   
type PlatformFee struct {
	union json.RawMessage
}

// PlatformFeeInput       
//
//      `fixedRate` ,      `fixedAmount`    .
//         .
type PlatformFeeInput struct {
	FixedAmount *int64 `json:"fixedAmount,omitempty"`
	FixedRate   *int32 `json:"fixedRate,omitempty"`
}

// PlatformFixedAmountFee  
//
//       .
type PlatformFixedAmountFee struct {
	Amount int64  `json:"amount"`
	Type   string `json:"type"`
}

// PlatformFixedRateFee  
//
//        .
type PlatformFixedRateFee struct {
	// Rate      ,    (10^-5)    . `  * rate * 10^5` (`rate * 10^3 %`)   .
	Rate int32  `json:"rate"`
	Type string `json:"type"`
}

// PlatformInsufficientDataToChangePartnerTypeError       
type PlatformInsufficientDataToChangePartnerTypeError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformManualTransfer  
type PlatformManualTransfer struct {
	GraphqlId string  `json:"graphqlId"`
	Id        string  `json:"id"`
	IsForTest bool    `json:"isForTest"`
	Memo      *string `json:"memo,omitempty"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner          PlatformPartner `json:"partner"`
	PayoutGraphqlId  *string         `json:"payoutGraphqlId,omitempty"`
	PayoutId         *string         `json:"payoutId,omitempty"`
	SettlementAmount int64           `json:"settlementAmount"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate          openapi_types.Date `json:"settlementDate"`
	SettlementTaxFreeAmount int64              `json:"settlementTaxFreeAmount"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformManualTransferSummary defines model for PlatformManualTransferSummary.
type PlatformManualTransferSummary struct {
	GraphqlId string                         `json:"graphqlId"`
	Id        string                         `json:"id"`
	IsForTest bool                           `json:"isForTest"`
	Memo      *string                        `json:"memo,omitempty"`
	Partner   PlatformTransferSummaryPartner `json:"partner"`

	// PartnerUserDefinedProperties 5   . partner.userDefinedProperties  .
	PartnerUserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"partnerUserDefinedProperties"`
	SettlementAmount             int64                                 `json:"settlementAmount"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate          openapi_types.Date `json:"settlementDate"`
	SettlementTaxFreeAmount int64              `json:"settlementTaxFreeAmount"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformMemberCompanyConnectedPartnerBrnUnchangeableError        
type PlatformMemberCompanyConnectedPartnerBrnUnchangeableError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformMemberCompanyConnectedPartnerCannotBeScheduledError        
type PlatformMemberCompanyConnectedPartnerCannotBeScheduledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformMemberCompanyConnectedPartnerTypeUnchangeableError         
type PlatformMemberCompanyConnectedPartnerTypeUnchangeableError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformMemberCompanyConnectedPartnersCannotBeScheduledError        
type PlatformMemberCompanyConnectedPartnersCannotBeScheduledError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformMemberCompanyNotConnectableStatusError          
type PlatformMemberCompanyNotConnectableStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformMemberCompanyNotConnectedError       
type PlatformMemberCompanyNotConnectedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformNotEnabledError         
type PlatformNotEnabledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformNotSupportedBankError    
type PlatformNotSupportedBankError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformOngoingTaxInvoiceExistsError     
type PlatformOngoingTaxInvoiceExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformOrderCancelTransfer   
type PlatformOrderCancelTransfer struct {
	AdditionalFees []PlatformOrderTransferAdditionalFee `json:"additionalFees"`

	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Cancellation   
	Cancellation PlatformOrderTransferCancellation `json:"cancellation"`

	// Contract 
	//
	//           .
	//             .
	Contract   PlatformContract                 `json:"contract"`
	Discounts  []PlatformOrderTransferDiscount  `json:"discounts"`
	GraphqlId  string                           `json:"graphqlId"`
	Id         string                           `json:"id"`
	IsForTest  bool                             `json:"isForTest"`
	Memo       *string                          `json:"memo,omitempty"`
	OrderLines []PlatformOrderTransferOrderLine `json:"orderLines"`
	Parameters TransferParameters               `json:"parameters"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`

	// Payment  
	Payment         PlatformPayment `json:"payment"`
	PayoutGraphqlId *string         `json:"payoutGraphqlId,omitempty"`
	PayoutId        *string         `json:"payoutId,omitempty"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate openapi_types.Date `json:"settlementStartDate"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformOrderCancelTransferSummary defines model for PlatformOrderCancelTransferSummary.
type PlatformOrderCancelTransferSummary struct {
	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Contract 
	//
	//           .
	//             .
	Contract  PlatformContract               `json:"contract"`
	GraphqlId string                         `json:"graphqlId"`
	Id        string                         `json:"id"`
	IsForTest bool                           `json:"isForTest"`
	Memo      *string                        `json:"memo,omitempty"`
	Partner   PlatformTransferSummaryPartner `json:"partner"`

	// PartnerUserDefinedProperties 5   . partner.userDefinedProperties  .
	PartnerUserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"partnerUserDefinedProperties"`
	Payment                      PlatformTransferSummaryPayment        `json:"payment"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate openapi_types.Date `json:"settlementStartDate"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	StoreId               string                                `json:"storeId"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformOrderDetailMismatchedError defines model for PlatformOrderDetailMismatchedError.
type PlatformOrderDetailMismatchedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformOrderSettlementAmount   
//
//         .
type PlatformOrderSettlementAmount struct {
	AdditionalFee        int64 `json:"additionalFee"`
	AdditionalFeeVat     int64 `json:"additionalFeeVat"`
	Discount             int64 `json:"discount"`
	DiscountShare        int64 `json:"discountShare"`
	DiscountShareTaxFree int64 `json:"discountShareTaxFree"`
	DiscountTaxFree      int64 `json:"discountTaxFree"`
	Order                int64 `json:"order"`
	OrderTaxFree         int64 `json:"orderTaxFree"`
	Payment              int64 `json:"payment"`
	PaymentSupply        int64 `json:"paymentSupply"`
	PaymentTaxFree       int64 `json:"paymentTaxFree"`
	PaymentVat           int64 `json:"paymentVat"`

	// PaymentVatBurden         false  0, true    .
	PaymentVatBurden    int64                             `json:"paymentVatBurden"`
	PlatformFee         int64                             `json:"platformFee"`
	PlatformFeeVat      int64                             `json:"platformFeeVat"`
	Settlement          int64                             `json:"settlement"`
	SettlementTaxFree   int64                             `json:"settlementTaxFree"`
	UserDefinedFormulas PlatformUserDefinedFormulaResults `json:"userDefinedFormulas"`
}

// PlatformOrderTransfer  
type PlatformOrderTransfer struct {
	AdditionalFees []PlatformOrderTransferAdditionalFee `json:"additionalFees"`

	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Contract 
	//
	//           .
	//             .
	Contract   PlatformContract                 `json:"contract"`
	Discounts  []PlatformOrderTransferDiscount  `json:"discounts"`
	GraphqlId  string                           `json:"graphqlId"`
	Id         string                           `json:"id"`
	IsForTest  bool                             `json:"isForTest"`
	Memo       *string                          `json:"memo,omitempty"`
	OrderLines []PlatformOrderTransferOrderLine `json:"orderLines"`
	Parameters TransferParameters               `json:"parameters"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`

	// Payment  
	Payment         PlatformPayment `json:"payment"`
	PayoutGraphqlId *string         `json:"payoutGraphqlId,omitempty"`
	PayoutId        *string         `json:"payoutId,omitempty"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate openapi_types.Date `json:"settlementStartDate"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformOrderTransferAdditionalFee   
type PlatformOrderTransferAdditionalFee struct {
	Amount int64 `json:"amount"`

	// Policy   
	//
	//           .     ,  ,    .
	Policy PlatformAdditionalFeePolicy `json:"policy"`
	Vat    int64                       `json:"vat"`
}

// PlatformOrderTransferAlreadyCancelledError defines model for PlatformOrderTransferAlreadyCancelledError.
type PlatformOrderTransferAlreadyCancelledError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformOrderTransferCancellation   
type PlatformOrderTransferCancellation struct {
	CancelledAt time.Time `json:"cancelledAt"`
	Id          string    `json:"id"`
}

// PlatformOrderTransferDiscount  
type PlatformOrderTransferDiscount struct {
	Amount      int64 `json:"amount"`
	ShareAmount int64 `json:"shareAmount"`

	// SharePolicy   
	//
	//           ,         .
	//     ,    .
	SharePolicy        PlatformDiscountSharePolicy `json:"sharePolicy"`
	ShareTaxFreeAmount int64                       `json:"shareTaxFreeAmount"`
	TaxFreeAmount      int64                       `json:"taxFreeAmount"`
}

// PlatformOrderTransferOrderLine  
type PlatformOrderTransferOrderLine struct {
	AdditionalFees []PlatformOrderTransferAdditionalFee `json:"additionalFees"`

	// Amount   
	//
	//         .
	Amount    PlatformOrderSettlementAmount   `json:"amount"`
	Discounts []PlatformOrderTransferDiscount `json:"discounts"`

	// Product 
	Product  PlatformOrderTransferProduct `json:"product"`
	Quantity int32                        `json:"quantity"`
}

// PlatformOrderTransferProduct 
type PlatformOrderTransferProduct struct {
	Amount        int64   `json:"amount"`
	Id            string  `json:"id"`
	Name          string  `json:"name"`
	Tag           *string `json:"tag,omitempty"`
	TaxFreeAmount int64   `json:"taxFreeAmount"`
}

// PlatformOrderTransferSummary defines model for PlatformOrderTransferSummary.
type PlatformOrderTransferSummary struct {
	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Contract 
	//
	//           .
	//             .
	Contract  PlatformContract               `json:"contract"`
	GraphqlId string                         `json:"graphqlId"`
	Id        string                         `json:"id"`
	IsForTest bool                           `json:"isForTest"`
	Memo      *string                        `json:"memo,omitempty"`
	Partner   PlatformTransferSummaryPartner `json:"partner"`

	// PartnerUserDefinedProperties 5   . partner.userDefinedProperties  .
	PartnerUserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"partnerUserDefinedProperties"`
	Payment                      PlatformTransferSummaryPayment        `json:"payment"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate openapi_types.Date `json:"settlementStartDate"`

	// Status  
	Status                PlatformTransferStatus                `json:"status"`
	StoreId               string                                `json:"storeId"`
	Type                  string                                `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformPartner 
//
//     .
//    ,         .
type PlatformPartner struct {
	// Account   
	//
	// `currency`  KRW     API     .       .
	Account   PlatformAccount `json:"account"`
	AppliedAt time.Time       `json:"appliedAt"`

	// Contact     
	//
	//      .
	Contact           PlatformContact `json:"contact"`
	DefaultContractId string          `json:"defaultContractId"`
	GraphqlId         string          `json:"graphqlId"`
	Id                string          `json:"id"`
	IsArchived        bool            `json:"isArchived"`
	IsForTest         bool            `json:"isForTest"`
	Memo              *string         `json:"memo,omitempty"`
	Name              string          `json:"name"`

	// Status   
	Status PlatformPartnerStatus `json:"status"`
	Tags   []string              `json:"tags"`

	// Type    
	Type                  PlatformPartnerType `json:"type"`
	UserDefinedProperties PlatformProperties  `json:"userDefinedProperties"`
}

// PlatformPartnerBusinessStatus    
type PlatformPartnerBusinessStatus string

// PlatformPartnerContractSummary    
type PlatformPartnerContractSummary struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

// PlatformPartnerFilterInput    
type PlatformPartnerFilterInput struct {
	// AccountCurrencies     ,         .
	AccountCurrencies *[]Currency `json:"accountCurrencies,omitempty"`

	// AccountStatuses             .
	AccountStatuses *[]PlatformAccountStatus `json:"accountStatuses,omitempty"`

	// Banks     ,         .
	Banks *[]Bank `json:"banks,omitempty"`

	// BusinessStatuses             .
	BusinessStatuses *[]PlatformPartnerBusinessStatus `json:"businessStatuses,omitempty"`

	// ContractIds     ,       id   .
	ContractIds *[]string `json:"contractIds,omitempty"`

	// Ids     ,        .
	Ids *[]string `json:"ids,omitempty"`

	// IsArchived true    , false     .  false .
	IsArchived *bool `json:"isArchived,omitempty"`

	// Keyword     
	//
	//     ,     .      .
	Keyword *PlatformPartnerFilterInputKeyword `json:"keyword,omitempty"`

	// MemberCompanyConnectionStatuses               .
	MemberCompanyConnectionStatuses *[]PlatformPartnerMemberCompanyConnectionStatus `json:"memberCompanyConnectionStatuses,omitempty"`

	// Tags              .
	Tags *[]string `json:"tags,omitempty"`

	// TaxationTypes             .
	TaxationTypes *[]PlatformPartnerTaxationType `json:"taxationTypes,omitempty"`

	// Types             .
	Types *[]PlatformPartnerTypeName `json:"types,omitempty"`
}

// PlatformPartnerFilterInputKeyword     
//
//     ,     .      .
type PlatformPartnerFilterInputKeyword struct {
	// AccountHolder        .
	AccountHolder *string `json:"accountHolder,omitempty"`

	// AccountNumber       .
	AccountNumber *string `json:"accountNumber,omitempty"`

	// BusinessRegistrationNumber       .
	BusinessRegistrationNumber *string `json:"businessRegistrationNumber,omitempty"`

	// DefaultContractId         .
	DefaultContractId *string `json:"defaultContractId,omitempty"`

	// Email        .
	Email *string `json:"email,omitempty"`

	// Id    id    .
	Id *string `json:"id,omitempty"`

	// Memo       .
	Memo *string `json:"memo,omitempty"`

	// Name        .
	Name *string `json:"name,omitempty"`
}

// PlatformPartnerFilterOptions       
type PlatformPartnerFilterOptions struct {
	ContractSummary []PlatformPartnerContractSummary `json:"contractSummary"`
	Tags            []string                         `json:"tags"`
}

// PlatformPartnerIdAlreadyExistsError defines model for PlatformPartnerIdAlreadyExistsError.
type PlatformPartnerIdAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerIdsAlreadyExistError defines model for PlatformPartnerIdsAlreadyExistError.
type PlatformPartnerIdsAlreadyExistError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformPartnerIdsDuplicatedError defines model for PlatformPartnerIdsDuplicatedError.
type PlatformPartnerIdsDuplicatedError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformPartnerManualSettlement defines model for PlatformPartnerManualSettlement.
type PlatformPartnerManualSettlement struct {
	Amount    int64   `json:"amount"`
	GraphqlId string  `json:"graphqlId"`
	Id        string  `json:"id"`
	IsForTest bool    `json:"isForTest"`
	Memo      *string `json:"memo,omitempty"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// Status  
	Status        PlatformPartnerSettlementStatus `json:"status"`
	TaxFreeAmount int64                           `json:"taxFreeAmount"`
	Type          string                          `json:"type"`
}

// PlatformPartnerMemberCompanyConnectionStatus      
type PlatformPartnerMemberCompanyConnectionStatus string

// PlatformPartnerNotFoundError defines model for PlatformPartnerNotFoundError.
type PlatformPartnerNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerOrderCancelSettlement defines model for PlatformPartnerOrderCancelSettlement.
type PlatformPartnerOrderCancelSettlement struct {
	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Contract 
	//
	//           .
	//             .
	Contract  PlatformContract `json:"contract"`
	GraphqlId string           `json:"graphqlId"`
	Id        string           `json:"id"`
	IsForTest bool             `json:"isForTest"`
	Memo      *string          `json:"memo,omitempty"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate           openapi_types.Date `json:"settlementDate"`
	SettlementStartDateRange DateRange          `json:"settlementStartDateRange"`

	// Status  
	Status PlatformPartnerSettlementStatus `json:"status"`
	Type   string                          `json:"type"`
}

// PlatformPartnerOrderSettlement defines model for PlatformPartnerOrderSettlement.
type PlatformPartnerOrderSettlement struct {
	// Amount   
	//
	//         .
	Amount PlatformOrderSettlementAmount `json:"amount"`

	// Contract 
	//
	//           .
	//             .
	Contract  PlatformContract `json:"contract"`
	GraphqlId string           `json:"graphqlId"`
	Id        string           `json:"id"`
	IsForTest bool             `json:"isForTest"`
	Memo      *string          `json:"memo,omitempty"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`

	// SettlementCurrency  
	SettlementCurrency Currency `json:"settlementCurrency"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate           openapi_types.Date `json:"settlementDate"`
	SettlementStartDateRange DateRange          `json:"settlementStartDateRange"`

	// Status  
	Status PlatformPartnerSettlementStatus `json:"status"`
	Type   string                          `json:"type"`
}

// PlatformPartnerScheduleAlreadyExistsError defines model for PlatformPartnerScheduleAlreadyExistsError.
type PlatformPartnerScheduleAlreadyExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerScheduleExistsError      
type PlatformPartnerScheduleExistsError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerSchedulesAlreadyExistError defines model for PlatformPartnerSchedulesAlreadyExistError.
type PlatformPartnerSchedulesAlreadyExistError struct {
	GraphqlIds []string `json:"graphqlIds"`
	Ids        []string `json:"ids"`
	Message    *string  `json:"message,omitempty"`
	Type       string   `json:"type"`
}

// PlatformPartnerSettlement defines model for PlatformPartnerSettlement.
type PlatformPartnerSettlement struct {
	union json.RawMessage
}

// PlatformPartnerSettlementFilterInput defines model for PlatformPartnerSettlementFilterInput.
type PlatformPartnerSettlementFilterInput struct {
	ContractIds          *[]string                                    `json:"contractIds,omitempty"`
	Keyword              *PlatformPartnerSettlementFilterKeywordInput `json:"keyword,omitempty"`
	PartnerIds           *[]string                                    `json:"partnerIds,omitempty"`
	PartnerTags          *[]string                                    `json:"partnerTags,omitempty"`
	SettlementCurrencies *[]Currency                                  `json:"settlementCurrencies,omitempty"`
	SettlementDates      *[]openapi_types.Date                        `json:"settlementDates,omitempty"`
	SettlementTypes      *[]PlatformPartnerSettlementType             `json:"settlementTypes,omitempty"`
	Statuses             *[]PlatformPartnerSettlementStatus           `json:"statuses,omitempty"`
}

// PlatformPartnerSettlementFilterKeywordInput defines model for PlatformPartnerSettlementFilterKeywordInput.
type PlatformPartnerSettlementFilterKeywordInput struct {
	BulkPayoutId        *string `json:"bulkPayoutId,omitempty"`
	PartnerSettlementId *string `json:"partnerSettlementId,omitempty"`
	PayoutId            *string `json:"payoutId,omitempty"`
}

// PlatformPartnerSettlementStatus  
type PlatformPartnerSettlementStatus string

// PlatformPartnerSettlementStatusStats defines model for PlatformPartnerSettlementStatusStats.
type PlatformPartnerSettlementStatusStats struct {
	InPayout        int64 `json:"inPayout"`
	PaidOut         int64 `json:"paidOut"`
	PayoutCancelled int64 `json:"payoutCancelled"`
	PayoutConfirmed int64 `json:"payoutConfirmed"`
	PayoutFailed    int64 `json:"payoutFailed"`
	PayoutPrepared  int64 `json:"payoutPrepared"`
	PayoutScheduled int64 `json:"payoutScheduled"`
	PayoutWithheld  int64 `json:"payoutWithheld"`
}

// PlatformPartnerSettlementType  
type PlatformPartnerSettlementType string

// PlatformPartnerStatus   
type PlatformPartnerStatus string

// PlatformPartnerTaxationType    
type PlatformPartnerTaxationType string

// PlatformPartnerTaxationTypeIsSimpleError         
type PlatformPartnerTaxationTypeIsSimpleError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerType    
type PlatformPartnerType struct {
	union json.RawMessage
}

// PlatformPartnerTypeBusiness   
//
//      .
type PlatformPartnerTypeBusiness struct {
	BusinessClass              *string `json:"businessClass,omitempty"`
	BusinessRegistrationNumber string  `json:"businessRegistrationNumber"`

	// BusinessStatus    
	BusinessStatus                      PlatformPartnerBusinessStatus `json:"businessStatus"`
	BusinessType                        *string                       `json:"businessType,omitempty"`
	CompanyAddress                      *string                       `json:"companyAddress,omitempty"`
	CompanyName                         string                        `json:"companyName"`
	MemberCompanyConnectionFailedReason *string                       `json:"memberCompanyConnectionFailedReason,omitempty"`

	// MemberCompanyConnectionStatus      
	MemberCompanyConnectionStatus PlatformPartnerMemberCompanyConnectionStatus `json:"memberCompanyConnectionStatus"`
	RepresentativeName            string                                       `json:"representativeName"`

	// TaxationType    
	TaxationType PlatformPartnerTaxationType `json:"taxationType"`
	Type         string                      `json:"type"`
}

// PlatformPartnerTypeIsNotBusinessError     
type PlatformPartnerTypeIsNotBusinessError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPartnerTypeName    
type PlatformPartnerTypeName string

// PlatformPartnerTypeNonWhtPayer    
//
//      .
type PlatformPartnerTypeNonWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
	Type      string              `json:"type"`
}

// PlatformPartnerTypeWhtPayer    
//
//      .
type PlatformPartnerTypeWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
	Type      string              `json:"type"`
}

// PlatformPayer   
//
//    ,      .
type PlatformPayer string

// PlatformPayment  
type PlatformPayment struct {
	union json.RawMessage
}

// PlatformPaymentMethod  
type PlatformPaymentMethod struct {
	union json.RawMessage
}

// PlatformPaymentMethodCard 
type PlatformPaymentMethodCard struct {
	Type string `json:"type"`
}

// PlatformPaymentMethodCardInput defines model for PlatformPaymentMethodCardInput.
type PlatformPaymentMethodCardInput = map[string]interface{}

// PlatformPaymentMethodEasyPay  
type PlatformPaymentMethodEasyPay struct {
	// MethodType   
	MethodType *EasyPayMethodType `json:"methodType,omitempty"`

	// Provider  
	Provider *EasyPayProvider `json:"provider,omitempty"`
	Type     string           `json:"type"`
}

// PlatformPaymentMethodEasyPayInput    
type PlatformPaymentMethodEasyPayInput struct {
	// MethodType   
	MethodType *EasyPayMethodType `json:"methodType,omitempty"`

	// Provider  
	Provider *EasyPayProvider `json:"provider,omitempty"`
}

// PlatformPaymentMethodGiftCertificate 
type PlatformPaymentMethodGiftCertificate struct {
	Type string `json:"type"`
}

// PlatformPaymentMethodGiftCertificateInput defines model for PlatformPaymentMethodGiftCertificateInput.
type PlatformPaymentMethodGiftCertificateInput = map[string]interface{}

// PlatformPaymentMethodInput    
type PlatformPaymentMethodInput struct {
	Card *PlatformPaymentMethodCardInput `json:"card,omitempty"`

	// EasyPay    
	EasyPay         *PlatformPaymentMethodEasyPayInput         `json:"easyPay,omitempty"`
	GiftCertificate *PlatformPaymentMethodGiftCertificateInput `json:"giftCertificate,omitempty"`
	Mobile          *PlatformPaymentMethodMobileInput          `json:"mobile,omitempty"`
	Transfer        *PlatformPaymentMethodTransferInput        `json:"transfer,omitempty"`
	VirtualAccount  *PlatformPaymentMethodVirtualAccountInput  `json:"virtualAccount,omitempty"`
}

// PlatformPaymentMethodMobile 
type PlatformPaymentMethodMobile struct {
	Type string `json:"type"`
}

// PlatformPaymentMethodMobileInput defines model for PlatformPaymentMethodMobileInput.
type PlatformPaymentMethodMobileInput = map[string]interface{}

// PlatformPaymentMethodTransfer 
type PlatformPaymentMethodTransfer struct {
	Type string `json:"type"`
}

// PlatformPaymentMethodTransferInput defines model for PlatformPaymentMethodTransferInput.
type PlatformPaymentMethodTransferInput = map[string]interface{}

// PlatformPaymentMethodVirtualAccount 
type PlatformPaymentMethodVirtualAccount struct {
	Type string `json:"type"`
}

// PlatformPaymentMethodVirtualAccountInput defines model for PlatformPaymentMethodVirtualAccountInput.
type PlatformPaymentMethodVirtualAccountInput = map[string]interface{}

// PlatformPaymentNotFoundError defines model for PlatformPaymentNotFoundError.
type PlatformPaymentNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformPayout defines model for PlatformPayout.
type PlatformPayout struct {
	Account             PlatformPayoutAccount `json:"account"`
	Amount              int64                 `json:"amount"`
	BulkPayoutGraphqlId string                `json:"bulkPayoutGraphqlId"`
	BulkPayoutId        string                `json:"bulkPayoutId"`
	CreatedAt           time.Time             `json:"createdAt"`

	// Currency  
	Currency             Currency             `json:"currency"`
	DeductWht            bool                 `json:"deductWht"`
	DepositMemo          *string              `json:"depositMemo,omitempty"`
	FailReason           *string              `json:"failReason,omitempty"`
	GraphqlId            string               `json:"graphqlId"`
	Id                   string               `json:"id"`
	IncomeTaxAmount      int64                `json:"incomeTaxAmount"`
	LocalIncomeTaxAmount int64                `json:"localIncomeTaxAmount"`
	Memo                 *string              `json:"memo,omitempty"`
	Method               PlatformPayoutMethod `json:"method"`

	// Partner 
	//
	//     .
	//    ,         .
	Partner              PlatformPartner      `json:"partner"`
	ScheduledAt          *time.Time           `json:"scheduledAt,omitempty"`
	SettlementAmount     int64                `json:"settlementAmount"`
	SettlementAmountType SettlementAmountType `json:"settlementAmountType"`

	// SettlementStatement    
	SettlementStatement     PlatformPayoutSettlementStatementSummary `json:"settlementStatement"`
	SettlementTaxFreeAmount int64                                    `json:"settlementTaxFreeAmount"`
	Status                  PlatformPayoutStatus                     `json:"status"`
	StatusUpdatedAt         time.Time                                `json:"statusUpdatedAt"`
	SupplyAmount            int64                                    `json:"supplyAmount"`
	TaxFreeAmount           int64                                    `json:"taxFreeAmount"`
	TaxInvoiceId            *string                                  `json:"taxInvoiceId,omitempty"`
	TaxInvoiceStatus        PlatformPayoutTaxInvoiceStatus           `json:"taxInvoiceStatus"`
	VatAmount               int64                                    `json:"vatAmount"`
	WithdrawalMemo          *string                                  `json:"withdrawalMemo,omitempty"`
}

// PlatformPayoutAccount defines model for PlatformPayoutAccount.
type PlatformPayoutAccount struct {
	// Bank 
	Bank   Bank   `json:"bank"`
	Holder string `json:"holder"`
	Number string `json:"number"`
}

// PlatformPayoutFilterInput     
type PlatformPayoutFilterInput struct {
	// Criteria    
	Criteria PlatformPayoutFilterInputCriteria `json:"criteria"`

	// PartnerIds            .
	PartnerIds *[]string `json:"partnerIds,omitempty"`

	// PartnerTags              .
	PartnerTags *[]string `json:"partnerTags,omitempty"`

	// PartnerTaxationTypes             .
	PartnerTaxationTypes *[]PlatformPartnerTaxationType `json:"partnerTaxationTypes,omitempty"`

	// PartnerTypes            .
	PartnerTypes *[]PlatformPartnerTypeName `json:"partnerTypes,omitempty"`

	// PayoutAccountBanks             .
	PayoutAccountBanks *[]Bank `json:"payoutAccountBanks,omitempty"`

	// PayoutCurrencies            .
	PayoutCurrencies *[]Currency `json:"payoutCurrencies,omitempty"`

	// PayoutIds            .
	PayoutIds *[]string `json:"payoutIds,omitempty"`

	// SettlementStatementStatuses             .
	SettlementStatementStatuses *[]PlatformPayoutSettlementStatementStatus `json:"settlementStatementStatuses,omitempty"`

	// Statuses            .
	Statuses *[]PlatformPayoutStatus `json:"statuses,omitempty"`

	// TaxInvoiceStatuses            .
	TaxInvoiceStatuses *[]PlatformPayoutTaxInvoiceStatus `json:"taxInvoiceStatuses,omitempty"`
}

// PlatformPayoutFilterInputCriteria    
type PlatformPayoutFilterInputCriteria struct {
	BulkPayoutId *string `json:"bulkPayoutId,omitempty"`
	PayoutId     *string `json:"payoutId,omitempty"`

	// ScheduledTimestampRange  
	ScheduledTimestampRange *DateTimeRange `json:"scheduledTimestampRange,omitempty"`
	SettlementStatementId   *string        `json:"settlementStatementId,omitempty"`

	// SettlementStatementIssuedTimestampRange  
	SettlementStatementIssuedTimestampRange *DateTimeRange `json:"settlementStatementIssuedTimestampRange,omitempty"`

	// StatusUpdatedTimestampRange  
	StatusUpdatedTimestampRange *DateTimeRange `json:"statusUpdatedTimestampRange,omitempty"`
	TaxInvoiceId                *string        `json:"taxInvoiceId,omitempty"`

	// TimestampRange  
	TimestampRange *DateTimeRange `json:"timestampRange,omitempty"`
}

// PlatformPayoutMethod defines model for PlatformPayoutMethod.
type PlatformPayoutMethod string

// PlatformPayoutSettlementStatementStatus    
type PlatformPayoutSettlementStatementStatus string

// PlatformPayoutSettlementStatementSummary    
type PlatformPayoutSettlementStatementSummary struct {
	Id       *string    `json:"id,omitempty"`
	IssuedAt *time.Time `json:"issuedAt,omitempty"`

	// Status    
	Status PlatformPayoutSettlementStatementStatus `json:"status"`
}

// PlatformPayoutStatus defines model for PlatformPayoutStatus.
type PlatformPayoutStatus string

// PlatformPayoutStatusStats defines model for PlatformPayoutStatusStats.
type PlatformPayoutStatusStats struct {
	Cancelled  int64 `json:"cancelled"`
	Confirmed  int64 `json:"confirmed"`
	Failed     int64 `json:"failed"`
	Prepared   int64 `json:"prepared"`
	Processing int64 `json:"processing"`
	Scheduled  int64 `json:"scheduled"`
	Stopped    int64 `json:"stopped"`
	Succeeded  int64 `json:"succeeded"`
}

// PlatformPayoutTaxInvoiceStatus defines model for PlatformPayoutTaxInvoiceStatus.
type PlatformPayoutTaxInvoiceStatus string

// PlatformPortOnePayment   
type PlatformPortOnePayment struct {
	ChannelKey string `json:"channelKey"`

	// Currency  
	Currency Currency `json:"currency"`
	Id       string   `json:"id"`

	// Method  
	Method    *PlatformPaymentMethod `json:"method,omitempty"`
	OrderName string                 `json:"orderName"`
	PaidAt    time.Time              `json:"paidAt"`
	StoreId   string                 `json:"storeId"`
	Type      string                 `json:"type"`
}

// PlatformPortOnePaymentCancelAmountType  
type PlatformPortOnePaymentCancelAmountType string

// PlatformProductIdDuplicatedError defines model for PlatformProductIdDuplicatedError.
type PlatformProductIdDuplicatedError struct {
	Id      string  `json:"id"`
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformProductIdNotFoundError defines model for PlatformProductIdNotFoundError.
type PlatformProductIdNotFoundError struct {
	Id      string  `json:"id"`
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformProperties defines model for PlatformProperties.
type PlatformProperties map[string]PlatformUserDefinedPropertyValue

// PlatformSetting  
type PlatformSetting struct {
	AdjustSettlementDateAfterHolidayIfEarlier bool                 `json:"adjustSettlementDateAfterHolidayIfEarlier"`
	DeductWht                                 bool                 `json:"deductWht"`
	DefaultDepositMemo                        *string              `json:"defaultDepositMemo,omitempty"`
	DefaultWithdrawalMemo                     *string              `json:"defaultWithdrawalMemo,omitempty"`
	IsForTest                                 bool                 `json:"isForTest"`
	SettlementAmountType                      SettlementAmountType `json:"settlementAmountType"`
	SupportsMultipleOrderTransfersPerPartner  bool                 `json:"supportsMultipleOrderTransfersPerPartner"`
}

// PlatformSettlementAmountExceededError     
type PlatformSettlementAmountExceededError struct {
	AllowedAmount int64   `json:"allowedAmount"`
	Message       *string `json:"message,omitempty"`

	// ProductId    .
	ProductId       *string                    `json:"productId,omitempty"`
	RequestedAmount int64                      `json:"requestedAmount"`
	Type            PlatformAmountExceededType `json:"type"`
}

// PlatformSettlementCancelAmountExceededPortOneCancelError            
type PlatformSettlementCancelAmountExceededPortOneCancelError struct {
	// AmountType  
	AmountType                       PlatformPortOnePaymentCancelAmountType `json:"amountType"`
	Message                          *string                                `json:"message,omitempty"`
	PortOneCancelAmount              int64                                  `json:"portOneCancelAmount"`
	RegisteredSettlementCancelAmount int64                                  `json:"registeredSettlementCancelAmount"`
	RequestSettlementCancelAmount    int64                                  `json:"requestSettlementCancelAmount"`
	Type                             string                                 `json:"type"`
}

// PlatformSettlementCycle  
//
// , ,  ,      .
type PlatformSettlementCycle struct {
	// DatePolicy   
	DatePolicy PlatformSettlementCycleDatePolicy `json:"datePolicy"`

	// LagDays ( )        .  1   10    .
	LagDays int32 `json:"lagDays"`

	// Method     
	Method PlatformSettlementCycleMethod `json:"method"`
}

// PlatformSettlementCycleDatePolicy   
type PlatformSettlementCycleDatePolicy string

// PlatformSettlementCycleInput     
type PlatformSettlementCycleInput struct {
	// DatePolicy   
	DatePolicy PlatformSettlementCycleDatePolicy `json:"datePolicy"`

	// LagDays ( )        .  1   10    .
	LagDays int32 `json:"lagDays"`

	// Method       
	//
	//      .
	Method PlatformSettlementCycleMethodInput `json:"method"`
}

// PlatformSettlementCycleMethod     
type PlatformSettlementCycleMethod struct {
	union json.RawMessage
}

// PlatformSettlementCycleMethodDaily  
type PlatformSettlementCycleMethodDaily struct {
	Type string `json:"type"`
}

// PlatformSettlementCycleMethodDailyInput defines model for PlatformSettlementCycleMethodDailyInput.
type PlatformSettlementCycleMethodDailyInput = map[string]interface{}

// PlatformSettlementCycleMethodInput       
//
//      .
type PlatformSettlementCycleMethodInput struct {
	Daily       *PlatformSettlementCycleMethodDailyInput       `json:"daily,omitempty"`
	ManualDates *PlatformSettlementCycleMethodManualDatesInput `json:"manualDates,omitempty"`
	Monthly     *PlatformSettlementCycleMethodMonthlyInput     `json:"monthly,omitempty"`
	Weekly      *PlatformSettlementCycleMethodWeeklyInput      `json:"weekly,omitempty"`
}

// PlatformSettlementCycleMethodManualDates  (, ) 
type PlatformSettlementCycleMethodManualDates struct {
	Dates []MonthDay `json:"dates"`
	Type  string     `json:"type"`
}

// PlatformSettlementCycleMethodManualDatesInput defines model for PlatformSettlementCycleMethodManualDatesInput.
type PlatformSettlementCycleMethodManualDatesInput struct {
	Dates []MonthDay `json:"dates"`
}

// PlatformSettlementCycleMethodMonthly   () 
type PlatformSettlementCycleMethodMonthly struct {
	DaysOfMonth []int32 `json:"daysOfMonth"`
	Type        string  `json:"type"`
}

// PlatformSettlementCycleMethodMonthlyInput defines model for PlatformSettlementCycleMethodMonthlyInput.
type PlatformSettlementCycleMethodMonthlyInput struct {
	DaysOfMonth []int32 `json:"daysOfMonth"`
}

// PlatformSettlementCycleMethodWeekly    
type PlatformSettlementCycleMethodWeekly struct {
	DaysOfWeek []DayOfWeek `json:"daysOfWeek"`
	Type       string      `json:"type"`
}

// PlatformSettlementCycleMethodWeeklyInput defines model for PlatformSettlementCycleMethodWeeklyInput.
type PlatformSettlementCycleMethodWeeklyInput struct {
	DaysOfWeek []DayOfWeek `json:"daysOfWeek"`
}

// PlatformSettlementCycleType     
type PlatformSettlementCycleType string

// PlatformSettlementDateEarlierThanSettlementStartDateError     
type PlatformSettlementDateEarlierThanSettlementStartDateError struct {
	Message *string `json:"message,omitempty"`

	// SettlementDate   , `yyyy-MM-dd`  .
	SettlementDate openapi_types.Date `json:"settlementDate"`

	// SettlementStartDate   , `yyyy-MM-dd`  .
	SettlementStartDate openapi_types.Date `json:"settlementStartDate"`
	Type                string             `json:"type"`
}

// PlatformSettlementParameterNotFoundError     
type PlatformSettlementParameterNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformSettlementParameterValue    
type PlatformSettlementParameterValue struct {
	Decimal int64 `json:"decimal"`

	// DecimalScale    `decimalScale`     0 .
	//    0 ~ 5 .
	DecimalScale *int32 `json:"decimalScale,omitempty"`
}

// PlatformSettlementPaymentAmountExceededPortOnePaymentError           
type PlatformSettlementPaymentAmountExceededPortOnePaymentError struct {
	Message                           *string `json:"message,omitempty"`
	PortOnePaymentAmount              int64   `json:"portOnePaymentAmount"`
	RegisteredSettlementPaymentAmount int64   `json:"registeredSettlementPaymentAmount"`
	RequestSettlementPaymentAmount    int64   `json:"requestSettlementPaymentAmount"`
	Type                              string  `json:"type"`
}

// PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError         
type PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError struct {
	Message                                 *string `json:"message,omitempty"`
	PortOneSupplyWithVatAmount              int64   `json:"portOneSupplyWithVatAmount"`
	RegisteredSettlementSupplyWithVatAmount int64   `json:"registeredSettlementSupplyWithVatAmount"`
	RequestSettlementSupplyWithVatAmount    int64   `json:"requestSettlementSupplyWithVatAmount"`
	Type                                    string  `json:"type"`
}

// PlatformSettlementTaxFreeAmountExceededPortOnePaymentError           
type PlatformSettlementTaxFreeAmountExceededPortOnePaymentError struct {
	Message                           *string `json:"message,omitempty"`
	PortOneTaxFreeAmount              int64   `json:"portOneTaxFreeAmount"`
	RegisteredSettlementTaxFreeAmount int64   `json:"registeredSettlementTaxFreeAmount"`
	RequestSettlementTaxFreeAmount    int64   `json:"requestSettlementTaxFreeAmount"`
	Type                              string  `json:"type"`
}

// PlatformTargetPartnerNotFoundError      
type PlatformTargetPartnerNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformTaxationType   
type PlatformTaxationType string

// PlatformTransfer 
//
//            .
//    ,   ,   .
type PlatformTransfer struct {
	union json.RawMessage
}

// PlatformTransferAlreadyExistsError defines model for PlatformTransferAlreadyExistsError.
type PlatformTransferAlreadyExistsError struct {
	Message           *string `json:"message,omitempty"`
	TransferGraphqlId string  `json:"transferGraphqlId"`
	TransferId        string  `json:"transferId"`
	Type              string  `json:"type"`
}

// PlatformTransferDiscountSharePolicyNotFoundError defines model for PlatformTransferDiscountSharePolicyNotFoundError.
type PlatformTransferDiscountSharePolicyNotFoundError struct {
	DiscountSharePolicyGraphqlId string  `json:"discountSharePolicyGraphqlId"`
	DiscountSharePolicyId        string  `json:"discountSharePolicyId"`
	Message                      *string `json:"message,omitempty"`
	ProductId                    *string `json:"productId,omitempty"`
	Type                         string  `json:"type"`
}

// PlatformTransferFilterInput    
//
//           .
type PlatformTransferFilterInput struct {
	// AdditionalFeePolicyIds                .
	AdditionalFeePolicyIds *[]string `json:"additionalFeePolicyIds,omitempty"`

	// ChannelKeys             .
	ChannelKeys *[]string `json:"channelKeys,omitempty"`

	// ContractIds             .
	ContractIds *[]string `json:"contractIds,omitempty"`

	// DiscountSharePolicyIds                 .
	DiscountSharePolicyIds *[]string `json:"discountSharePolicyIds,omitempty"`

	// IsForTest Query Parameter test    Query Parameter test    .
	// Query Parameter test Filter isForTest      false .
	IsForTest *bool `json:"isForTest,omitempty"`

	// Keyword     
	//
	//     ,     .      .
	Keyword *PlatformTransferFilterInputKeyword `json:"keyword,omitempty"`

	// PartnerTags                .
	PartnerTags *[]string `json:"partnerTags,omitempty"`

	// PaymentMethodTypes             .
	PaymentMethodTypes       *[]PaymentMethodType `json:"paymentMethodTypes,omitempty"`
	SettlementDateRange      *DateRange           `json:"settlementDateRange,omitempty"`
	SettlementStartDateRange *DateRange           `json:"settlementStartDateRange,omitempty"`

	// Statuses            .
	Statuses *[]PlatformTransferStatus `json:"statuses,omitempty"`

	// Types            .
	Types *[]PlatformTransferType `json:"types,omitempty"`
}

// PlatformTransferFilterInputKeyword     
//
//     ,     .      .
type PlatformTransferFilterInputKeyword struct {
	// All       .
	All *string `json:"all,omitempty"`

	// PartnerId    partnerId    .
	PartnerId *string `json:"partnerId,omitempty"`

	// PartnerMemo    partnerMemo    .
	PartnerMemo *string `json:"partnerMemo,omitempty"`

	// PartnerName    partnerName    .
	PartnerName *string `json:"partnerName,omitempty"`

	// PartnerSettlementId    partnerSettlementId    .
	PartnerSettlementId *string `json:"partnerSettlementId,omitempty"`

	// PaymentId    paymentId    .
	PaymentId *string `json:"paymentId,omitempty"`

	// PayoutId       .
	PayoutId *string `json:"payoutId,omitempty"`

	// ProductId    productId    .
	ProductId *string `json:"productId,omitempty"`

	// ProductName    productName    .
	ProductName *string `json:"productName,omitempty"`

	// TransferId    transferId    .
	TransferId *string `json:"transferId,omitempty"`

	// TransferMemo    transferMemo    .
	TransferMemo *string `json:"transferMemo,omitempty"`
}

// PlatformTransferNonDeletableStatusError defines model for PlatformTransferNonDeletableStatusError.
type PlatformTransferNonDeletableStatusError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformTransferNotFoundError defines model for PlatformTransferNotFoundError.
type PlatformTransferNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformTransferStatus  
type PlatformTransferStatus string

// PlatformTransferSummary defines model for PlatformTransferSummary.
type PlatformTransferSummary struct {
	union json.RawMessage
}

// PlatformTransferSummaryExternalPayment defines model for PlatformTransferSummaryExternalPayment.
type PlatformTransferSummaryExternalPayment struct {
	// Currency  
	Currency   Currency           `json:"currency"`
	Id         string             `json:"id"`
	MethodType *PaymentMethodType `json:"methodType,omitempty"`
	OrderName  *string            `json:"orderName,omitempty"`
	Type       string             `json:"type"`
}

// PlatformTransferSummaryPartner defines model for PlatformTransferSummaryPartner.
type PlatformTransferSummaryPartner struct {
	GraphqlId string `json:"graphqlId"`
	Id        string `json:"id"`
	Name      string `json:"name"`

	// TaxationType    
	TaxationType *PlatformPartnerTaxationType `json:"taxationType,omitempty"`

	// Type  
	Type                  PlatformTransferSummaryPartnerType    `json:"type"`
	UserDefinedProperties []PlatformUserDefinedPropertyKeyValue `json:"userDefinedProperties"`
}

// PlatformTransferSummaryPartnerType  
type PlatformTransferSummaryPartnerType string

// PlatformTransferSummaryPayment defines model for PlatformTransferSummaryPayment.
type PlatformTransferSummaryPayment struct {
	union json.RawMessage
}

// PlatformTransferSummaryPortOnePayment defines model for PlatformTransferSummaryPortOnePayment.
type PlatformTransferSummaryPortOnePayment struct {
	// Currency  
	Currency   Currency           `json:"currency"`
	Id         string             `json:"id"`
	MethodType *PaymentMethodType `json:"methodType,omitempty"`
	OrderName  string             `json:"orderName"`
	Type       string             `json:"type"`
}

// PlatformTransferType defines model for PlatformTransferType.
type PlatformTransferType string

// PlatformUserDefinedFormulaResults defines model for PlatformUserDefinedFormulaResults.
type PlatformUserDefinedFormulaResults map[string]int64

// PlatformUserDefinedPropertyKeyValue   
type PlatformUserDefinedPropertyKeyValue struct {
	Key   string                           `json:"key"`
	Value PlatformUserDefinedPropertyValue `json:"value"`
}

// PlatformUserDefinedPropertyNotFoundError       
type PlatformUserDefinedPropertyNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PlatformUserDefinedPropertyValue defines model for PlatformUserDefinedPropertyValue.
type PlatformUserDefinedPropertyValue struct {
	String string `json:"string"`
}

// PlatformWithdrawalAccountTransfer defines model for PlatformWithdrawalAccountTransfer.
type PlatformWithdrawalAccountTransfer struct {
	Amount                       int64     `json:"amount"`
	Balance                      *int64    `json:"balance,omitempty"`
	BankAccountGraphqlId         string    `json:"bankAccountGraphqlId"`
	BankAccountId                string    `json:"bankAccountId"`
	BulkAccountTransferGraphqlId *string   `json:"bulkAccountTransferGraphqlId,omitempty"`
	BulkAccountTransferId        *string   `json:"bulkAccountTransferId,omitempty"`
	BulkPayoutGraphqlId          *string   `json:"bulkPayoutGraphqlId,omitempty"`
	BulkPayoutId                 *string   `json:"bulkPayoutId,omitempty"`
	CreatedAt                    time.Time `json:"createdAt"`

	// Currency  
	Currency             Currency `json:"currency"`
	DepositAccountHolder string   `json:"depositAccountHolder"`
	DepositAccountNumber string   `json:"depositAccountNumber"`

	// DepositBank 
	DepositBank      Bank       `json:"depositBank"`
	DepositMemo      *string    `json:"depositMemo,omitempty"`
	DocumentId       *string    `json:"documentId,omitempty"`
	FailReason       *string    `json:"failReason,omitempty"`
	Id               string     `json:"id"`
	IsForTest        bool       `json:"isForTest"`
	PartnerGraphqlId *string    `json:"partnerGraphqlId,omitempty"`
	PartnerId        *string    `json:"partnerId,omitempty"`
	PayoutGraphqlId  *string    `json:"payoutGraphqlId,omitempty"`
	PayoutId         *string    `json:"payoutId,omitempty"`
	ScheduledAt      *time.Time `json:"scheduledAt,omitempty"`
	SequenceNumber   *int32     `json:"sequenceNumber,omitempty"`

	// Status   
	Status          PlatformAccountTransferStatus `json:"status"`
	StatusUpdatedAt time.Time                     `json:"statusUpdatedAt"`
	TradedAt        *time.Time                    `json:"tradedAt,omitempty"`
	Type            string                        `json:"type"`
	UpdatedAt       time.Time                     `json:"updatedAt"`
	WithdrawalMemo  *string                       `json:"withdrawalMemo,omitempty"`
	WithdrawalType  Type                          `json:"withdrawalType"`
}

// PortOneVersion  
type PortOneVersion string

// PreRegisterPaymentBody      
type PreRegisterPaymentBody struct {
	// Currency  
	Currency *Currency `json:"currency,omitempty"`

	// StoreId       ,      .
	StoreId       *string `json:"storeId,omitempty"`
	TaxFreeAmount *int64  `json:"taxFreeAmount,omitempty"`
	TotalAmount   *int64  `json:"totalAmount,omitempty"`
}

// PreRegisterPaymentError defines model for PreRegisterPaymentError.
type PreRegisterPaymentError struct {
	union json.RawMessage
}

// PreRegisterPaymentResponse     
type PreRegisterPaymentResponse = map[string]interface{}

// Promotion 
type Promotion struct {
	union json.RawMessage
}

// PromotionAmountDiscountScheme defines model for PromotionAmountDiscountScheme.
type PromotionAmountDiscountScheme struct {
	Amount int64  `json:"amount"`
	Type   string `json:"type"`
}

// PromotionCardCompany    
type PromotionCardCompany string

// PromotionDiscountPartition     
type PromotionDiscountPartition struct {
	AmountFrom int64                   `json:"amountFrom"`
	Scheme     PromotionDiscountScheme `json:"scheme"`
}

// PromotionDiscountPolicy   
type PromotionDiscountPolicy struct {
	Partitions []PromotionDiscountPartition `json:"partitions"`
}

// PromotionDiscountRetainOption defines model for PromotionDiscountRetainOption.
type PromotionDiscountRetainOption string

// PromotionDiscountRetainOptionShouldNotBeChangedError           
type PromotionDiscountRetainOptionShouldNotBeChangedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PromotionDiscountScheme defines model for PromotionDiscountScheme.
type PromotionDiscountScheme struct {
	union json.RawMessage
}

// PromotionNotFoundError    
type PromotionNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PromotionPayMethodDoesNotMatchError       
type PromotionPayMethodDoesNotMatchError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// PromotionPercentDiscountScheme defines model for PromotionPercentDiscountScheme.
type PromotionPercentDiscountScheme struct {
	Percent int32  `json:"percent"`
	Type    string `json:"type"`
}

// PromotionRecoverOption defines model for PromotionRecoverOption.
type PromotionRecoverOption struct {
	union json.RawMessage
}

// PromotionRecoverOptionNoRecover      
type PromotionRecoverOptionNoRecover struct {
	SpareBudget *PromotionSpareBudget `json:"spareBudget,omitempty"`
	Type        string                `json:"type"`
}

// PromotionRecoverOptionRecover      
type PromotionRecoverOptionRecover struct {
	Type string `json:"type"`
}

// PromotionSpareBudget defines model for PromotionSpareBudget.
type PromotionSpareBudget struct {
	union json.RawMessage
}

// PromotionSpareBudgetAmount defines model for PromotionSpareBudgetAmount.
type PromotionSpareBudgetAmount struct {
	Amount int64  `json:"amount"`
	Type   string `json:"type"`
}

// PromotionSpareBudgetPercent defines model for PromotionSpareBudgetPercent.
type PromotionSpareBudgetPercent struct {
	Percent int32  `json:"percent"`
	Type    string `json:"type"`
}

// PromotionStatus defines model for PromotionStatus.
type PromotionStatus string

// ReadyIdentityVerification    
type ReadyIdentityVerification struct {
	// Channel (,  )   
	Channel     *SelectedChannel `json:"channel,omitempty"`
	CustomData  *string          `json:"customData,omitempty"`
	Id          string           `json:"id"`
	RequestedAt time.Time        `json:"requestedAt"`

	// RequestedCustomer    
	RequestedCustomer IdentityVerificationRequestedCustomer `json:"requestedCustomer"`
	Status            string                                `json:"status"`
	StatusChangedAt   time.Time                             `json:"statusChangedAt"`
	UpdatedAt         time.Time                             `json:"updatedAt"`

	// Version  
	Version PortOneVersion `json:"version"`
}

// ReadyPayment   
type ReadyPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel *SelectedChannel `json:"channel,omitempty"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// ReadyPaymentTransaction   
type ReadyPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel *SelectedChannel `json:"channel,omitempty"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// RecoverPlatformAdditionalFeePolicyError defines model for RecoverPlatformAdditionalFeePolicyError.
type RecoverPlatformAdditionalFeePolicyError struct {
	union json.RawMessage
}

// RecoverPlatformAdditionalFeePolicyResponse      
type RecoverPlatformAdditionalFeePolicyResponse struct {
	// AdditionalFeePolicy   
	//
	//           .     ,  ,    .
	AdditionalFeePolicy PlatformAdditionalFeePolicy `json:"additionalFeePolicy"`
}

// RecoverPlatformContractError defines model for RecoverPlatformContractError.
type RecoverPlatformContractError struct {
	union json.RawMessage
}

// RecoverPlatformContractResponse    
type RecoverPlatformContractResponse struct {
	// Contract 
	//
	//           .
	//             .
	Contract PlatformContract `json:"contract"`
}

// RecoverPlatformDiscountSharePolicyError defines model for RecoverPlatformDiscountSharePolicyError.
type RecoverPlatformDiscountSharePolicyError struct {
	union json.RawMessage
}

// RecoverPlatformDiscountSharePolicyResponse     
type RecoverPlatformDiscountSharePolicyResponse struct {
	// DiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	DiscountSharePolicy PlatformDiscountSharePolicy `json:"discountSharePolicy"`
}

// RecoverPlatformPartnerError defines model for RecoverPlatformPartnerError.
type RecoverPlatformPartnerError struct {
	union json.RawMessage
}

// RecoverPlatformPartnerResponse    
type RecoverPlatformPartnerResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// RefreshTokenBody     
type RefreshTokenBody struct {
	RefreshToken string `json:"refreshToken"`
}

// RefreshTokenError defines model for RefreshTokenError.
type RefreshTokenError struct {
	union json.RawMessage
}

// RefreshTokenResponse    
type RefreshTokenResponse struct {
	// AccessToken 30   .
	AccessToken string `json:"accessToken"`

	// RefreshToken    ,           .
	//               API  .
	RefreshToken string `json:"refreshToken"`
}

// RefuseB2bTaxInvoiceRequestBody     
type RefuseB2bTaxInvoiceRequestBody struct {
	Memo *string `json:"memo,omitempty"`
}

// RefuseB2bTaxInvoiceRequestError defines model for RefuseB2bTaxInvoiceRequestError.
type RefuseB2bTaxInvoiceRequestError struct {
	union json.RawMessage
}

// RefuseB2bTaxInvoiceRequestResponse     
type RefuseB2bTaxInvoiceRequestResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// RegisterEscrowLogisticsBody      
type RegisterEscrowLogisticsBody struct {
	// Logistics 
	Logistics PaymentLogistics  `json:"logistics"`
	Products  *[]PaymentProduct `json:"products,omitempty"`

	// Receiver   
	Receiver *PaymentEscrowReceiverInput `json:"receiver,omitempty"`

	// SendEmail        .
	SendEmail *bool `json:"sendEmail,omitempty"`

	// Sender   
	Sender *PaymentEscrowSenderInput `json:"sender,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// RegisterStoreReceiptBody       
type RegisterStoreReceiptBody struct {
	Items   []RegisterStoreReceiptBodyItem `json:"items"`
	StoreId *string                        `json:"storeId,omitempty"`
}

// RegisterStoreReceiptBodyItem    
type RegisterStoreReceiptBodyItem struct {
	// Currency  
	Currency                        Currency `json:"currency"`
	StoreBusinessRegistrationNumber string   `json:"storeBusinessRegistrationNumber"`
	StoreName                       string   `json:"storeName"`
	SupplyAmount                    *int64   `json:"supplyAmount,omitempty"`
	TaxFreeAmount                   *int64   `json:"taxFreeAmount,omitempty"`
	TotalAmount                     int64    `json:"totalAmount"`
	VatAmount                       *int64   `json:"vatAmount,omitempty"`
}

// RegisterStoreReceiptError defines model for RegisterStoreReceiptError.
type RegisterStoreReceiptError struct {
	union json.RawMessage
}

// RegisterStoreReceiptResponse       
type RegisterStoreReceiptResponse struct {
	ReceiptUrl *string `json:"receiptUrl,omitempty"`
}

// RegisteredPaymentEscrow    
type RegisteredPaymentEscrow struct {
	AppliedAt     *time.Time `json:"appliedAt,omitempty"`
	Company       string     `json:"company"`
	InvoiceNumber string     `json:"invoiceNumber"`
	SentAt        *time.Time `json:"sentAt,omitempty"`
	Status        string     `json:"status"`
}

// RejectConfirmedPaymentEscrow   
type RejectConfirmedPaymentEscrow struct {
	AppliedAt     *time.Time `json:"appliedAt,omitempty"`
	Company       string     `json:"company"`
	InvoiceNumber string     `json:"invoiceNumber"`
	SentAt        *time.Time `json:"sentAt,omitempty"`
	Status        string     `json:"status"`
}

// RejectedPaymentEscrow  
type RejectedPaymentEscrow struct {
	AppliedAt     *time.Time `json:"appliedAt,omitempty"`
	Company       string     `json:"company"`
	InvoiceNumber string     `json:"invoiceNumber"`
	SentAt        *time.Time `json:"sentAt,omitempty"`
	Status        string     `json:"status"`
}

// RequestB2bTaxInvoiceResponse    
type RequestB2bTaxInvoiceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// RequestB2bTaxInvoiceReverseIssuanceBody     
type RequestB2bTaxInvoiceReverseIssuanceBody struct {
	Memo *string `json:"memo,omitempty"`

	// Modification     
	Modification *B2bTaxInvoiceModificationCreateBody `json:"modification,omitempty"`

	// TaxInvoice    
	TaxInvoice B2bTaxInvoiceInput `json:"taxInvoice"`
}

// RequestB2bTaxInvoiceReverseIssuanceError defines model for RequestB2bTaxInvoiceReverseIssuanceError.
type RequestB2bTaxInvoiceReverseIssuanceError struct {
	union json.RawMessage
}

// RequestB2bTaxInvoiceReverseIssuanceResponse     
type RequestB2bTaxInvoiceReverseIssuanceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// RequestedPaymentCancellation   
type RequestedPaymentCancellation struct {
	CancelledAt           *time.Time `json:"cancelledAt,omitempty"`
	EasyPayDiscountAmount *int64     `json:"easyPayDiscountAmount,omitempty"`
	Id                    string     `json:"id"`
	PgCancellationId      *string    `json:"pgCancellationId,omitempty"`
	Reason                string     `json:"reason"`
	RequestedAt           time.Time  `json:"requestedAt"`
	Status                string     `json:"status"`
	TaxFreeAmount         int64      `json:"taxFreeAmount"`
	TotalAmount           int64      `json:"totalAmount"`
	Trigger               *Trigger   `json:"trigger,omitempty"`
	VatAmount             int64      `json:"vatAmount"`
}

// RescheduleAdditionalFeePolicyError defines model for RescheduleAdditionalFeePolicyError.
type RescheduleAdditionalFeePolicyError struct {
	union json.RawMessage
}

// RescheduleContractError defines model for RescheduleContractError.
type RescheduleContractError struct {
	union json.RawMessage
}

// RescheduleDiscountSharePolicyError defines model for RescheduleDiscountSharePolicyError.
type RescheduleDiscountSharePolicyError struct {
	union json.RawMessage
}

// ReschedulePartnerError defines model for ReschedulePartnerError.
type ReschedulePartnerError struct {
	union json.RawMessage
}

// ReschedulePlatformAdditionalFeePolicyBody         
type ReschedulePlatformAdditionalFeePolicyBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update       
	//
	//      .
	Update UpdatePlatformAdditionalFeePolicyBody `json:"update"`
}

// ReschedulePlatformAdditionalFeePolicyResponse        
type ReschedulePlatformAdditionalFeePolicyResponse struct {
	// ScheduledAdditionalFeePolicy   
	//
	//           .     ,  ,    .
	ScheduledAdditionalFeePolicy PlatformAdditionalFeePolicy `json:"scheduledAdditionalFeePolicy"`
}

// ReschedulePlatformContractBody       
type ReschedulePlatformContractBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update     .      .
	//
	//      .
	Update UpdatePlatformContractBody `json:"update"`
}

// ReschedulePlatformContractResponse      
type ReschedulePlatformContractResponse struct {
	// ScheduledContract 
	//
	//           .
	//             .
	ScheduledContract PlatformContract `json:"scheduledContract"`
}

// ReschedulePlatformDiscountSharePolicyBody         
type ReschedulePlatformDiscountSharePolicyBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update       
	//
	//      .
	Update UpdatePlatformDiscountSharePolicyBody `json:"update"`
}

// ReschedulePlatformDiscountSharePolicyResponse        
type ReschedulePlatformDiscountSharePolicyResponse struct {
	// ScheduledDiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	ScheduledDiscountSharePolicy PlatformDiscountSharePolicy `json:"scheduledDiscountSharePolicy"`
}

// ReschedulePlatformPartnerBody       
type ReschedulePlatformPartnerBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update     
	//
	//      .
	Update UpdatePlatformPartnerBody `json:"update"`
}

// ReschedulePlatformPartnerResponse      
type ReschedulePlatformPartnerResponse struct {
	// ScheduledPartner 
	//
	//     .
	//    ,         .
	ScheduledPartner PlatformPartner `json:"scheduledPartner"`
}

// ResendIdentityVerificationError defines model for ResendIdentityVerificationError.
type ResendIdentityVerificationError struct {
	union json.RawMessage
}

// ResendIdentityVerificationResponse     
type ResendIdentityVerificationResponse = map[string]interface{}

// ResendWebhookBody     
type ResendWebhookBody struct {
	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`

	// WebhookId          
	WebhookId *string `json:"webhookId,omitempty"`
}

// ResendWebhookError defines model for ResendWebhookError.
type ResendWebhookError struct {
	union json.RawMessage
}

// ResendWebhookResponse    
type ResendWebhookResponse struct {
	// Webhook   
	Webhook PaymentWebhook `json:"webhook"`
}

// RevokePaymentSchedulesBody       
type RevokePaymentSchedulesBody struct {
	BillingKey  *string   `json:"billingKey,omitempty"`
	ScheduleIds *[]string `json:"scheduleIds,omitempty"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// RevokePaymentSchedulesError defines model for RevokePaymentSchedulesError.
type RevokePaymentSchedulesError struct {
	union json.RawMessage
}

// RevokePaymentSchedulesResponse      
type RevokePaymentSchedulesResponse struct {
	RevokedAt          *time.Time `json:"revokedAt,omitempty"`
	RevokedScheduleIds []string   `json:"revokedScheduleIds"`
}

// RevokedPaymentSchedule    
type RevokedPaymentSchedule struct {
	BillingKey string    `json:"billingKey"`
	CreatedAt  time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	RevokedAt         time.Time         `json:"revokedAt"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// ScheduleAdditionalFeePolicyError defines model for ScheduleAdditionalFeePolicyError.
type ScheduleAdditionalFeePolicyError struct {
	union json.RawMessage
}

// ScheduleContractError defines model for ScheduleContractError.
type ScheduleContractError struct {
	union json.RawMessage
}

// ScheduleDiscountSharePolicyError defines model for ScheduleDiscountSharePolicyError.
type ScheduleDiscountSharePolicyError struct {
	union json.RawMessage
}

// SchedulePartnerError defines model for SchedulePartnerError.
type SchedulePartnerError struct {
	union json.RawMessage
}

// SchedulePlatformAdditionalFeePolicyBody        
type SchedulePlatformAdditionalFeePolicyBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update       
	//
	//      .
	Update UpdatePlatformAdditionalFeePolicyBody `json:"update"`
}

// SchedulePlatformAdditionalFeePolicyResponse       
type SchedulePlatformAdditionalFeePolicyResponse struct {
	// ScheduledAdditionalFeePolicy   
	//
	//           .     ,  ,    .
	ScheduledAdditionalFeePolicy PlatformAdditionalFeePolicy `json:"scheduledAdditionalFeePolicy"`
}

// SchedulePlatformContractBody      
type SchedulePlatformContractBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update     .      .
	//
	//      .
	Update UpdatePlatformContractBody `json:"update"`
}

// SchedulePlatformContractResponse     
type SchedulePlatformContractResponse struct {
	// ScheduledContract 
	//
	//           .
	//             .
	ScheduledContract PlatformContract `json:"scheduledContract"`
}

// SchedulePlatformDiscountSharePolicyBody        
type SchedulePlatformDiscountSharePolicyBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update       
	//
	//      .
	Update UpdatePlatformDiscountSharePolicyBody `json:"update"`
}

// SchedulePlatformDiscountSharePolicyResponse       
type SchedulePlatformDiscountSharePolicyResponse struct {
	// ScheduledDiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	ScheduledDiscountSharePolicy PlatformDiscountSharePolicy `json:"scheduledDiscountSharePolicy"`
}

// SchedulePlatformPartnerBody      
type SchedulePlatformPartnerBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Update     
	//
	//      .
	Update UpdatePlatformPartnerBody `json:"update"`
}

// SchedulePlatformPartnerResponse     
type SchedulePlatformPartnerResponse struct {
	// ScheduledPartner 
	//
	//     .
	//    ,         .
	ScheduledPartner PlatformPartner `json:"scheduledPartner"`
}

// SchedulePlatformPartnersBody defines model for SchedulePlatformPartnersBody.
type SchedulePlatformPartnersBody struct {
	AppliedAt time.Time `json:"appliedAt"`

	// Filter    
	Filter *PlatformPartnerFilterInput        `json:"filter,omitempty"`
	Update SchedulePlatformPartnersBodyUpdate `json:"update"`
}

// SchedulePlatformPartnersBodyUpdate defines model for SchedulePlatformPartnersBodyUpdate.
type SchedulePlatformPartnersBodyUpdate struct {
	// Account      
	Account *SchedulePlatformPartnersBodyUpdateAccount `json:"account,omitempty"`

	// Contact      
	Contact           *SchedulePlatformPartnersBodyUpdateContact `json:"contact,omitempty"`
	DefaultContractId *string                                    `json:"defaultContractId,omitempty"`
	Memo              *string                                    `json:"memo,omitempty"`
	Name              *string                                    `json:"name,omitempty"`
	Tags              *[]string                                  `json:"tags,omitempty"`

	// Type       
	//
	//     .
	//               .
	Type                  *SchedulePlatformPartnersBodyUpdateType `json:"type,omitempty"`
	UserDefinedProperties *PlatformProperties                     `json:"userDefinedProperties,omitempty"`
}

// SchedulePlatformPartnersBodyUpdateAccount      
type SchedulePlatformPartnersBodyUpdateAccount struct {
	AccountVerificationId *string `json:"accountVerificationId,omitempty"`

	// Bank 
	Bank Bank `json:"bank"`

	// Currency  
	Currency Currency `json:"currency"`
	Holder   string   `json:"holder"`
	Number   string   `json:"number"`
}

// SchedulePlatformPartnersBodyUpdateContact      
type SchedulePlatformPartnersBodyUpdateContact struct {
	Email       *string `json:"email,omitempty"`
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// SchedulePlatformPartnersBodyUpdateType       
//
//     .
//               .
type SchedulePlatformPartnersBodyUpdateType struct {
	Business    *SchedulePlatformPartnersBodyUpdateTypeBusiness    `json:"business,omitempty"`
	NonWhtPayer *SchedulePlatformPartnersBodyUpdateTypeNonWhtPayer `json:"nonWhtPayer,omitempty"`
	WhtPayer    *SchedulePlatformPartnersBodyUpdateTypeWhtPayer    `json:"whtPayer,omitempty"`
}

// SchedulePlatformPartnersBodyUpdateTypeBusiness defines model for SchedulePlatformPartnersBodyUpdateTypeBusiness.
type SchedulePlatformPartnersBodyUpdateTypeBusiness struct {
	BusinessClass              *string `json:"businessClass,omitempty"`
	BusinessRegistrationNumber *string `json:"businessRegistrationNumber,omitempty"`
	BusinessType               *string `json:"businessType,omitempty"`
	CompanyAddress             *string `json:"companyAddress,omitempty"`
	CompanyName                *string `json:"companyName,omitempty"`
	CompanyVerificationId      *string `json:"companyVerificationId,omitempty"`
	RepresentativeName         *string `json:"representativeName,omitempty"`

	// TaxationType    
	TaxationType *PlatformPartnerTaxationType `json:"taxationType,omitempty"`
}

// SchedulePlatformPartnersBodyUpdateTypeNonWhtPayer defines model for SchedulePlatformPartnersBodyUpdateTypeNonWhtPayer.
type SchedulePlatformPartnersBodyUpdateTypeNonWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// SchedulePlatformPartnersBodyUpdateTypeWhtPayer defines model for SchedulePlatformPartnersBodyUpdateTypeWhtPayer.
type SchedulePlatformPartnersBodyUpdateTypeWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// SchedulePlatformPartnersError defines model for SchedulePlatformPartnersError.
type SchedulePlatformPartnersError struct {
	union json.RawMessage
}

// SchedulePlatformPartnersResponse defines model for SchedulePlatformPartnersResponse.
type SchedulePlatformPartnersResponse = map[string]interface{}

// ScheduledPaymentSchedule    
type ScheduledPaymentSchedule struct {
	BillingKey string    `json:"billingKey"`
	CreatedAt  time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// SelectedChannel (,  )   
type SelectedChannel struct {
	Id           *string `json:"id,omitempty"`
	Key          *string `json:"key,omitempty"`
	Name         *string `json:"name,omitempty"`
	PgMerchantId string  `json:"pgMerchantId"`

	// PgProvider PG  
	PgProvider PgProvider `json:"pgProvider"`

	// Type  
	Type SelectedChannelType `json:"type"`
}

// SelectedChannelType  
type SelectedChannelType string

// SendIdentityVerificationBody     
type SendIdentityVerificationBody struct {
	Bypass     *map[string]interface{} `json:"bypass,omitempty"`
	ChannelKey string                  `json:"channelKey"`
	CustomData *string                 `json:"customData,omitempty"`

	// Customer     
	Customer SendIdentityVerificationBodyCustomer `json:"customer"`

	// Method  
	Method IdentityVerificationMethod `json:"method"`

	// Operator  
	Operator IdentityVerificationOperator `json:"operator"`

	// StoreId       ,      .
	StoreId *string `json:"storeId,omitempty"`
}

// SendIdentityVerificationBodyCustomer     
type SendIdentityVerificationBodyCustomer struct {
	Id *string `json:"id,omitempty"`

	// IdentityNumber SMS    .
	IdentityNumber *string `json:"identityNumber,omitempty"`

	// IpAddress     .
	IpAddress string `json:"ipAddress"`
	Name      string `json:"name"`

	// PhoneNumber  (-)   .
	PhoneNumber string `json:"phoneNumber"`
}

// SendIdentityVerificationError defines model for SendIdentityVerificationError.
type SendIdentityVerificationError struct {
	union json.RawMessage
}

// SendIdentityVerificationResponse     
type SendIdentityVerificationResponse = map[string]interface{}

// SendToNtsB2bTaxInvoiceError defines model for SendToNtsB2bTaxInvoiceError.
type SendToNtsB2bTaxInvoiceError struct {
	union json.RawMessage
}

// SendToNtsB2bTaxInvoiceResponse     
type SendToNtsB2bTaxInvoiceResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// SeparatedAddress   
//
//         .
//           .
type SeparatedAddress struct {
	AddressLine1 string  `json:"addressLine1"`
	AddressLine2 string  `json:"addressLine2"`
	City         *string `json:"city,omitempty"`

	// Country 
	Country  *Country `json:"country,omitempty"`
	OneLine  string   `json:"oneLine"`
	Province *string  `json:"province,omitempty"`
	Type     string   `json:"type"`
}

// SeparatedAddressInput     
type SeparatedAddressInput struct {
	AddressLine1 string  `json:"addressLine1"`
	AddressLine2 string  `json:"addressLine2"`
	City         *string `json:"city,omitempty"`

	// Country 
	Country  *Country `json:"country,omitempty"`
	Province *string  `json:"province,omitempty"`
}

// SettlementAmountType defines model for SettlementAmountType.
type SettlementAmountType string

// SortOrder  
type SortOrder string

// StartedPaymentSchedule   
type StartedPaymentSchedule struct {
	BillingKey string    `json:"billingKey"`
	CreatedAt  time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	StartedAt         time.Time         `json:"startedAt"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// SucceededPaymentCancellation   
type SucceededPaymentCancellation struct {
	CancelledAt           *time.Time `json:"cancelledAt,omitempty"`
	EasyPayDiscountAmount *int64     `json:"easyPayDiscountAmount,omitempty"`
	Id                    string     `json:"id"`
	PgCancellationId      *string    `json:"pgCancellationId,omitempty"`
	Reason                string     `json:"reason"`
	ReceiptUrl            *string    `json:"receiptUrl,omitempty"`
	RequestedAt           time.Time  `json:"requestedAt"`
	Status                string     `json:"status"`
	TaxFreeAmount         int64      `json:"taxFreeAmount"`
	TotalAmount           int64      `json:"totalAmount"`
	Trigger               *Trigger   `json:"trigger,omitempty"`
	VatAmount             int64      `json:"vatAmount"`
}

// SucceededPaymentSchedule   
type SucceededPaymentSchedule struct {
	BillingKey  string    `json:"billingKey"`
	CompletedAt time.Time `json:"completedAt"`
	CreatedAt   time.Time `json:"createdAt"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData string   `json:"customData"`

	// Customer  
	Customer          Customer          `json:"customer"`
	Id                string            `json:"id"`
	InstallmentMonth  *int32            `json:"installmentMonth,omitempty"`
	IsCulturalExpense bool              `json:"isCulturalExpense"`
	IsEscrow          bool              `json:"isEscrow"`
	MerchantId        string            `json:"merchantId"`
	NoticeUrls        *[]string         `json:"noticeUrls,omitempty"`
	OrderName         string            `json:"orderName"`
	PaymentId         string            `json:"paymentId"`
	Products          *[]PaymentProduct `json:"products,omitempty"`
	StartedAt         time.Time         `json:"startedAt"`
	Status            string            `json:"status"`
	StoreId           string            `json:"storeId"`
	TaxFreeAmount     *int64            `json:"taxFreeAmount,omitempty"`
	TimeToPay         time.Time         `json:"timeToPay"`
	TotalAmount       int64             `json:"totalAmount"`
	VatAmount         *int64            `json:"vatAmount,omitempty"`
}

// SumOfPartsExceedsCancelAmountError           
type SumOfPartsExceedsCancelAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// SumOfPartsExceedsTotalAmountError           
type SumOfPartsExceedsTotalAmountError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// TaxInvoicesSheetField    
type TaxInvoicesSheetField string

// TransferParameters defines model for TransferParameters.
type TransferParameters map[string]PlatformSettlementParameterValue

// Trigger defines model for Trigger.
type Trigger string

// Type defines model for Type.
type Type string

// UnauthorizedError     
type UnauthorizedError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// UpdateB2bTaxInvoiceDraftBody    
type UpdateB2bTaxInvoiceDraftBody struct {
	// Brn taxInvoiceKeyType TAX_INVOICE_ID    .
	Brn  *string `json:"brn,omitempty"`
	Memo *string `json:"memo,omitempty"`

	// TaxInvoice    
	TaxInvoice    B2bTaxInvoiceInput `json:"taxInvoice"`
	TaxInvoiceKey string             `json:"taxInvoiceKey"`

	// TaxInvoiceKeyType   
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `json:"taxInvoiceKeyType,omitempty"`
}

// UpdateB2bTaxInvoiceDraftError defines model for UpdateB2bTaxInvoiceDraftError.
type UpdateB2bTaxInvoiceDraftError struct {
	union json.RawMessage
}

// UpdateB2bTaxInvoiceDraftResponse    
type UpdateB2bTaxInvoiceDraftResponse struct {
	// TaxInvoice 
	TaxInvoice B2bTaxInvoice `json:"taxInvoice"`
}

// UpdatePlatformAdditionalFeePolicyBody       
//
//      .
type UpdatePlatformAdditionalFeePolicyBody struct {
	// Fee       
	//
	//      `fixedRate` ,      `fixedAmount`    .
	//         .
	Fee  *PlatformFeeInput `json:"fee,omitempty"`
	Memo *string           `json:"memo,omitempty"`
	Name *string           `json:"name,omitempty"`

	// VatPayer   
	//
	//    ,      .
	VatPayer *PlatformPayer `json:"vatPayer,omitempty"`
}

// UpdatePlatformAdditionalFeePolicyError defines model for UpdatePlatformAdditionalFeePolicyError.
type UpdatePlatformAdditionalFeePolicyError struct {
	union json.RawMessage
}

// UpdatePlatformAdditionalFeePolicyResponse      
type UpdatePlatformAdditionalFeePolicyResponse struct {
	// AdditionalFeePolicy   
	//
	//           .     ,  ,    .
	AdditionalFeePolicy PlatformAdditionalFeePolicy `json:"additionalFeePolicy"`
}

// UpdatePlatformContractBody     .      .
//
//      .
type UpdatePlatformContractBody struct {
	Memo *string `json:"memo,omitempty"`
	Name *string `json:"name,omitempty"`

	// PlatformFee       
	//
	//      `fixedRate` ,      `fixedAmount`    .
	//         .
	PlatformFee *PlatformFeeInput `json:"platformFee,omitempty"`

	// PlatformFeeVatPayer   
	//
	//    ,      .
	PlatformFeeVatPayer *PlatformPayer `json:"platformFeeVatPayer,omitempty"`

	// SettlementCycle     
	SettlementCycle          *PlatformSettlementCycleInput `json:"settlementCycle,omitempty"`
	SubtractPaymentVatAmount *bool                         `json:"subtractPaymentVatAmount,omitempty"`
}

// UpdatePlatformContractError defines model for UpdatePlatformContractError.
type UpdatePlatformContractError struct {
	union json.RawMessage
}

// UpdatePlatformContractResponse     
type UpdatePlatformContractResponse struct {
	// Contract 
	//
	//           .
	//             .
	Contract PlatformContract `json:"contract"`
}

// UpdatePlatformDiscountSharePolicyBody       
//
//      .
type UpdatePlatformDiscountSharePolicyBody struct {
	Memo *string `json:"memo,omitempty"`
	Name *string `json:"name,omitempty"`

	// PartnerShareRate         (10^-5)    ,    ` * partnerShareRate * 10^5`  .
	PartnerShareRate *int32 `json:"partnerShareRate,omitempty"`
}

// UpdatePlatformDiscountSharePolicyError defines model for UpdatePlatformDiscountSharePolicyError.
type UpdatePlatformDiscountSharePolicyError struct {
	union json.RawMessage
}

// UpdatePlatformDiscountSharePolicyResponse      
type UpdatePlatformDiscountSharePolicyResponse struct {
	// DiscountSharePolicy   
	//
	//           ,         .
	//     ,    .
	DiscountSharePolicy PlatformDiscountSharePolicy `json:"discountSharePolicy"`
}

// UpdatePlatformPartnerBody     
//
//      .
type UpdatePlatformPartnerBody struct {
	// Account      
	Account *UpdatePlatformPartnerBodyAccount `json:"account,omitempty"`

	// Contact     
	Contact           *UpdatePlatformPartnerBodyContact `json:"contact,omitempty"`
	DefaultContractId *string                           `json:"defaultContractId,omitempty"`
	Memo              *string                           `json:"memo,omitempty"`
	Name              *string                           `json:"name,omitempty"`
	Tags              *[]string                         `json:"tags,omitempty"`

	// Type      
	//
	//     .
	//       ,    .
	Type                  *UpdatePlatformPartnerBodyType `json:"type,omitempty"`
	UserDefinedProperties *PlatformProperties            `json:"userDefinedProperties,omitempty"`
}

// UpdatePlatformPartnerBodyAccount      
type UpdatePlatformPartnerBodyAccount struct {
	AccountVerificationId *string `json:"accountVerificationId,omitempty"`

	// Bank 
	Bank Bank `json:"bank"`

	// Currency  
	Currency Currency `json:"currency"`
	Holder   string   `json:"holder"`
	Number   string   `json:"number"`
}

// UpdatePlatformPartnerBodyContact     
type UpdatePlatformPartnerBodyContact struct {
	Email       *string `json:"email,omitempty"`
	Name        *string `json:"name,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

// UpdatePlatformPartnerBodyType      
//
//     .
//       ,    .
type UpdatePlatformPartnerBodyType struct {
	Business    *UpdatePlatformPartnerBodyTypeBusiness    `json:"business,omitempty"`
	NonWhtPayer *UpdatePlatformPartnerBodyTypeNonWhtPayer `json:"nonWhtPayer,omitempty"`
	WhtPayer    *UpdatePlatformPartnerBodyTypeWhtPayer    `json:"whtPayer,omitempty"`
}

// UpdatePlatformPartnerBodyTypeBusiness defines model for UpdatePlatformPartnerBodyTypeBusiness.
type UpdatePlatformPartnerBodyTypeBusiness struct {
	BusinessClass              *string `json:"businessClass,omitempty"`
	BusinessRegistrationNumber *string `json:"businessRegistrationNumber,omitempty"`
	BusinessType               *string `json:"businessType,omitempty"`
	CompanyAddress             *string `json:"companyAddress,omitempty"`
	CompanyName                *string `json:"companyName,omitempty"`
	CompanyVerificationId      *string `json:"companyVerificationId,omitempty"`
	RepresentativeName         *string `json:"representativeName,omitempty"`

	// TaxationType    
	TaxationType *PlatformPartnerTaxationType `json:"taxationType,omitempty"`
}

// UpdatePlatformPartnerBodyTypeNonWhtPayer defines model for UpdatePlatformPartnerBodyTypeNonWhtPayer.
type UpdatePlatformPartnerBodyTypeNonWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// UpdatePlatformPartnerBodyTypeWhtPayer defines model for UpdatePlatformPartnerBodyTypeWhtPayer.
type UpdatePlatformPartnerBodyTypeWhtPayer struct {
	// Birthdate   , `yyyy-MM-dd`  .
	Birthdate *openapi_types.Date `json:"birthdate,omitempty"`
}

// UpdatePlatformPartnerError defines model for UpdatePlatformPartnerError.
type UpdatePlatformPartnerError struct {
	union json.RawMessage
}

// UpdatePlatformPartnerResponse    
type UpdatePlatformPartnerResponse struct {
	// Partner 
	//
	//     .
	//    ,         .
	Partner PlatformPartner `json:"partner"`
}

// UpdatePlatformSettingBody      
type UpdatePlatformSettingBody struct {
	AdjustSettlementDateAfterHolidayIfEarlier *bool                 `json:"adjustSettlementDateAfterHolidayIfEarlier,omitempty"`
	DeductWht                                 *bool                 `json:"deductWht,omitempty"`
	DefaultDepositMemo                        *string               `json:"defaultDepositMemo,omitempty"`
	DefaultWithdrawalMemo                     *string               `json:"defaultWithdrawalMemo,omitempty"`
	SettlementAmountType                      *SettlementAmountType `json:"settlementAmountType,omitempty"`
	SupportsMultipleOrderTransfersPerPartner  *bool                 `json:"supportsMultipleOrderTransfersPerPartner,omitempty"`
}

// UpdatePlatformSettingError defines model for UpdatePlatformSettingError.
type UpdatePlatformSettingError struct {
	union json.RawMessage
}

// UpdatePlatformSettingResponse    
type UpdatePlatformSettingResponse struct {
	// Setting  
	Setting PlatformSetting `json:"setting"`
}

// VerifiedIdentityVerification   
type VerifiedIdentityVerification struct {
	// Channel (,  )   
	Channel         *SelectedChannel `json:"channel,omitempty"`
	CustomData      *string          `json:"customData,omitempty"`
	Id              string           `json:"id"`
	PgRawResponse   string           `json:"pgRawResponse"`
	PgTxId          string           `json:"pgTxId"`
	RequestedAt     time.Time        `json:"requestedAt"`
	Status          string           `json:"status"`
	StatusChangedAt time.Time        `json:"statusChangedAt"`
	UpdatedAt       time.Time        `json:"updatedAt"`
	VerifiedAt      time.Time        `json:"verifiedAt"`

	// VerifiedCustomer   
	VerifiedCustomer IdentityVerificationVerifiedCustomer `json:"verifiedCustomer"`

	// Version  
	Version PortOneVersion `json:"version"`
}

// VirtualAccountIssuedPayment     
type VirtualAccountIssuedPayment struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow            *PaymentEscrow `json:"escrow,omitempty"`
	Id                string         `json:"id"`
	IsCulturalExpense *bool          `json:"isCulturalExpense,omitempty"`
	MerchantId        string         `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`

	// TransactionId V1    imp_uid .
	TransactionId string    `json:"transactionId"`
	UpdatedAt     time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// VirtualAccountIssuedPaymentTransaction     
type VirtualAccountIssuedPaymentTransaction struct {
	// Amount    
	Amount PaymentAmount `json:"amount"`

	// BillingKey    
	BillingKey *string `json:"billingKey,omitempty"`

	// Channel (,  )   
	Channel SelectedChannel `json:"channel"`

	// ChannelGroup   
	ChannelGroup *ChannelGroupSummary `json:"channelGroup,omitempty"`

	// Country 
	Country *Country `json:"country,omitempty"`

	// Currency  
	Currency   Currency `json:"currency"`
	CustomData *string  `json:"customData,omitempty"`

	// Customer  
	Customer Customer `json:"customer"`

	// Escrow  
	//
	// V1     REGISTERED  .
	Escrow *PaymentEscrow `json:"escrow,omitempty"`

	// Id V1    imp_uid .
	Id                string `json:"id"`
	IsCulturalExpense *bool  `json:"isCulturalExpense,omitempty"`
	MerchantId        string `json:"merchantId"`

	// Method  
	Method       *PaymentMethod    `json:"method,omitempty"`
	OrderName    string            `json:"orderName"`
	PaymentId    string            `json:"paymentId"`
	PgTxId       *string           `json:"pgTxId,omitempty"`
	ProductCount *int32            `json:"productCount,omitempty"`
	Products     *[]PaymentProduct `json:"products,omitempty"`
	PromotionId  *string           `json:"promotionId,omitempty"`
	RequestedAt  time.Time         `json:"requestedAt"`

	// ScheduleId     
	ScheduleId      *string   `json:"scheduleId,omitempty"`
	Status          string    `json:"status"`
	StatusChangedAt time.Time `json:"statusChangedAt"`
	StoreId         string    `json:"storeId"`
	UpdatedAt       time.Time `json:"updatedAt"`

	// Version  
	Version  PortOneVersion    `json:"version"`
	Webhooks *[]PaymentWebhook `json:"webhooks,omitempty"`
}

// WebhookNotFoundError     
type WebhookNotFoundError struct {
	Message *string `json:"message,omitempty"`
	Type    string  `json:"type"`
}

// RequestB2bTaxInvoiceError defines model for requestB2bTaxInvoiceError.
type RequestB2bTaxInvoiceError struct {
	union json.RawMessage
}

// GetB2bBulkTaxInvoiceParams defines parameters for GetB2bBulkTaxInvoice.
type GetB2bBulkTaxInvoiceParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CreateB2bFileUploadUrlParams defines parameters for CreateB2bFileUploadUrl.
type CreateB2bFileUploadUrlParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoicesParams defines parameters for GetB2bTaxInvoices.
type GetB2bTaxInvoicesParams struct {
	RequestBody *GetB2bTaxInvoicesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// DownloadB2bTaxInvoicesSheetParams defines parameters for DownloadB2bTaxInvoicesSheet.
type DownloadB2bTaxInvoicesSheetParams struct {
	RequestBody *DownloadB2bTaxInvoicesSheetBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// DraftB2bTaxInvoiceParams defines parameters for DraftB2bTaxInvoice.
type DraftB2bTaxInvoiceParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdateB2bTaxInvoiceDraftParams defines parameters for UpdateB2bTaxInvoiceDraft.
type UpdateB2bTaxInvoiceDraftParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// IssueB2bTaxInvoiceImmediatelyParams defines parameters for IssueB2bTaxInvoiceImmediately.
type IssueB2bTaxInvoiceImmediatelyParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RequestB2bTaxInvoiceReverseIssuanceParams defines parameters for RequestB2bTaxInvoiceReverseIssuance.
type RequestB2bTaxInvoiceReverseIssuanceParams struct {
	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// DeleteB2bTaxInvoiceParams defines parameters for DeleteB2bTaxInvoice.
type DeleteB2bTaxInvoiceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoiceParams defines parameters for GetB2bTaxInvoice.
type GetB2bTaxInvoiceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// AttachB2bTaxInvoiceFileParams defines parameters for AttachB2bTaxInvoiceFile.
type AttachB2bTaxInvoiceFileParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoiceAttachmentsParams defines parameters for GetB2bTaxInvoiceAttachments.
type GetB2bTaxInvoiceAttachmentsParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// DeleteB2bTaxInvoiceAttachmentParams defines parameters for DeleteB2bTaxInvoiceAttachment.
type DeleteB2bTaxInvoiceAttachmentParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelB2bTaxInvoiceIssuanceParams defines parameters for CancelB2bTaxInvoiceIssuance.
type CancelB2bTaxInvoiceIssuanceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelB2bTaxInvoiceRequestParams defines parameters for CancelB2bTaxInvoiceRequest.
type CancelB2bTaxInvoiceRequestParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// IssueB2bTaxInvoiceParams defines parameters for IssueB2bTaxInvoice.
type IssueB2bTaxInvoiceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoicePdfDownloadUrlParams defines parameters for GetB2bTaxInvoicePdfDownloadUrl.
type GetB2bTaxInvoicePdfDownloadUrlParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoicePopupUrlParams defines parameters for GetB2bTaxInvoicePopupUrl.
type GetB2bTaxInvoicePopupUrlParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// IncludeMenu   
	//
	//  URL     .   true.
	IncludeMenu *bool `form:"includeMenu,omitempty" json:"includeMenu,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bTaxInvoicePrintUrlParams defines parameters for GetB2bTaxInvoicePrintUrl.
type GetB2bTaxInvoicePrintUrlParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RefuseB2bTaxInvoiceRequestParams defines parameters for RefuseB2bTaxInvoiceRequest.
type RefuseB2bTaxInvoiceRequestParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RequestB2bTaxInvoiceParams defines parameters for RequestB2bTaxInvoice.
type RequestB2bTaxInvoiceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// SendToNtsB2bTaxInvoiceParams defines parameters for SendToNtsB2bTaxInvoice.
type SendToNtsB2bTaxInvoiceParams struct {
	// Brn 
	Brn *string `form:"brn,omitempty" json:"brn,omitempty"`

	// TaxInvoiceKeyType   
	//
	// query    .   TAX_INVOICE_ID SUPPLIER, RECIPIENT, TAX_INVOICE_ID .
	TaxInvoiceKeyType *B2bTaxInvoiceKeyType `form:"taxInvoiceKeyType,omitempty" json:"taxInvoiceKeyType,omitempty"`

	// Test   
	//
	// true    , false        .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetBillingKeyInfosParams defines parameters for GetBillingKeyInfos.
type GetBillingKeyInfosParams struct {
	RequestBody *GetBillingKeyInfosBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// DeleteBillingKeyParams defines parameters for DeleteBillingKey.
type DeleteBillingKeyParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`

	// Reason 
	//
	// :   .  .
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Requester  
	//
	// :    .  .
	Requester *BillingKeyDeleteRequester `form:"requester,omitempty" json:"requester,omitempty"`
}

// GetBillingKeyInfoParams defines parameters for GetBillingKeyInfo.
type GetBillingKeyInfoParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetCashReceiptsParams defines parameters for GetCashReceipts.
type GetCashReceiptsParams struct {
	RequestBody *GetCashReceiptsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetIdentityVerificationsParams defines parameters for GetIdentityVerifications.
type GetIdentityVerificationsParams struct {
	RequestBody *GetIdentityVerificationsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetIdentityVerificationParams defines parameters for GetIdentityVerification.
type GetIdentityVerificationParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// ResendIdentityVerificationParams defines parameters for ResendIdentityVerification.
type ResendIdentityVerificationParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetKakaopayPaymentOrderParams defines parameters for GetKakaopayPaymentOrder.
type GetKakaopayPaymentOrderParams struct {
	// PgTxId    (tid)
	PgTxId string `form:"pgTxId" json:"pgTxId"`

	// ChannelKey  
	ChannelKey string `form:"channelKey" json:"channelKey"`
}

// GetAllPaymentEventsByCursorParams defines parameters for GetAllPaymentEventsByCursor.
type GetAllPaymentEventsByCursorParams struct {
	RequestBody *GetAllPaymentEventsByCursorBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// RevokePaymentSchedulesParams defines parameters for RevokePaymentSchedules.
type RevokePaymentSchedulesParams struct {
	RequestBody *RevokePaymentSchedulesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPaymentSchedulesParams defines parameters for GetPaymentSchedules.
type GetPaymentSchedulesParams struct {
	RequestBody *GetPaymentSchedulesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPaymentScheduleParams defines parameters for GetPaymentSchedule.
type GetPaymentScheduleParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetPaymentsParams defines parameters for GetPayments.
type GetPaymentsParams struct {
	RequestBody *GetPaymentsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetAllPaymentsByCursorParams defines parameters for GetAllPaymentsByCursor.
type GetAllPaymentsByCursorParams struct {
	RequestBody *GetAllPaymentsByCursorBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPaymentParams defines parameters for GetPayment.
type GetPaymentParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetCashReceiptByPaymentIdParams defines parameters for GetCashReceiptByPaymentId.
type GetCashReceiptByPaymentIdParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// CancelCashReceiptByPaymentIdParams defines parameters for CancelCashReceiptByPaymentId.
type CancelCashReceiptByPaymentIdParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetPaymentTransactionsParams defines parameters for GetPaymentTransactions.
type GetPaymentTransactionsParams struct {
	// StoreId  
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// CloseVirtualAccountParams defines parameters for CloseVirtualAccount.
type CloseVirtualAccountParams struct {
	// StoreId  
	//
	//       ,      .
	StoreId *string `form:"storeId,omitempty" json:"storeId,omitempty"`
}

// GetPlatformAccountTransfersParams defines parameters for GetPlatformAccountTransfers.
type GetPlatformAccountTransfersParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                     `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetAccountTransfersBody1 `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPlatformAdditionalFeePoliciesParams defines parameters for GetPlatformAdditionalFeePolicies.
type GetPlatformAdditionalFeePoliciesParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                                 `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformAdditionalFeePoliciesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// CreatePlatformAdditionalFeePolicyParams defines parameters for CreatePlatformAdditionalFeePolicy.
type CreatePlatformAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformAdditionalFeePolicyParams defines parameters for GetPlatformAdditionalFeePolicy.
type GetPlatformAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdatePlatformAdditionalFeePolicyParams defines parameters for UpdatePlatformAdditionalFeePolicy.
type UpdatePlatformAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ArchivePlatformAdditionalFeePolicyParams defines parameters for ArchivePlatformAdditionalFeePolicy.
type ArchivePlatformAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RecoverPlatformAdditionalFeePolicyParams defines parameters for RecoverPlatformAdditionalFeePolicy.
type RecoverPlatformAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelPlatformAdditionalFeePolicyScheduleParams defines parameters for CancelPlatformAdditionalFeePolicySchedule.
type CancelPlatformAdditionalFeePolicyScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformAdditionalFeePolicyScheduleParams defines parameters for GetPlatformAdditionalFeePolicySchedule.
type GetPlatformAdditionalFeePolicyScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ScheduleAdditionalFeePolicyParams defines parameters for ScheduleAdditionalFeePolicy.
type ScheduleAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RescheduleAdditionalFeePolicyParams defines parameters for RescheduleAdditionalFeePolicy.
type RescheduleAdditionalFeePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformAccountHolderParams defines parameters for GetPlatformAccountHolder.
type GetPlatformAccountHolderParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`

	// Birthdate 
	//
	//       . birthdate businessRegistrationNumber    .
	Birthdate *string `form:"birthdate,omitempty" json:"birthdate,omitempty"`

	// BusinessRegistrationNumber 
	//
	//       . birthdate businessRegistrationNumber    .
	BusinessRegistrationNumber *string `form:"businessRegistrationNumber,omitempty" json:"businessRegistrationNumber,omitempty"`
}

// GetPlatformBulkAccountTransfersParams defines parameters for GetPlatformBulkAccountTransfers.
type GetPlatformBulkAccountTransfersParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                                `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformBulkAccountTransfersBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPlatformBulkPayoutsParams defines parameters for GetPlatformBulkPayouts.
type GetPlatformBulkPayoutsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                       `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformBulkPayoutsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPlatformCompanyStateParams defines parameters for GetPlatformCompanyState.
type GetPlatformCompanyStateParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformContractsParams defines parameters for GetPlatformContracts.
type GetPlatformContractsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                     `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformContractsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// CreatePlatformContractParams defines parameters for CreatePlatformContract.
type CreatePlatformContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformContractParams defines parameters for GetPlatformContract.
type GetPlatformContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdatePlatformContractParams defines parameters for UpdatePlatformContract.
type UpdatePlatformContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ArchivePlatformContractParams defines parameters for ArchivePlatformContract.
type ArchivePlatformContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RecoverPlatformContractParams defines parameters for RecoverPlatformContract.
type RecoverPlatformContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelPlatformContractScheduleParams defines parameters for CancelPlatformContractSchedule.
type CancelPlatformContractScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformContractScheduleParams defines parameters for GetPlatformContractSchedule.
type GetPlatformContractScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ScheduleContractParams defines parameters for ScheduleContract.
type ScheduleContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RescheduleContractParams defines parameters for RescheduleContract.
type RescheduleContractParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformDiscountSharePoliciesParams defines parameters for GetPlatformDiscountSharePolicies.
type GetPlatformDiscountSharePoliciesParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                                 `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformDiscountSharePoliciesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// CreatePlatformDiscountSharePolicyParams defines parameters for CreatePlatformDiscountSharePolicy.
type CreatePlatformDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformDiscountSharePolicyParams defines parameters for GetPlatformDiscountSharePolicy.
type GetPlatformDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdatePlatformDiscountSharePolicyParams defines parameters for UpdatePlatformDiscountSharePolicy.
type UpdatePlatformDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ArchivePlatformDiscountSharePolicyParams defines parameters for ArchivePlatformDiscountSharePolicy.
type ArchivePlatformDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RecoverPlatformDiscountSharePolicyParams defines parameters for RecoverPlatformDiscountSharePolicy.
type RecoverPlatformDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelPlatformDiscountSharePolicyScheduleParams defines parameters for CancelPlatformDiscountSharePolicySchedule.
type CancelPlatformDiscountSharePolicyScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformDiscountSharePolicyScheduleParams defines parameters for GetPlatformDiscountSharePolicySchedule.
type GetPlatformDiscountSharePolicyScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ScheduleDiscountSharePolicyParams defines parameters for ScheduleDiscountSharePolicy.
type ScheduleDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RescheduleDiscountSharePolicyParams defines parameters for RescheduleDiscountSharePolicy.
type RescheduleDiscountSharePolicyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformDiscountSharePolicyFilterOptionsParams defines parameters for GetPlatformDiscountSharePolicyFilterOptions.
type GetPlatformDiscountSharePolicyFilterOptionsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`

	// IsArchived   
	//
	// true       , false        .  false .
	IsArchived *bool `form:"isArchived,omitempty" json:"isArchived,omitempty"`
}

// GetPlatformPartnerFilterOptionsParams defines parameters for GetPlatformPartnerFilterOptions.
type GetPlatformPartnerFilterOptionsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`

	// IsArchived   
	//
	// true      , false       .  false .
	IsArchived *bool `form:"isArchived,omitempty" json:"isArchived,omitempty"`
}

// GetPlatformPartnerSettlementsParams defines parameters for GetPlatformPartnerSettlements.
type GetPlatformPartnerSettlementsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                              `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformPartnerSettlementsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPlatformPartnersParams defines parameters for GetPlatformPartners.
type GetPlatformPartnersParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                    `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformPartnersBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// CreatePlatformPartnerParams defines parameters for CreatePlatformPartner.
type CreatePlatformPartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CreatePlatformPartnersParams defines parameters for CreatePlatformPartners.
type CreatePlatformPartnersParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ConnectBulkPartnerMemberCompanyParams defines parameters for ConnectBulkPartnerMemberCompany.
type ConnectBulkPartnerMemberCompanyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ConnectPartnerMemberCompanyParams defines parameters for ConnectPartnerMemberCompany.
type ConnectPartnerMemberCompanyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// DisconnectBulkPartnerMemberCompanyParams defines parameters for DisconnectBulkPartnerMemberCompany.
type DisconnectBulkPartnerMemberCompanyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// DisconnectPartnerMemberCompanyParams defines parameters for DisconnectPartnerMemberCompany.
type DisconnectPartnerMemberCompanyParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// SchedulePlatformPartnersParams defines parameters for SchedulePlatformPartners.
type SchedulePlatformPartnersParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformPartnerParams defines parameters for GetPlatformPartner.
type GetPlatformPartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdatePlatformPartnerParams defines parameters for UpdatePlatformPartner.
type UpdatePlatformPartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ArchivePlatformPartnerParams defines parameters for ArchivePlatformPartner.
type ArchivePlatformPartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// RecoverPlatformPartnerParams defines parameters for RecoverPlatformPartner.
type RecoverPlatformPartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CancelPlatformPartnerScheduleParams defines parameters for CancelPlatformPartnerSchedule.
type CancelPlatformPartnerScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformPartnerScheduleParams defines parameters for GetPlatformPartnerSchedule.
type GetPlatformPartnerScheduleParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// SchedulePartnerParams defines parameters for SchedulePartner.
type SchedulePartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// ReschedulePartnerParams defines parameters for ReschedulePartner.
type ReschedulePartnerParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformPayoutsParams defines parameters for GetPlatformPayouts.
type GetPlatformPayoutsParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                   `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformPayoutsBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// GetPlatformSettingParams defines parameters for GetPlatformSetting.
type GetPlatformSettingParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// UpdatePlatformSettingParams defines parameters for UpdatePlatformSetting.
type UpdatePlatformSettingParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformTransferSummariesParams defines parameters for GetPlatformTransferSummaries.
type GetPlatformTransferSummariesParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                             `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *GetPlatformTransferSummariesBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// DownloadPlatformTransferSheetParams defines parameters for DownloadPlatformTransferSheet.
type DownloadPlatformTransferSheetParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test        *bool                              `form:"test,omitempty" json:"test,omitempty"`
	RequestBody *DownloadPlatformTransferSheetBody `form:"requestBody,omitempty" json:"requestBody,omitempty"`
}

// CreatePlatformManualTransferParams defines parameters for CreatePlatformManualTransfer.
type CreatePlatformManualTransferParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CreatePlatformOrderTransferParams defines parameters for CreatePlatformOrderTransfer.
type CreatePlatformOrderTransferParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// CreatePlatformOrderCancelTransferParams defines parameters for CreatePlatformOrderCancelTransfer.
type CreatePlatformOrderCancelTransferParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// DeletePlatformTransferParams defines parameters for DeletePlatformTransfer.
type DeletePlatformTransferParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetPlatformTransferParams defines parameters for GetPlatformTransfer.
type GetPlatformTransferParams struct {
	// Test   
	//
	//    . true    . Request Body isForTest   ,    Query Parameter test  , Request Body isForTest . Query Parameter test Request Body isForTest      false .
	Test *bool `form:"test,omitempty" json:"test,omitempty"`
}

// GetB2bBusinessInfosJSONRequestBody defines body for GetB2bBusinessInfos for application/json ContentType.
type GetB2bBusinessInfosJSONRequestBody = GetB2bBusinessInfosBody

// CreateB2bFileUploadUrlJSONRequestBody defines body for CreateB2bFileUploadUrl for application/json ContentType.
type CreateB2bFileUploadUrlJSONRequestBody = CreateB2bFileUploadUrlBody

// GetB2bTaxInvoicesJSONRequestBody defines body for GetB2bTaxInvoices for application/json ContentType.
type GetB2bTaxInvoicesJSONRequestBody = GetB2bTaxInvoicesBody

// DownloadB2bTaxInvoicesSheetJSONRequestBody defines body for DownloadB2bTaxInvoicesSheet for application/json ContentType.
type DownloadB2bTaxInvoicesSheetJSONRequestBody = DownloadB2bTaxInvoicesSheetBody

// DraftB2bTaxInvoiceJSONRequestBody defines body for DraftB2bTaxInvoice for application/json ContentType.
type DraftB2bTaxInvoiceJSONRequestBody = DraftB2bTaxInvoiceBody

// UpdateB2bTaxInvoiceDraftJSONRequestBody defines body for UpdateB2bTaxInvoiceDraft for application/json ContentType.
type UpdateB2bTaxInvoiceDraftJSONRequestBody = UpdateB2bTaxInvoiceDraftBody

// IssueB2bTaxInvoiceImmediatelyJSONRequestBody defines body for IssueB2bTaxInvoiceImmediately for application/json ContentType.
type IssueB2bTaxInvoiceImmediatelyJSONRequestBody = IssueB2bTaxInvoiceImmediatelyBody

// RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody defines body for RequestB2bTaxInvoiceReverseIssuance for application/json ContentType.
type RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody = RequestB2bTaxInvoiceReverseIssuanceBody

// AttachB2bTaxInvoiceFileJSONRequestBody defines body for AttachB2bTaxInvoiceFile for application/json ContentType.
type AttachB2bTaxInvoiceFileJSONRequestBody = AttachB2bTaxInvoiceFileBody

// CancelB2bTaxInvoiceIssuanceJSONRequestBody defines body for CancelB2bTaxInvoiceIssuance for application/json ContentType.
type CancelB2bTaxInvoiceIssuanceJSONRequestBody = CancelB2bTaxInvoiceIssuanceBody

// CancelB2bTaxInvoiceRequestJSONRequestBody defines body for CancelB2bTaxInvoiceRequest for application/json ContentType.
type CancelB2bTaxInvoiceRequestJSONRequestBody = CancelB2bTaxInvoiceRequestBody

// IssueB2bTaxInvoiceJSONRequestBody defines body for IssueB2bTaxInvoice for application/json ContentType.
type IssueB2bTaxInvoiceJSONRequestBody = IssueB2bTaxInvoiceBody

// RefuseB2bTaxInvoiceRequestJSONRequestBody defines body for RefuseB2bTaxInvoiceRequest for application/json ContentType.
type RefuseB2bTaxInvoiceRequestJSONRequestBody = RefuseB2bTaxInvoiceRequestBody

// GetBillingKeyInfosJSONRequestBody defines body for GetBillingKeyInfos for application/json ContentType.
type GetBillingKeyInfosJSONRequestBody = GetBillingKeyInfosBody

// IssueBillingKeyJSONRequestBody defines body for IssueBillingKey for application/json ContentType.
type IssueBillingKeyJSONRequestBody = IssueBillingKeyBody

// ConfirmBillingKeyJSONRequestBody defines body for ConfirmBillingKey for application/json ContentType.
type ConfirmBillingKeyJSONRequestBody = ConfirmBillingKeyBody

// ConfirmBillingKeyIssueAndPayJSONRequestBody defines body for ConfirmBillingKeyIssueAndPay for application/json ContentType.
type ConfirmBillingKeyIssueAndPayJSONRequestBody = ConfirmBillingKeyIssueAndPayBody

// GetCashReceiptsJSONRequestBody defines body for GetCashReceipts for application/json ContentType.
type GetCashReceiptsJSONRequestBody = GetCashReceiptsBody

// IssueCashReceiptJSONRequestBody defines body for IssueCashReceipt for application/json ContentType.
type IssueCashReceiptJSONRequestBody = IssueCashReceiptBody

// GetIdentityVerificationsJSONRequestBody defines body for GetIdentityVerifications for application/json ContentType.
type GetIdentityVerificationsJSONRequestBody = GetIdentityVerificationsBody

// ConfirmIdentityVerificationJSONRequestBody defines body for ConfirmIdentityVerification for application/json ContentType.
type ConfirmIdentityVerificationJSONRequestBody = ConfirmIdentityVerificationBody

// SendIdentityVerificationJSONRequestBody defines body for SendIdentityVerification for application/json ContentType.
type SendIdentityVerificationJSONRequestBody = SendIdentityVerificationBody

// LoginViaApiSecretJSONRequestBody defines body for LoginViaApiSecret for application/json ContentType.
type LoginViaApiSecretJSONRequestBody = LoginViaApiSecretBody

// GetAllPaymentEventsByCursorJSONRequestBody defines body for GetAllPaymentEventsByCursor for application/json ContentType.
type GetAllPaymentEventsByCursorJSONRequestBody = GetAllPaymentEventsByCursorBody

// RevokePaymentSchedulesJSONRequestBody defines body for RevokePaymentSchedules for application/json ContentType.
type RevokePaymentSchedulesJSONRequestBody = RevokePaymentSchedulesBody

// GetPaymentSchedulesJSONRequestBody defines body for GetPaymentSchedules for application/json ContentType.
type GetPaymentSchedulesJSONRequestBody = GetPaymentSchedulesBody

// GetPaymentsJSONRequestBody defines body for GetPayments for application/json ContentType.
type GetPaymentsJSONRequestBody = GetPaymentsBody

// GetAllPaymentsByCursorJSONRequestBody defines body for GetAllPaymentsByCursor for application/json ContentType.
type GetAllPaymentsByCursorJSONRequestBody = GetAllPaymentsByCursorBody

// PayWithBillingKeyJSONRequestBody defines body for PayWithBillingKey for application/json ContentType.
type PayWithBillingKeyJSONRequestBody = BillingKeyPaymentInput

// CancelPaymentJSONRequestBody defines body for CancelPayment for application/json ContentType.
type CancelPaymentJSONRequestBody = CancelPaymentBody

// CapturePaymentJSONRequestBody defines body for CapturePayment for application/json ContentType.
type CapturePaymentJSONRequestBody = CapturePaymentBody

// ConfirmPaymentJSONRequestBody defines body for ConfirmPayment for application/json ContentType.
type ConfirmPaymentJSONRequestBody = ConfirmPaymentBody

// ConfirmEscrowJSONRequestBody defines body for ConfirmEscrow for application/json ContentType.
type ConfirmEscrowJSONRequestBody = ConfirmEscrowBody

// ModifyEscrowLogisticsJSONRequestBody defines body for ModifyEscrowLogistics for application/json ContentType.
type ModifyEscrowLogisticsJSONRequestBody = ModifyEscrowLogisticsBody

// ApplyEscrowLogisticsJSONRequestBody defines body for ApplyEscrowLogistics for application/json ContentType.
type ApplyEscrowLogisticsJSONRequestBody = RegisterEscrowLogisticsBody

// PayInstantlyJSONRequestBody defines body for PayInstantly for application/json ContentType.
type PayInstantlyJSONRequestBody = InstantPaymentInput

// PreRegisterPaymentJSONRequestBody defines body for PreRegisterPayment for application/json ContentType.
type PreRegisterPaymentJSONRequestBody = PreRegisterPaymentBody

// RegisterStoreReceiptJSONRequestBody defines body for RegisterStoreReceipt for application/json ContentType.
type RegisterStoreReceiptJSONRequestBody = RegisterStoreReceiptBody

// ResendWebhookJSONRequestBody defines body for ResendWebhook for application/json ContentType.
type ResendWebhookJSONRequestBody = ResendWebhookBody

// CreatePaymentScheduleJSONRequestBody defines body for CreatePaymentSchedule for application/json ContentType.
type CreatePaymentScheduleJSONRequestBody = CreatePaymentScheduleBody

// GetPlatformAccountTransfersJSONRequestBody defines body for GetPlatformAccountTransfers for application/json ContentType.
type GetPlatformAccountTransfersJSONRequestBody = GetAccountTransfersBody1

// GetPlatformAdditionalFeePoliciesJSONRequestBody defines body for GetPlatformAdditionalFeePolicies for application/json ContentType.
type GetPlatformAdditionalFeePoliciesJSONRequestBody = GetPlatformAdditionalFeePoliciesBody

// CreatePlatformAdditionalFeePolicyJSONRequestBody defines body for CreatePlatformAdditionalFeePolicy for application/json ContentType.
type CreatePlatformAdditionalFeePolicyJSONRequestBody = CreatePlatformAdditionalFeePolicyBody

// UpdatePlatformAdditionalFeePolicyJSONRequestBody defines body for UpdatePlatformAdditionalFeePolicy for application/json ContentType.
type UpdatePlatformAdditionalFeePolicyJSONRequestBody = UpdatePlatformAdditionalFeePolicyBody

// ScheduleAdditionalFeePolicyJSONRequestBody defines body for ScheduleAdditionalFeePolicy for application/json ContentType.
type ScheduleAdditionalFeePolicyJSONRequestBody = SchedulePlatformAdditionalFeePolicyBody

// RescheduleAdditionalFeePolicyJSONRequestBody defines body for RescheduleAdditionalFeePolicy for application/json ContentType.
type RescheduleAdditionalFeePolicyJSONRequestBody = ReschedulePlatformAdditionalFeePolicyBody

// GetPlatformBulkAccountTransfersJSONRequestBody defines body for GetPlatformBulkAccountTransfers for application/json ContentType.
type GetPlatformBulkAccountTransfersJSONRequestBody = GetPlatformBulkAccountTransfersBody

// GetPlatformBulkPayoutsJSONRequestBody defines body for GetPlatformBulkPayouts for application/json ContentType.
type GetPlatformBulkPayoutsJSONRequestBody = GetPlatformBulkPayoutsBody

// GetPlatformContractsJSONRequestBody defines body for GetPlatformContracts for application/json ContentType.
type GetPlatformContractsJSONRequestBody = GetPlatformContractsBody

// CreatePlatformContractJSONRequestBody defines body for CreatePlatformContract for application/json ContentType.
type CreatePlatformContractJSONRequestBody = CreatePlatformContractBody

// UpdatePlatformContractJSONRequestBody defines body for UpdatePlatformContract for application/json ContentType.
type UpdatePlatformContractJSONRequestBody = UpdatePlatformContractBody

// ScheduleContractJSONRequestBody defines body for ScheduleContract for application/json ContentType.
type ScheduleContractJSONRequestBody = SchedulePlatformContractBody

// RescheduleContractJSONRequestBody defines body for RescheduleContract for application/json ContentType.
type RescheduleContractJSONRequestBody = ReschedulePlatformContractBody

// GetPlatformDiscountSharePoliciesJSONRequestBody defines body for GetPlatformDiscountSharePolicies for application/json ContentType.
type GetPlatformDiscountSharePoliciesJSONRequestBody = GetPlatformDiscountSharePoliciesBody

// CreatePlatformDiscountSharePolicyJSONRequestBody defines body for CreatePlatformDiscountSharePolicy for application/json ContentType.
type CreatePlatformDiscountSharePolicyJSONRequestBody = CreatePlatformDiscountSharePolicyBody

// UpdatePlatformDiscountSharePolicyJSONRequestBody defines body for UpdatePlatformDiscountSharePolicy for application/json ContentType.
type UpdatePlatformDiscountSharePolicyJSONRequestBody = UpdatePlatformDiscountSharePolicyBody

// ScheduleDiscountSharePolicyJSONRequestBody defines body for ScheduleDiscountSharePolicy for application/json ContentType.
type ScheduleDiscountSharePolicyJSONRequestBody = SchedulePlatformDiscountSharePolicyBody

// RescheduleDiscountSharePolicyJSONRequestBody defines body for RescheduleDiscountSharePolicy for application/json ContentType.
type RescheduleDiscountSharePolicyJSONRequestBody = ReschedulePlatformDiscountSharePolicyBody

// GetPlatformPartnerSettlementsJSONRequestBody defines body for GetPlatformPartnerSettlements for application/json ContentType.
type GetPlatformPartnerSettlementsJSONRequestBody = GetPlatformPartnerSettlementsBody

// GetPlatformPartnersJSONRequestBody defines body for GetPlatformPartners for application/json ContentType.
type GetPlatformPartnersJSONRequestBody = GetPlatformPartnersBody

// CreatePlatformPartnerJSONRequestBody defines body for CreatePlatformPartner for application/json ContentType.
type CreatePlatformPartnerJSONRequestBody = CreatePlatformPartnerBody

// CreatePlatformPartnersJSONRequestBody defines body for CreatePlatformPartners for application/json ContentType.
type CreatePlatformPartnersJSONRequestBody = CreatePlatformPartnersBody

// ConnectBulkPartnerMemberCompanyJSONRequestBody defines body for ConnectBulkPartnerMemberCompany for application/json ContentType.
type ConnectBulkPartnerMemberCompanyJSONRequestBody = ConnectBulkPartnerMemberCompanyBody

// DisconnectBulkPartnerMemberCompanyJSONRequestBody defines body for DisconnectBulkPartnerMemberCompany for application/json ContentType.
type DisconnectBulkPartnerMemberCompanyJSONRequestBody = DisconnectBulkPartnerMemberCompanyBody

// SchedulePlatformPartnersJSONRequestBody defines body for SchedulePlatformPartners for application/json ContentType.
type SchedulePlatformPartnersJSONRequestBody = SchedulePlatformPartnersBody

// UpdatePlatformPartnerJSONRequestBody defines body for UpdatePlatformPartner for application/json ContentType.
type UpdatePlatformPartnerJSONRequestBody = UpdatePlatformPartnerBody

// SchedulePartnerJSONRequestBody defines body for SchedulePartner for application/json ContentType.
type SchedulePartnerJSONRequestBody = SchedulePlatformPartnerBody

// ReschedulePartnerJSONRequestBody defines body for ReschedulePartner for application/json ContentType.
type ReschedulePartnerJSONRequestBody = ReschedulePlatformPartnerBody

// GetPlatformPayoutsJSONRequestBody defines body for GetPlatformPayouts for application/json ContentType.
type GetPlatformPayoutsJSONRequestBody = GetPlatformPayoutsBody

// UpdatePlatformSettingJSONRequestBody defines body for UpdatePlatformSetting for application/json ContentType.
type UpdatePlatformSettingJSONRequestBody = UpdatePlatformSettingBody

// GetPlatformTransferSummariesJSONRequestBody defines body for GetPlatformTransferSummaries for application/json ContentType.
type GetPlatformTransferSummariesJSONRequestBody = GetPlatformTransferSummariesBody

// DownloadPlatformTransferSheetJSONRequestBody defines body for DownloadPlatformTransferSheet for application/json ContentType.
type DownloadPlatformTransferSheetJSONRequestBody = DownloadPlatformTransferSheetBody

// CreatePlatformManualTransferJSONRequestBody defines body for CreatePlatformManualTransfer for application/json ContentType.
type CreatePlatformManualTransferJSONRequestBody = CreatePlatformManualTransferBody

// CreatePlatformOrderTransferJSONRequestBody defines body for CreatePlatformOrderTransfer for application/json ContentType.
type CreatePlatformOrderTransferJSONRequestBody = CreatePlatformOrderTransferBody

// CreatePlatformOrderCancelTransferJSONRequestBody defines body for CreatePlatformOrderCancelTransfer for application/json ContentType.
type CreatePlatformOrderCancelTransferJSONRequestBody = CreatePlatformOrderCancelTransferBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody = RefreshTokenBody

// AsOneLineAddress returns the union data inside the Address as a OneLineAddress
func (t Address) AsOneLineAddress() (OneLineAddress, error) {
	var body OneLineAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOneLineAddress overwrites any union data inside the Address as the provided OneLineAddress
func (t *Address) FromOneLineAddress(v OneLineAddress) error {
	v.Type = "ONE_LINE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOneLineAddress performs a merge with any union data inside the Address, using the provided OneLineAddress
func (t *Address) MergeOneLineAddress(v OneLineAddress) error {
	v.Type = "ONE_LINE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSeparatedAddress returns the union data inside the Address as a SeparatedAddress
func (t Address) AsSeparatedAddress() (SeparatedAddress, error) {
	var body SeparatedAddress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSeparatedAddress overwrites any union data inside the Address as the provided SeparatedAddress
func (t *Address) FromSeparatedAddress(v SeparatedAddress) error {
	v.Type = "SEPARATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSeparatedAddress performs a merge with any union data inside the Address, using the provided SeparatedAddress
func (t *Address) MergeSeparatedAddress(v SeparatedAddress) error {
	v.Type = "SEPARATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Address) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Address) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ONE_LINE":
		return t.AsOneLineAddress()
	case "SEPARATED":
		return t.AsSeparatedAddress()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Address) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Address) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ApplyEscrowLogisticsError as a ForbiddenError
func (t ApplyEscrowLogisticsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ApplyEscrowLogisticsError as the provided ForbiddenError
func (t *ApplyEscrowLogisticsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided ForbiddenError
func (t *ApplyEscrowLogisticsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ApplyEscrowLogisticsError as a InvalidRequestError
func (t ApplyEscrowLogisticsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ApplyEscrowLogisticsError as the provided InvalidRequestError
func (t *ApplyEscrowLogisticsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided InvalidRequestError
func (t *ApplyEscrowLogisticsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the ApplyEscrowLogisticsError as a PaymentNotFoundError
func (t ApplyEscrowLogisticsError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the ApplyEscrowLogisticsError as the provided PaymentNotFoundError
func (t *ApplyEscrowLogisticsError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided PaymentNotFoundError
func (t *ApplyEscrowLogisticsError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the ApplyEscrowLogisticsError as a PaymentNotPaidError
func (t ApplyEscrowLogisticsError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the ApplyEscrowLogisticsError as the provided PaymentNotPaidError
func (t *ApplyEscrowLogisticsError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided PaymentNotPaidError
func (t *ApplyEscrowLogisticsError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ApplyEscrowLogisticsError as a PgProviderError
func (t ApplyEscrowLogisticsError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ApplyEscrowLogisticsError as the provided PgProviderError
func (t *ApplyEscrowLogisticsError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided PgProviderError
func (t *ApplyEscrowLogisticsError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ApplyEscrowLogisticsError as a UnauthorizedError
func (t ApplyEscrowLogisticsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ApplyEscrowLogisticsError as the provided UnauthorizedError
func (t *ApplyEscrowLogisticsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ApplyEscrowLogisticsError, using the provided UnauthorizedError
func (t *ApplyEscrowLogisticsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApplyEscrowLogisticsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ApplyEscrowLogisticsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ApplyEscrowLogisticsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApplyEscrowLogisticsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a ForbiddenError
func (t ArchivePlatformAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided ForbiddenError
func (t *ArchivePlatformAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided ForbiddenError
func (t *ArchivePlatformAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a InvalidRequestError
func (t ArchivePlatformAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided InvalidRequestError
func (t *ArchivePlatformAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *ArchivePlatformAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t ArchivePlatformAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *ArchivePlatformAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *ArchivePlatformAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCannotArchiveScheduledAdditionalFeePolicyError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a PlatformCannotArchiveScheduledAdditionalFeePolicyError
func (t ArchivePlatformAdditionalFeePolicyError) AsPlatformCannotArchiveScheduledAdditionalFeePolicyError() (PlatformCannotArchiveScheduledAdditionalFeePolicyError, error) {
	var body PlatformCannotArchiveScheduledAdditionalFeePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCannotArchiveScheduledAdditionalFeePolicyError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided PlatformCannotArchiveScheduledAdditionalFeePolicyError
func (t *ArchivePlatformAdditionalFeePolicyError) FromPlatformCannotArchiveScheduledAdditionalFeePolicyError(v PlatformCannotArchiveScheduledAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCannotArchiveScheduledAdditionalFeePolicyError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided PlatformCannotArchiveScheduledAdditionalFeePolicyError
func (t *ArchivePlatformAdditionalFeePolicyError) MergePlatformCannotArchiveScheduledAdditionalFeePolicyError(v PlatformCannotArchiveScheduledAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a PlatformNotEnabledError
func (t ArchivePlatformAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *ArchivePlatformAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *ArchivePlatformAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ArchivePlatformAdditionalFeePolicyError as a UnauthorizedError
func (t ArchivePlatformAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ArchivePlatformAdditionalFeePolicyError as the provided UnauthorizedError
func (t *ArchivePlatformAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ArchivePlatformAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *ArchivePlatformAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArchivePlatformAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ArchivePlatformAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_ADDITIONAL_FEE_POLICY":
		return t.AsPlatformCannotArchiveScheduledAdditionalFeePolicyError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ArchivePlatformAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArchivePlatformAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ArchivePlatformContractError as a ForbiddenError
func (t ArchivePlatformContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ArchivePlatformContractError as the provided ForbiddenError
func (t *ArchivePlatformContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ArchivePlatformContractError, using the provided ForbiddenError
func (t *ArchivePlatformContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ArchivePlatformContractError as a InvalidRequestError
func (t ArchivePlatformContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ArchivePlatformContractError as the provided InvalidRequestError
func (t *ArchivePlatformContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ArchivePlatformContractError, using the provided InvalidRequestError
func (t *ArchivePlatformContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCannotArchiveScheduledContractError returns the union data inside the ArchivePlatformContractError as a PlatformCannotArchiveScheduledContractError
func (t ArchivePlatformContractError) AsPlatformCannotArchiveScheduledContractError() (PlatformCannotArchiveScheduledContractError, error) {
	var body PlatformCannotArchiveScheduledContractError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCannotArchiveScheduledContractError overwrites any union data inside the ArchivePlatformContractError as the provided PlatformCannotArchiveScheduledContractError
func (t *ArchivePlatformContractError) FromPlatformCannotArchiveScheduledContractError(v PlatformCannotArchiveScheduledContractError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_CONTRACT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCannotArchiveScheduledContractError performs a merge with any union data inside the ArchivePlatformContractError, using the provided PlatformCannotArchiveScheduledContractError
func (t *ArchivePlatformContractError) MergePlatformCannotArchiveScheduledContractError(v PlatformCannotArchiveScheduledContractError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_CONTRACT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the ArchivePlatformContractError as a PlatformContractNotFoundError
func (t ArchivePlatformContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the ArchivePlatformContractError as the provided PlatformContractNotFoundError
func (t *ArchivePlatformContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the ArchivePlatformContractError, using the provided PlatformContractNotFoundError
func (t *ArchivePlatformContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ArchivePlatformContractError as a PlatformNotEnabledError
func (t ArchivePlatformContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ArchivePlatformContractError as the provided PlatformNotEnabledError
func (t *ArchivePlatformContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ArchivePlatformContractError, using the provided PlatformNotEnabledError
func (t *ArchivePlatformContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ArchivePlatformContractError as a UnauthorizedError
func (t ArchivePlatformContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ArchivePlatformContractError as the provided UnauthorizedError
func (t *ArchivePlatformContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ArchivePlatformContractError, using the provided UnauthorizedError
func (t *ArchivePlatformContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArchivePlatformContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ArchivePlatformContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_CONTRACT":
		return t.AsPlatformCannotArchiveScheduledContractError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ArchivePlatformContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArchivePlatformContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a ForbiddenError
func (t ArchivePlatformDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided ForbiddenError
func (t *ArchivePlatformDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided ForbiddenError
func (t *ArchivePlatformDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a InvalidRequestError
func (t ArchivePlatformDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided InvalidRequestError
func (t *ArchivePlatformDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided InvalidRequestError
func (t *ArchivePlatformDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCannotArchiveScheduledDiscountSharePolicyError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a PlatformCannotArchiveScheduledDiscountSharePolicyError
func (t ArchivePlatformDiscountSharePolicyError) AsPlatformCannotArchiveScheduledDiscountSharePolicyError() (PlatformCannotArchiveScheduledDiscountSharePolicyError, error) {
	var body PlatformCannotArchiveScheduledDiscountSharePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCannotArchiveScheduledDiscountSharePolicyError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided PlatformCannotArchiveScheduledDiscountSharePolicyError
func (t *ArchivePlatformDiscountSharePolicyError) FromPlatformCannotArchiveScheduledDiscountSharePolicyError(v PlatformCannotArchiveScheduledDiscountSharePolicyError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCannotArchiveScheduledDiscountSharePolicyError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided PlatformCannotArchiveScheduledDiscountSharePolicyError
func (t *ArchivePlatformDiscountSharePolicyError) MergePlatformCannotArchiveScheduledDiscountSharePolicyError(v PlatformCannotArchiveScheduledDiscountSharePolicyError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t ArchivePlatformDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *ArchivePlatformDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *ArchivePlatformDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a PlatformNotEnabledError
func (t ArchivePlatformDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *ArchivePlatformDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *ArchivePlatformDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ArchivePlatformDiscountSharePolicyError as a UnauthorizedError
func (t ArchivePlatformDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ArchivePlatformDiscountSharePolicyError as the provided UnauthorizedError
func (t *ArchivePlatformDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ArchivePlatformDiscountSharePolicyError, using the provided UnauthorizedError
func (t *ArchivePlatformDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArchivePlatformDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ArchivePlatformDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_DISCOUNT_SHARE_POLICY":
		return t.AsPlatformCannotArchiveScheduledDiscountSharePolicyError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ArchivePlatformDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArchivePlatformDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ArchivePlatformPartnerError as a ForbiddenError
func (t ArchivePlatformPartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ArchivePlatformPartnerError as the provided ForbiddenError
func (t *ArchivePlatformPartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided ForbiddenError
func (t *ArchivePlatformPartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ArchivePlatformPartnerError as a InvalidRequestError
func (t ArchivePlatformPartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ArchivePlatformPartnerError as the provided InvalidRequestError
func (t *ArchivePlatformPartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided InvalidRequestError
func (t *ArchivePlatformPartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCannotArchiveScheduledPartnerError returns the union data inside the ArchivePlatformPartnerError as a PlatformCannotArchiveScheduledPartnerError
func (t ArchivePlatformPartnerError) AsPlatformCannotArchiveScheduledPartnerError() (PlatformCannotArchiveScheduledPartnerError, error) {
	var body PlatformCannotArchiveScheduledPartnerError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCannotArchiveScheduledPartnerError overwrites any union data inside the ArchivePlatformPartnerError as the provided PlatformCannotArchiveScheduledPartnerError
func (t *ArchivePlatformPartnerError) FromPlatformCannotArchiveScheduledPartnerError(v PlatformCannotArchiveScheduledPartnerError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_PARTNER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCannotArchiveScheduledPartnerError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided PlatformCannotArchiveScheduledPartnerError
func (t *ArchivePlatformPartnerError) MergePlatformCannotArchiveScheduledPartnerError(v PlatformCannotArchiveScheduledPartnerError) error {
	v.Type = "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_PARTNER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ArchivePlatformPartnerError as a PlatformNotEnabledError
func (t ArchivePlatformPartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ArchivePlatformPartnerError as the provided PlatformNotEnabledError
func (t *ArchivePlatformPartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided PlatformNotEnabledError
func (t *ArchivePlatformPartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the ArchivePlatformPartnerError as a PlatformPartnerNotFoundError
func (t ArchivePlatformPartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the ArchivePlatformPartnerError as the provided PlatformPartnerNotFoundError
func (t *ArchivePlatformPartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided PlatformPartnerNotFoundError
func (t *ArchivePlatformPartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ArchivePlatformPartnerError as a UnauthorizedError
func (t ArchivePlatformPartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ArchivePlatformPartnerError as the provided UnauthorizedError
func (t *ArchivePlatformPartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ArchivePlatformPartnerError, using the provided UnauthorizedError
func (t *ArchivePlatformPartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArchivePlatformPartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ArchivePlatformPartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CANNOT_ARCHIVE_SCHEDULED_PARTNER":
		return t.AsPlatformCannotArchiveScheduledPartnerError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ArchivePlatformPartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArchivePlatformPartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the AttachB2bTaxInvoiceFileError as a B2bExternalServiceError
func (t AttachB2bTaxInvoiceFileError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided B2bExternalServiceError
func (t *AttachB2bTaxInvoiceFileError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided B2bExternalServiceError
func (t *AttachB2bTaxInvoiceFileError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bFileNotFoundError returns the union data inside the AttachB2bTaxInvoiceFileError as a B2bFileNotFoundError
func (t AttachB2bTaxInvoiceFileError) AsB2bFileNotFoundError() (B2bFileNotFoundError, error) {
	var body B2bFileNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bFileNotFoundError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided B2bFileNotFoundError
func (t *AttachB2bTaxInvoiceFileError) FromB2bFileNotFoundError(v B2bFileNotFoundError) error {
	v.Type = "B2B_FILE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bFileNotFoundError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided B2bFileNotFoundError
func (t *AttachB2bTaxInvoiceFileError) MergeB2bFileNotFoundError(v B2bFileNotFoundError) error {
	v.Type = "B2B_FILE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the AttachB2bTaxInvoiceFileError as a B2bNotEnabledError
func (t AttachB2bTaxInvoiceFileError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided B2bNotEnabledError
func (t *AttachB2bTaxInvoiceFileError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided B2bNotEnabledError
func (t *AttachB2bTaxInvoiceFileError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotDraftedStatusError returns the union data inside the AttachB2bTaxInvoiceFileError as a B2bTaxInvoiceNotDraftedStatusError
func (t AttachB2bTaxInvoiceFileError) AsB2bTaxInvoiceNotDraftedStatusError() (B2bTaxInvoiceNotDraftedStatusError, error) {
	var body B2bTaxInvoiceNotDraftedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotDraftedStatusError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided B2bTaxInvoiceNotDraftedStatusError
func (t *AttachB2bTaxInvoiceFileError) FromB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotDraftedStatusError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided B2bTaxInvoiceNotDraftedStatusError
func (t *AttachB2bTaxInvoiceFileError) MergeB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the AttachB2bTaxInvoiceFileError as a B2bTaxInvoiceNotFoundError
func (t AttachB2bTaxInvoiceFileError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided B2bTaxInvoiceNotFoundError
func (t *AttachB2bTaxInvoiceFileError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided B2bTaxInvoiceNotFoundError
func (t *AttachB2bTaxInvoiceFileError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the AttachB2bTaxInvoiceFileError as a ForbiddenError
func (t AttachB2bTaxInvoiceFileError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided ForbiddenError
func (t *AttachB2bTaxInvoiceFileError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided ForbiddenError
func (t *AttachB2bTaxInvoiceFileError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the AttachB2bTaxInvoiceFileError as a InvalidRequestError
func (t AttachB2bTaxInvoiceFileError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided InvalidRequestError
func (t *AttachB2bTaxInvoiceFileError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided InvalidRequestError
func (t *AttachB2bTaxInvoiceFileError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the AttachB2bTaxInvoiceFileError as a UnauthorizedError
func (t AttachB2bTaxInvoiceFileError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the AttachB2bTaxInvoiceFileError as the provided UnauthorizedError
func (t *AttachB2bTaxInvoiceFileError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the AttachB2bTaxInvoiceFileError, using the provided UnauthorizedError
func (t *AttachB2bTaxInvoiceFileError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AttachB2bTaxInvoiceFileError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AttachB2bTaxInvoiceFileError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_FILE_NOT_FOUND":
		return t.AsB2bFileNotFoundError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
		return t.AsB2bTaxInvoiceNotDraftedStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AttachB2bTaxInvoiceFileError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AttachB2bTaxInvoiceFileError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeletedBillingKeyInfo returns the union data inside the BillingKeyInfo as a DeletedBillingKeyInfo
func (t BillingKeyInfo) AsDeletedBillingKeyInfo() (DeletedBillingKeyInfo, error) {
	var body DeletedBillingKeyInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeletedBillingKeyInfo overwrites any union data inside the BillingKeyInfo as the provided DeletedBillingKeyInfo
func (t *BillingKeyInfo) FromDeletedBillingKeyInfo(v DeletedBillingKeyInfo) error {
	v.Status = "DELETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeletedBillingKeyInfo performs a merge with any union data inside the BillingKeyInfo, using the provided DeletedBillingKeyInfo
func (t *BillingKeyInfo) MergeDeletedBillingKeyInfo(v DeletedBillingKeyInfo) error {
	v.Status = "DELETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssuedBillingKeyInfo returns the union data inside the BillingKeyInfo as a IssuedBillingKeyInfo
func (t BillingKeyInfo) AsIssuedBillingKeyInfo() (IssuedBillingKeyInfo, error) {
	var body IssuedBillingKeyInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssuedBillingKeyInfo overwrites any union data inside the BillingKeyInfo as the provided IssuedBillingKeyInfo
func (t *BillingKeyInfo) FromIssuedBillingKeyInfo(v IssuedBillingKeyInfo) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssuedBillingKeyInfo performs a merge with any union data inside the BillingKeyInfo, using the provided IssuedBillingKeyInfo
func (t *BillingKeyInfo) MergeIssuedBillingKeyInfo(v IssuedBillingKeyInfo) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingKeyInfo) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingKeyInfo) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DELETED":
		return t.AsDeletedBillingKeyInfo()
	case "ISSUED":
		return t.AsIssuedBillingKeyInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingKeyInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingKeyInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyPaymentMethodCard returns the union data inside the BillingKeyPaymentMethod as a BillingKeyPaymentMethodCard
func (t BillingKeyPaymentMethod) AsBillingKeyPaymentMethodCard() (BillingKeyPaymentMethodCard, error) {
	var body BillingKeyPaymentMethodCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodCard overwrites any union data inside the BillingKeyPaymentMethod as the provided BillingKeyPaymentMethodCard
func (t *BillingKeyPaymentMethod) FromBillingKeyPaymentMethodCard(v BillingKeyPaymentMethodCard) error {
	v.Type = "BillingKeyPaymentMethodCard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodCard performs a merge with any union data inside the BillingKeyPaymentMethod, using the provided BillingKeyPaymentMethodCard
func (t *BillingKeyPaymentMethod) MergeBillingKeyPaymentMethodCard(v BillingKeyPaymentMethodCard) error {
	v.Type = "BillingKeyPaymentMethodCard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodEasyPay returns the union data inside the BillingKeyPaymentMethod as a BillingKeyPaymentMethodEasyPay
func (t BillingKeyPaymentMethod) AsBillingKeyPaymentMethodEasyPay() (BillingKeyPaymentMethodEasyPay, error) {
	var body BillingKeyPaymentMethodEasyPay
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodEasyPay overwrites any union data inside the BillingKeyPaymentMethod as the provided BillingKeyPaymentMethodEasyPay
func (t *BillingKeyPaymentMethod) FromBillingKeyPaymentMethodEasyPay(v BillingKeyPaymentMethodEasyPay) error {
	v.Type = "BillingKeyPaymentMethodEasyPay"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodEasyPay performs a merge with any union data inside the BillingKeyPaymentMethod, using the provided BillingKeyPaymentMethodEasyPay
func (t *BillingKeyPaymentMethod) MergeBillingKeyPaymentMethodEasyPay(v BillingKeyPaymentMethodEasyPay) error {
	v.Type = "BillingKeyPaymentMethodEasyPay"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodMobile returns the union data inside the BillingKeyPaymentMethod as a BillingKeyPaymentMethodMobile
func (t BillingKeyPaymentMethod) AsBillingKeyPaymentMethodMobile() (BillingKeyPaymentMethodMobile, error) {
	var body BillingKeyPaymentMethodMobile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodMobile overwrites any union data inside the BillingKeyPaymentMethod as the provided BillingKeyPaymentMethodMobile
func (t *BillingKeyPaymentMethod) FromBillingKeyPaymentMethodMobile(v BillingKeyPaymentMethodMobile) error {
	v.Type = "BillingKeyPaymentMethodMobile"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodMobile performs a merge with any union data inside the BillingKeyPaymentMethod, using the provided BillingKeyPaymentMethodMobile
func (t *BillingKeyPaymentMethod) MergeBillingKeyPaymentMethodMobile(v BillingKeyPaymentMethodMobile) error {
	v.Type = "BillingKeyPaymentMethodMobile"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodPaypal returns the union data inside the BillingKeyPaymentMethod as a BillingKeyPaymentMethodPaypal
func (t BillingKeyPaymentMethod) AsBillingKeyPaymentMethodPaypal() (BillingKeyPaymentMethodPaypal, error) {
	var body BillingKeyPaymentMethodPaypal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodPaypal overwrites any union data inside the BillingKeyPaymentMethod as the provided BillingKeyPaymentMethodPaypal
func (t *BillingKeyPaymentMethod) FromBillingKeyPaymentMethodPaypal(v BillingKeyPaymentMethodPaypal) error {
	v.Type = "BillingKeyPaymentMethodPaypal"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodPaypal performs a merge with any union data inside the BillingKeyPaymentMethod, using the provided BillingKeyPaymentMethodPaypal
func (t *BillingKeyPaymentMethod) MergeBillingKeyPaymentMethodPaypal(v BillingKeyPaymentMethodPaypal) error {
	v.Type = "BillingKeyPaymentMethodPaypal"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodTransfer returns the union data inside the BillingKeyPaymentMethod as a BillingKeyPaymentMethodTransfer
func (t BillingKeyPaymentMethod) AsBillingKeyPaymentMethodTransfer() (BillingKeyPaymentMethodTransfer, error) {
	var body BillingKeyPaymentMethodTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodTransfer overwrites any union data inside the BillingKeyPaymentMethod as the provided BillingKeyPaymentMethodTransfer
func (t *BillingKeyPaymentMethod) FromBillingKeyPaymentMethodTransfer(v BillingKeyPaymentMethodTransfer) error {
	v.Type = "BillingKeyPaymentMethodTransfer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodTransfer performs a merge with any union data inside the BillingKeyPaymentMethod, using the provided BillingKeyPaymentMethodTransfer
func (t *BillingKeyPaymentMethod) MergeBillingKeyPaymentMethodTransfer(v BillingKeyPaymentMethodTransfer) error {
	v.Type = "BillingKeyPaymentMethodTransfer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingKeyPaymentMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingKeyPaymentMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BillingKeyPaymentMethodCard":
		return t.AsBillingKeyPaymentMethodCard()
	case "BillingKeyPaymentMethodEasyPay":
		return t.AsBillingKeyPaymentMethodEasyPay()
	case "BillingKeyPaymentMethodMobile":
		return t.AsBillingKeyPaymentMethodMobile()
	case "BillingKeyPaymentMethodPaypal":
		return t.AsBillingKeyPaymentMethodPaypal()
	case "BillingKeyPaymentMethodTransfer":
		return t.AsBillingKeyPaymentMethodTransfer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingKeyPaymentMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingKeyPaymentMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyPaymentMethodCard returns the union data inside the BillingKeyPaymentMethodEasyPayMethod as a BillingKeyPaymentMethodCard
func (t BillingKeyPaymentMethodEasyPayMethod) AsBillingKeyPaymentMethodCard() (BillingKeyPaymentMethodCard, error) {
	var body BillingKeyPaymentMethodCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodCard overwrites any union data inside the BillingKeyPaymentMethodEasyPayMethod as the provided BillingKeyPaymentMethodCard
func (t *BillingKeyPaymentMethodEasyPayMethod) FromBillingKeyPaymentMethodCard(v BillingKeyPaymentMethodCard) error {
	v.Type = "BillingKeyPaymentMethodCard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodCard performs a merge with any union data inside the BillingKeyPaymentMethodEasyPayMethod, using the provided BillingKeyPaymentMethodCard
func (t *BillingKeyPaymentMethodEasyPayMethod) MergeBillingKeyPaymentMethodCard(v BillingKeyPaymentMethodCard) error {
	v.Type = "BillingKeyPaymentMethodCard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodEasyPayCharge returns the union data inside the BillingKeyPaymentMethodEasyPayMethod as a BillingKeyPaymentMethodEasyPayCharge
func (t BillingKeyPaymentMethodEasyPayMethod) AsBillingKeyPaymentMethodEasyPayCharge() (BillingKeyPaymentMethodEasyPayCharge, error) {
	var body BillingKeyPaymentMethodEasyPayCharge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodEasyPayCharge overwrites any union data inside the BillingKeyPaymentMethodEasyPayMethod as the provided BillingKeyPaymentMethodEasyPayCharge
func (t *BillingKeyPaymentMethodEasyPayMethod) FromBillingKeyPaymentMethodEasyPayCharge(v BillingKeyPaymentMethodEasyPayCharge) error {
	v.Type = "BillingKeyPaymentMethodEasyPayCharge"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodEasyPayCharge performs a merge with any union data inside the BillingKeyPaymentMethodEasyPayMethod, using the provided BillingKeyPaymentMethodEasyPayCharge
func (t *BillingKeyPaymentMethodEasyPayMethod) MergeBillingKeyPaymentMethodEasyPayCharge(v BillingKeyPaymentMethodEasyPayCharge) error {
	v.Type = "BillingKeyPaymentMethodEasyPayCharge"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyPaymentMethodTransfer returns the union data inside the BillingKeyPaymentMethodEasyPayMethod as a BillingKeyPaymentMethodTransfer
func (t BillingKeyPaymentMethodEasyPayMethod) AsBillingKeyPaymentMethodTransfer() (BillingKeyPaymentMethodTransfer, error) {
	var body BillingKeyPaymentMethodTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyPaymentMethodTransfer overwrites any union data inside the BillingKeyPaymentMethodEasyPayMethod as the provided BillingKeyPaymentMethodTransfer
func (t *BillingKeyPaymentMethodEasyPayMethod) FromBillingKeyPaymentMethodTransfer(v BillingKeyPaymentMethodTransfer) error {
	v.Type = "BillingKeyPaymentMethodTransfer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyPaymentMethodTransfer performs a merge with any union data inside the BillingKeyPaymentMethodEasyPayMethod, using the provided BillingKeyPaymentMethodTransfer
func (t *BillingKeyPaymentMethodEasyPayMethod) MergeBillingKeyPaymentMethodTransfer(v BillingKeyPaymentMethodTransfer) error {
	v.Type = "BillingKeyPaymentMethodTransfer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BillingKeyPaymentMethodEasyPayMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BillingKeyPaymentMethodEasyPayMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BillingKeyPaymentMethodCard":
		return t.AsBillingKeyPaymentMethodCard()
	case "BillingKeyPaymentMethodEasyPayCharge":
		return t.AsBillingKeyPaymentMethodEasyPayCharge()
	case "BillingKeyPaymentMethodTransfer":
		return t.AsBillingKeyPaymentMethodTransfer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BillingKeyPaymentMethodEasyPayMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BillingKeyPaymentMethodEasyPayMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a B2bExternalServiceError
func (t CancelB2bTaxInvoiceIssuanceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided B2bExternalServiceError
func (t *CancelB2bTaxInvoiceIssuanceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided B2bExternalServiceError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a B2bNotEnabledError
func (t CancelB2bTaxInvoiceIssuanceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided B2bNotEnabledError
func (t *CancelB2bTaxInvoiceIssuanceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided B2bNotEnabledError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a B2bTaxInvoiceNotFoundError
func (t CancelB2bTaxInvoiceIssuanceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided B2bTaxInvoiceNotFoundError
func (t *CancelB2bTaxInvoiceIssuanceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided B2bTaxInvoiceNotFoundError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotIssuedStatusError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a B2bTaxInvoiceNotIssuedStatusError
func (t CancelB2bTaxInvoiceIssuanceError) AsB2bTaxInvoiceNotIssuedStatusError() (B2bTaxInvoiceNotIssuedStatusError, error) {
	var body B2bTaxInvoiceNotIssuedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotIssuedStatusError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided B2bTaxInvoiceNotIssuedStatusError
func (t *CancelB2bTaxInvoiceIssuanceError) FromB2bTaxInvoiceNotIssuedStatusError(v B2bTaxInvoiceNotIssuedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_ISSUED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotIssuedStatusError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided B2bTaxInvoiceNotIssuedStatusError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeB2bTaxInvoiceNotIssuedStatusError(v B2bTaxInvoiceNotIssuedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_ISSUED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a ForbiddenError
func (t CancelB2bTaxInvoiceIssuanceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided ForbiddenError
func (t *CancelB2bTaxInvoiceIssuanceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided ForbiddenError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a InvalidRequestError
func (t CancelB2bTaxInvoiceIssuanceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided InvalidRequestError
func (t *CancelB2bTaxInvoiceIssuanceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided InvalidRequestError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelB2bTaxInvoiceIssuanceError as a UnauthorizedError
func (t CancelB2bTaxInvoiceIssuanceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelB2bTaxInvoiceIssuanceError as the provided UnauthorizedError
func (t *CancelB2bTaxInvoiceIssuanceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelB2bTaxInvoiceIssuanceError, using the provided UnauthorizedError
func (t *CancelB2bTaxInvoiceIssuanceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelB2bTaxInvoiceIssuanceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelB2bTaxInvoiceIssuanceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_ISSUED_STATUS":
		return t.AsB2bTaxInvoiceNotIssuedStatusError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelB2bTaxInvoiceIssuanceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelB2bTaxInvoiceIssuanceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the CancelB2bTaxInvoiceRequestError as a B2bExternalServiceError
func (t CancelB2bTaxInvoiceRequestError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided B2bExternalServiceError
func (t *CancelB2bTaxInvoiceRequestError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided B2bExternalServiceError
func (t *CancelB2bTaxInvoiceRequestError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the CancelB2bTaxInvoiceRequestError as a B2bNotEnabledError
func (t CancelB2bTaxInvoiceRequestError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided B2bNotEnabledError
func (t *CancelB2bTaxInvoiceRequestError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided B2bNotEnabledError
func (t *CancelB2bTaxInvoiceRequestError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNoRecipientDocumentKeyError returns the union data inside the CancelB2bTaxInvoiceRequestError as a B2bTaxInvoiceNoRecipientDocumentKeyError
func (t CancelB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNoRecipientDocumentKeyError() (B2bTaxInvoiceNoRecipientDocumentKeyError, error) {
	var body B2bTaxInvoiceNoRecipientDocumentKeyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNoRecipientDocumentKeyError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNoRecipientDocumentKeyError
func (t *CancelB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNoRecipientDocumentKeyError(v B2bTaxInvoiceNoRecipientDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNoRecipientDocumentKeyError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNoRecipientDocumentKeyError
func (t *CancelB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNoRecipientDocumentKeyError(v B2bTaxInvoiceNoRecipientDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the CancelB2bTaxInvoiceRequestError as a B2bTaxInvoiceNotFoundError
func (t CancelB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNotFoundError
func (t *CancelB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNotFoundError
func (t *CancelB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotRequestedStatusError returns the union data inside the CancelB2bTaxInvoiceRequestError as a B2bTaxInvoiceNotRequestedStatusError
func (t CancelB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNotRequestedStatusError() (B2bTaxInvoiceNotRequestedStatusError, error) {
	var body B2bTaxInvoiceNotRequestedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotRequestedStatusError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNotRequestedStatusError
func (t *CancelB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotRequestedStatusError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNotRequestedStatusError
func (t *CancelB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CancelB2bTaxInvoiceRequestError as a ForbiddenError
func (t CancelB2bTaxInvoiceRequestError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided ForbiddenError
func (t *CancelB2bTaxInvoiceRequestError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided ForbiddenError
func (t *CancelB2bTaxInvoiceRequestError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelB2bTaxInvoiceRequestError as a InvalidRequestError
func (t CancelB2bTaxInvoiceRequestError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided InvalidRequestError
func (t *CancelB2bTaxInvoiceRequestError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided InvalidRequestError
func (t *CancelB2bTaxInvoiceRequestError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelB2bTaxInvoiceRequestError as a UnauthorizedError
func (t CancelB2bTaxInvoiceRequestError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelB2bTaxInvoiceRequestError as the provided UnauthorizedError
func (t *CancelB2bTaxInvoiceRequestError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelB2bTaxInvoiceRequestError, using the provided UnauthorizedError
func (t *CancelB2bTaxInvoiceRequestError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelB2bTaxInvoiceRequestError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelB2bTaxInvoiceRequestError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
		return t.AsB2bTaxInvoiceNotRequestedStatusError()
	case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
		return t.AsB2bTaxInvoiceNoRecipientDocumentKeyError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelB2bTaxInvoiceRequestError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelB2bTaxInvoiceRequestError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashReceiptNotFoundError returns the union data inside the CancelCashReceiptError as a CashReceiptNotFoundError
func (t CancelCashReceiptError) AsCashReceiptNotFoundError() (CashReceiptNotFoundError, error) {
	var body CashReceiptNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashReceiptNotFoundError overwrites any union data inside the CancelCashReceiptError as the provided CashReceiptNotFoundError
func (t *CancelCashReceiptError) FromCashReceiptNotFoundError(v CashReceiptNotFoundError) error {
	v.Type = "CASH_RECEIPT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashReceiptNotFoundError performs a merge with any union data inside the CancelCashReceiptError, using the provided CashReceiptNotFoundError
func (t *CancelCashReceiptError) MergeCashReceiptNotFoundError(v CashReceiptNotFoundError) error {
	v.Type = "CASH_RECEIPT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCashReceiptNotIssuedError returns the union data inside the CancelCashReceiptError as a CashReceiptNotIssuedError
func (t CancelCashReceiptError) AsCashReceiptNotIssuedError() (CashReceiptNotIssuedError, error) {
	var body CashReceiptNotIssuedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashReceiptNotIssuedError overwrites any union data inside the CancelCashReceiptError as the provided CashReceiptNotIssuedError
func (t *CancelCashReceiptError) FromCashReceiptNotIssuedError(v CashReceiptNotIssuedError) error {
	v.Type = "CASH_RECEIPT_NOT_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashReceiptNotIssuedError performs a merge with any union data inside the CancelCashReceiptError, using the provided CashReceiptNotIssuedError
func (t *CancelCashReceiptError) MergeCashReceiptNotIssuedError(v CashReceiptNotIssuedError) error {
	v.Type = "CASH_RECEIPT_NOT_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CancelCashReceiptError as a ForbiddenError
func (t CancelCashReceiptError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelCashReceiptError as the provided ForbiddenError
func (t *CancelCashReceiptError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelCashReceiptError, using the provided ForbiddenError
func (t *CancelCashReceiptError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelCashReceiptError as a InvalidRequestError
func (t CancelCashReceiptError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelCashReceiptError as the provided InvalidRequestError
func (t *CancelCashReceiptError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelCashReceiptError, using the provided InvalidRequestError
func (t *CancelCashReceiptError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the CancelCashReceiptError as a PgProviderError
func (t CancelCashReceiptError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the CancelCashReceiptError as the provided PgProviderError
func (t *CancelCashReceiptError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the CancelCashReceiptError, using the provided PgProviderError
func (t *CancelCashReceiptError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelCashReceiptError as a UnauthorizedError
func (t CancelCashReceiptError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelCashReceiptError as the provided UnauthorizedError
func (t *CancelCashReceiptError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelCashReceiptError, using the provided UnauthorizedError
func (t *CancelCashReceiptError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelCashReceiptError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelCashReceiptError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CASH_RECEIPT_NOT_FOUND":
		return t.AsCashReceiptNotFoundError()
	case "CASH_RECEIPT_NOT_ISSUED":
		return t.AsCashReceiptNotIssuedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelCashReceiptError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelCashReceiptError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelAmountExceedsCancellableAmountError returns the union data inside the CancelPaymentError as a CancelAmountExceedsCancellableAmountError
func (t CancelPaymentError) AsCancelAmountExceedsCancellableAmountError() (CancelAmountExceedsCancellableAmountError, error) {
	var body CancelAmountExceedsCancellableAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelAmountExceedsCancellableAmountError overwrites any union data inside the CancelPaymentError as the provided CancelAmountExceedsCancellableAmountError
func (t *CancelPaymentError) FromCancelAmountExceedsCancellableAmountError(v CancelAmountExceedsCancellableAmountError) error {
	v.Type = "CANCEL_AMOUNT_EXCEEDS_CANCELLABLE_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelAmountExceedsCancellableAmountError performs a merge with any union data inside the CancelPaymentError, using the provided CancelAmountExceedsCancellableAmountError
func (t *CancelPaymentError) MergeCancelAmountExceedsCancellableAmountError(v CancelAmountExceedsCancellableAmountError) error {
	v.Type = "CANCEL_AMOUNT_EXCEEDS_CANCELLABLE_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCancelTaxAmountExceedsCancellableTaxAmountError returns the union data inside the CancelPaymentError as a CancelTaxAmountExceedsCancellableTaxAmountError
func (t CancelPaymentError) AsCancelTaxAmountExceedsCancellableTaxAmountError() (CancelTaxAmountExceedsCancellableTaxAmountError, error) {
	var body CancelTaxAmountExceedsCancellableTaxAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelTaxAmountExceedsCancellableTaxAmountError overwrites any union data inside the CancelPaymentError as the provided CancelTaxAmountExceedsCancellableTaxAmountError
func (t *CancelPaymentError) FromCancelTaxAmountExceedsCancellableTaxAmountError(v CancelTaxAmountExceedsCancellableTaxAmountError) error {
	v.Type = "CANCEL_TAX_AMOUNT_EXCEEDS_CANCELLABLE_TAX_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelTaxAmountExceedsCancellableTaxAmountError performs a merge with any union data inside the CancelPaymentError, using the provided CancelTaxAmountExceedsCancellableTaxAmountError
func (t *CancelPaymentError) MergeCancelTaxAmountExceedsCancellableTaxAmountError(v CancelTaxAmountExceedsCancellableTaxAmountError) error {
	v.Type = "CANCEL_TAX_AMOUNT_EXCEEDS_CANCELLABLE_TAX_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError returns the union data inside the CancelPaymentError as a CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError
func (t CancelPaymentError) AsCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError() (CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError, error) {
	var body CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError overwrites any union data inside the CancelPaymentError as the provided CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError
func (t *CancelPaymentError) FromCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError(v CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError) error {
	v.Type = "CANCEL_TAX_FREE_AMOUNT_EXCEEDS_CANCELLABLE_TAX_FREE_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError performs a merge with any union data inside the CancelPaymentError, using the provided CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError
func (t *CancelPaymentError) MergeCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError(v CancelTaxFreeAmountExceedsCancellableTaxFreeAmountError) error {
	v.Type = "CANCEL_TAX_FREE_AMOUNT_EXCEEDS_CANCELLABLE_TAX_FREE_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCancellableAmountConsistencyBrokenError returns the union data inside the CancelPaymentError as a CancellableAmountConsistencyBrokenError
func (t CancelPaymentError) AsCancellableAmountConsistencyBrokenError() (CancellableAmountConsistencyBrokenError, error) {
	var body CancellableAmountConsistencyBrokenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancellableAmountConsistencyBrokenError overwrites any union data inside the CancelPaymentError as the provided CancellableAmountConsistencyBrokenError
func (t *CancelPaymentError) FromCancellableAmountConsistencyBrokenError(v CancellableAmountConsistencyBrokenError) error {
	v.Type = "CANCELLABLE_AMOUNT_CONSISTENCY_BROKEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancellableAmountConsistencyBrokenError performs a merge with any union data inside the CancelPaymentError, using the provided CancellableAmountConsistencyBrokenError
func (t *CancelPaymentError) MergeCancellableAmountConsistencyBrokenError(v CancellableAmountConsistencyBrokenError) error {
	v.Type = "CANCELLABLE_AMOUNT_CONSISTENCY_BROKEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CancelPaymentError as a ForbiddenError
func (t CancelPaymentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelPaymentError as the provided ForbiddenError
func (t *CancelPaymentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelPaymentError, using the provided ForbiddenError
func (t *CancelPaymentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelPaymentError as a InvalidRequestError
func (t CancelPaymentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelPaymentError as the provided InvalidRequestError
func (t *CancelPaymentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelPaymentError, using the provided InvalidRequestError
func (t *CancelPaymentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNegativePromotionAdjustedCancelAmountError returns the union data inside the CancelPaymentError as a NegativePromotionAdjustedCancelAmountError
func (t CancelPaymentError) AsNegativePromotionAdjustedCancelAmountError() (NegativePromotionAdjustedCancelAmountError, error) {
	var body NegativePromotionAdjustedCancelAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNegativePromotionAdjustedCancelAmountError overwrites any union data inside the CancelPaymentError as the provided NegativePromotionAdjustedCancelAmountError
func (t *CancelPaymentError) FromNegativePromotionAdjustedCancelAmountError(v NegativePromotionAdjustedCancelAmountError) error {
	v.Type = "NEGATIVE_PROMOTION_ADJUSTED_CANCEL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNegativePromotionAdjustedCancelAmountError performs a merge with any union data inside the CancelPaymentError, using the provided NegativePromotionAdjustedCancelAmountError
func (t *CancelPaymentError) MergeNegativePromotionAdjustedCancelAmountError(v NegativePromotionAdjustedCancelAmountError) error {
	v.Type = "NEGATIVE_PROMOTION_ADJUSTED_CANCEL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentAlreadyCancelledError returns the union data inside the CancelPaymentError as a PaymentAlreadyCancelledError
func (t CancelPaymentError) AsPaymentAlreadyCancelledError() (PaymentAlreadyCancelledError, error) {
	var body PaymentAlreadyCancelledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentAlreadyCancelledError overwrites any union data inside the CancelPaymentError as the provided PaymentAlreadyCancelledError
func (t *CancelPaymentError) FromPaymentAlreadyCancelledError(v PaymentAlreadyCancelledError) error {
	v.Type = "PAYMENT_ALREADY_CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentAlreadyCancelledError performs a merge with any union data inside the CancelPaymentError, using the provided PaymentAlreadyCancelledError
func (t *CancelPaymentError) MergePaymentAlreadyCancelledError(v PaymentAlreadyCancelledError) error {
	v.Type = "PAYMENT_ALREADY_CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the CancelPaymentError as a PaymentNotFoundError
func (t CancelPaymentError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the CancelPaymentError as the provided PaymentNotFoundError
func (t *CancelPaymentError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the CancelPaymentError, using the provided PaymentNotFoundError
func (t *CancelPaymentError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the CancelPaymentError as a PaymentNotPaidError
func (t CancelPaymentError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the CancelPaymentError as the provided PaymentNotPaidError
func (t *CancelPaymentError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the CancelPaymentError, using the provided PaymentNotPaidError
func (t *CancelPaymentError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the CancelPaymentError as a PgProviderError
func (t CancelPaymentError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the CancelPaymentError as the provided PgProviderError
func (t *CancelPaymentError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the CancelPaymentError, using the provided PgProviderError
func (t *CancelPaymentError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionDiscountRetainOptionShouldNotBeChangedError returns the union data inside the CancelPaymentError as a PromotionDiscountRetainOptionShouldNotBeChangedError
func (t CancelPaymentError) AsPromotionDiscountRetainOptionShouldNotBeChangedError() (PromotionDiscountRetainOptionShouldNotBeChangedError, error) {
	var body PromotionDiscountRetainOptionShouldNotBeChangedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionDiscountRetainOptionShouldNotBeChangedError overwrites any union data inside the CancelPaymentError as the provided PromotionDiscountRetainOptionShouldNotBeChangedError
func (t *CancelPaymentError) FromPromotionDiscountRetainOptionShouldNotBeChangedError(v PromotionDiscountRetainOptionShouldNotBeChangedError) error {
	v.Type = "PROMOTION_DISCOUNT_RETAIN_OPTION_SHOULD_NOT_BE_CHANGED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionDiscountRetainOptionShouldNotBeChangedError performs a merge with any union data inside the CancelPaymentError, using the provided PromotionDiscountRetainOptionShouldNotBeChangedError
func (t *CancelPaymentError) MergePromotionDiscountRetainOptionShouldNotBeChangedError(v PromotionDiscountRetainOptionShouldNotBeChangedError) error {
	v.Type = "PROMOTION_DISCOUNT_RETAIN_OPTION_SHOULD_NOT_BE_CHANGED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSumOfPartsExceedsCancelAmountError returns the union data inside the CancelPaymentError as a SumOfPartsExceedsCancelAmountError
func (t CancelPaymentError) AsSumOfPartsExceedsCancelAmountError() (SumOfPartsExceedsCancelAmountError, error) {
	var body SumOfPartsExceedsCancelAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSumOfPartsExceedsCancelAmountError overwrites any union data inside the CancelPaymentError as the provided SumOfPartsExceedsCancelAmountError
func (t *CancelPaymentError) FromSumOfPartsExceedsCancelAmountError(v SumOfPartsExceedsCancelAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_CANCEL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSumOfPartsExceedsCancelAmountError performs a merge with any union data inside the CancelPaymentError, using the provided SumOfPartsExceedsCancelAmountError
func (t *CancelPaymentError) MergeSumOfPartsExceedsCancelAmountError(v SumOfPartsExceedsCancelAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_CANCEL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelPaymentError as a UnauthorizedError
func (t CancelPaymentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelPaymentError as the provided UnauthorizedError
func (t *CancelPaymentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelPaymentError, using the provided UnauthorizedError
func (t *CancelPaymentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelPaymentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelPaymentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLABLE_AMOUNT_CONSISTENCY_BROKEN":
		return t.AsCancellableAmountConsistencyBrokenError()
	case "CANCEL_AMOUNT_EXCEEDS_CANCELLABLE_AMOUNT":
		return t.AsCancelAmountExceedsCancellableAmountError()
	case "CANCEL_TAX_AMOUNT_EXCEEDS_CANCELLABLE_TAX_AMOUNT":
		return t.AsCancelTaxAmountExceedsCancellableTaxAmountError()
	case "CANCEL_TAX_FREE_AMOUNT_EXCEEDS_CANCELLABLE_TAX_FREE_AMOUNT":
		return t.AsCancelTaxFreeAmountExceedsCancellableTaxFreeAmountError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "NEGATIVE_PROMOTION_ADJUSTED_CANCEL_AMOUNT":
		return t.AsNegativePromotionAdjustedCancelAmountError()
	case "PAYMENT_ALREADY_CANCELLED":
		return t.AsPaymentAlreadyCancelledError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "PROMOTION_DISCOUNT_RETAIN_OPTION_SHOULD_NOT_BE_CHANGED":
		return t.AsPromotionDiscountRetainOptionShouldNotBeChangedError()
	case "SUM_OF_PARTS_EXCEEDS_CANCEL_AMOUNT":
		return t.AsSumOfPartsExceedsCancelAmountError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelPaymentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelPaymentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CancelPlatformAdditionalFeePolicyScheduleError as a ForbiddenError
func (t CancelPlatformAdditionalFeePolicyScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelPlatformAdditionalFeePolicyScheduleError as the provided ForbiddenError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelPlatformAdditionalFeePolicyScheduleError, using the provided ForbiddenError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelPlatformAdditionalFeePolicyScheduleError as a InvalidRequestError
func (t CancelPlatformAdditionalFeePolicyScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelPlatformAdditionalFeePolicyScheduleError as the provided InvalidRequestError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelPlatformAdditionalFeePolicyScheduleError, using the provided InvalidRequestError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the CancelPlatformAdditionalFeePolicyScheduleError as a PlatformAdditionalFeePolicyNotFoundError
func (t CancelPlatformAdditionalFeePolicyScheduleError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the CancelPlatformAdditionalFeePolicyScheduleError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the CancelPlatformAdditionalFeePolicyScheduleError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CancelPlatformAdditionalFeePolicyScheduleError as a PlatformNotEnabledError
func (t CancelPlatformAdditionalFeePolicyScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CancelPlatformAdditionalFeePolicyScheduleError as the provided PlatformNotEnabledError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CancelPlatformAdditionalFeePolicyScheduleError, using the provided PlatformNotEnabledError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelPlatformAdditionalFeePolicyScheduleError as a UnauthorizedError
func (t CancelPlatformAdditionalFeePolicyScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelPlatformAdditionalFeePolicyScheduleError as the provided UnauthorizedError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelPlatformAdditionalFeePolicyScheduleError, using the provided UnauthorizedError
func (t *CancelPlatformAdditionalFeePolicyScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelPlatformAdditionalFeePolicyScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelPlatformAdditionalFeePolicyScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelPlatformAdditionalFeePolicyScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelPlatformAdditionalFeePolicyScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CancelPlatformContractScheduleError as a ForbiddenError
func (t CancelPlatformContractScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelPlatformContractScheduleError as the provided ForbiddenError
func (t *CancelPlatformContractScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelPlatformContractScheduleError, using the provided ForbiddenError
func (t *CancelPlatformContractScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelPlatformContractScheduleError as a InvalidRequestError
func (t CancelPlatformContractScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelPlatformContractScheduleError as the provided InvalidRequestError
func (t *CancelPlatformContractScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelPlatformContractScheduleError, using the provided InvalidRequestError
func (t *CancelPlatformContractScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the CancelPlatformContractScheduleError as a PlatformContractNotFoundError
func (t CancelPlatformContractScheduleError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the CancelPlatformContractScheduleError as the provided PlatformContractNotFoundError
func (t *CancelPlatformContractScheduleError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the CancelPlatformContractScheduleError, using the provided PlatformContractNotFoundError
func (t *CancelPlatformContractScheduleError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CancelPlatformContractScheduleError as a PlatformNotEnabledError
func (t CancelPlatformContractScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CancelPlatformContractScheduleError as the provided PlatformNotEnabledError
func (t *CancelPlatformContractScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CancelPlatformContractScheduleError, using the provided PlatformNotEnabledError
func (t *CancelPlatformContractScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelPlatformContractScheduleError as a UnauthorizedError
func (t CancelPlatformContractScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelPlatformContractScheduleError as the provided UnauthorizedError
func (t *CancelPlatformContractScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelPlatformContractScheduleError, using the provided UnauthorizedError
func (t *CancelPlatformContractScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelPlatformContractScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelPlatformContractScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelPlatformContractScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelPlatformContractScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CancelPlatformDiscountSharePolicyScheduleError as a ForbiddenError
func (t CancelPlatformDiscountSharePolicyScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelPlatformDiscountSharePolicyScheduleError as the provided ForbiddenError
func (t *CancelPlatformDiscountSharePolicyScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelPlatformDiscountSharePolicyScheduleError, using the provided ForbiddenError
func (t *CancelPlatformDiscountSharePolicyScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelPlatformDiscountSharePolicyScheduleError as a InvalidRequestError
func (t CancelPlatformDiscountSharePolicyScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelPlatformDiscountSharePolicyScheduleError as the provided InvalidRequestError
func (t *CancelPlatformDiscountSharePolicyScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelPlatformDiscountSharePolicyScheduleError, using the provided InvalidRequestError
func (t *CancelPlatformDiscountSharePolicyScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the CancelPlatformDiscountSharePolicyScheduleError as a PlatformDiscountSharePolicyNotFoundError
func (t CancelPlatformDiscountSharePolicyScheduleError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the CancelPlatformDiscountSharePolicyScheduleError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *CancelPlatformDiscountSharePolicyScheduleError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the CancelPlatformDiscountSharePolicyScheduleError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *CancelPlatformDiscountSharePolicyScheduleError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CancelPlatformDiscountSharePolicyScheduleError as a PlatformNotEnabledError
func (t CancelPlatformDiscountSharePolicyScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CancelPlatformDiscountSharePolicyScheduleError as the provided PlatformNotEnabledError
func (t *CancelPlatformDiscountSharePolicyScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CancelPlatformDiscountSharePolicyScheduleError, using the provided PlatformNotEnabledError
func (t *CancelPlatformDiscountSharePolicyScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelPlatformDiscountSharePolicyScheduleError as a UnauthorizedError
func (t CancelPlatformDiscountSharePolicyScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelPlatformDiscountSharePolicyScheduleError as the provided UnauthorizedError
func (t *CancelPlatformDiscountSharePolicyScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelPlatformDiscountSharePolicyScheduleError, using the provided UnauthorizedError
func (t *CancelPlatformDiscountSharePolicyScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelPlatformDiscountSharePolicyScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelPlatformDiscountSharePolicyScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelPlatformDiscountSharePolicyScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelPlatformDiscountSharePolicyScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CancelPlatformPartnerScheduleError as a ForbiddenError
func (t CancelPlatformPartnerScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CancelPlatformPartnerScheduleError as the provided ForbiddenError
func (t *CancelPlatformPartnerScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CancelPlatformPartnerScheduleError, using the provided ForbiddenError
func (t *CancelPlatformPartnerScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CancelPlatformPartnerScheduleError as a InvalidRequestError
func (t CancelPlatformPartnerScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CancelPlatformPartnerScheduleError as the provided InvalidRequestError
func (t *CancelPlatformPartnerScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CancelPlatformPartnerScheduleError, using the provided InvalidRequestError
func (t *CancelPlatformPartnerScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CancelPlatformPartnerScheduleError as a PlatformNotEnabledError
func (t CancelPlatformPartnerScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CancelPlatformPartnerScheduleError as the provided PlatformNotEnabledError
func (t *CancelPlatformPartnerScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CancelPlatformPartnerScheduleError, using the provided PlatformNotEnabledError
func (t *CancelPlatformPartnerScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the CancelPlatformPartnerScheduleError as a PlatformPartnerNotFoundError
func (t CancelPlatformPartnerScheduleError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the CancelPlatformPartnerScheduleError as the provided PlatformPartnerNotFoundError
func (t *CancelPlatformPartnerScheduleError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the CancelPlatformPartnerScheduleError, using the provided PlatformPartnerNotFoundError
func (t *CancelPlatformPartnerScheduleError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CancelPlatformPartnerScheduleError as a UnauthorizedError
func (t CancelPlatformPartnerScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CancelPlatformPartnerScheduleError as the provided UnauthorizedError
func (t *CancelPlatformPartnerScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CancelPlatformPartnerScheduleError, using the provided UnauthorizedError
func (t *CancelPlatformPartnerScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CancelPlatformPartnerScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CancelPlatformPartnerScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CancelPlatformPartnerScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CancelPlatformPartnerScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CapturePaymentError as a ForbiddenError
func (t CapturePaymentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CapturePaymentError as the provided ForbiddenError
func (t *CapturePaymentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CapturePaymentError, using the provided ForbiddenError
func (t *CapturePaymentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CapturePaymentError as a InvalidRequestError
func (t CapturePaymentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CapturePaymentError as the provided InvalidRequestError
func (t *CapturePaymentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CapturePaymentError, using the provided InvalidRequestError
func (t *CapturePaymentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the CapturePaymentError as a PaymentNotFoundError
func (t CapturePaymentError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the CapturePaymentError as the provided PaymentNotFoundError
func (t *CapturePaymentError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the CapturePaymentError, using the provided PaymentNotFoundError
func (t *CapturePaymentError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the CapturePaymentError as a PaymentNotPaidError
func (t CapturePaymentError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the CapturePaymentError as the provided PaymentNotPaidError
func (t *CapturePaymentError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the CapturePaymentError, using the provided PaymentNotPaidError
func (t *CapturePaymentError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the CapturePaymentError as a PgProviderError
func (t CapturePaymentError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the CapturePaymentError as the provided PgProviderError
func (t *CapturePaymentError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the CapturePaymentError, using the provided PgProviderError
func (t *CapturePaymentError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CapturePaymentError as a UnauthorizedError
func (t CapturePaymentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CapturePaymentError as the provided UnauthorizedError
func (t *CapturePaymentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CapturePaymentError, using the provided UnauthorizedError
func (t *CapturePaymentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CapturePaymentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CapturePaymentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CapturePaymentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CapturePaymentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelledCashReceipt returns the union data inside the CashReceipt as a CancelledCashReceipt
func (t CashReceipt) AsCancelledCashReceipt() (CancelledCashReceipt, error) {
	var body CancelledCashReceipt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledCashReceipt overwrites any union data inside the CashReceipt as the provided CancelledCashReceipt
func (t *CashReceipt) FromCancelledCashReceipt(v CancelledCashReceipt) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledCashReceipt performs a merge with any union data inside the CashReceipt, using the provided CancelledCashReceipt
func (t *CashReceipt) MergeCancelledCashReceipt(v CancelledCashReceipt) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFailedCashReceipt returns the union data inside the CashReceipt as a IssueFailedCashReceipt
func (t CashReceipt) AsIssueFailedCashReceipt() (IssueFailedCashReceipt, error) {
	var body IssueFailedCashReceipt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFailedCashReceipt overwrites any union data inside the CashReceipt as the provided IssueFailedCashReceipt
func (t *CashReceipt) FromIssueFailedCashReceipt(v IssueFailedCashReceipt) error {
	v.Status = "ISSUE_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFailedCashReceipt performs a merge with any union data inside the CashReceipt, using the provided IssueFailedCashReceipt
func (t *CashReceipt) MergeIssueFailedCashReceipt(v IssueFailedCashReceipt) error {
	v.Status = "ISSUE_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssuedCashReceipt returns the union data inside the CashReceipt as a IssuedCashReceipt
func (t CashReceipt) AsIssuedCashReceipt() (IssuedCashReceipt, error) {
	var body IssuedCashReceipt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssuedCashReceipt overwrites any union data inside the CashReceipt as the provided IssuedCashReceipt
func (t *CashReceipt) FromIssuedCashReceipt(v IssuedCashReceipt) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssuedCashReceipt performs a merge with any union data inside the CashReceipt, using the provided IssuedCashReceipt
func (t *CashReceipt) MergeIssuedCashReceipt(v IssuedCashReceipt) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CashReceipt) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CashReceipt) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLED":
		return t.AsCancelledCashReceipt()
	case "ISSUED":
		return t.AsIssuedCashReceipt()
	case "ISSUE_FAILED":
		return t.AsIssueFailedCashReceipt()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CashReceipt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CashReceipt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChannelSpecificFailureInvalidRequest returns the union data inside the ChannelSpecificFailure as a ChannelSpecificFailureInvalidRequest
func (t ChannelSpecificFailure) AsChannelSpecificFailureInvalidRequest() (ChannelSpecificFailureInvalidRequest, error) {
	var body ChannelSpecificFailureInvalidRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelSpecificFailureInvalidRequest overwrites any union data inside the ChannelSpecificFailure as the provided ChannelSpecificFailureInvalidRequest
func (t *ChannelSpecificFailure) FromChannelSpecificFailureInvalidRequest(v ChannelSpecificFailureInvalidRequest) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelSpecificFailureInvalidRequest performs a merge with any union data inside the ChannelSpecificFailure, using the provided ChannelSpecificFailureInvalidRequest
func (t *ChannelSpecificFailure) MergeChannelSpecificFailureInvalidRequest(v ChannelSpecificFailureInvalidRequest) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelSpecificFailurePgProvider returns the union data inside the ChannelSpecificFailure as a ChannelSpecificFailurePgProvider
func (t ChannelSpecificFailure) AsChannelSpecificFailurePgProvider() (ChannelSpecificFailurePgProvider, error) {
	var body ChannelSpecificFailurePgProvider
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelSpecificFailurePgProvider overwrites any union data inside the ChannelSpecificFailure as the provided ChannelSpecificFailurePgProvider
func (t *ChannelSpecificFailure) FromChannelSpecificFailurePgProvider(v ChannelSpecificFailurePgProvider) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelSpecificFailurePgProvider performs a merge with any union data inside the ChannelSpecificFailure, using the provided ChannelSpecificFailurePgProvider
func (t *ChannelSpecificFailure) MergeChannelSpecificFailurePgProvider(v ChannelSpecificFailurePgProvider) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChannelSpecificFailure) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ChannelSpecificFailure) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsChannelSpecificFailureInvalidRequest()
	case "PG_PROVIDER":
		return t.AsChannelSpecificFailurePgProvider()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ChannelSpecificFailure) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChannelSpecificFailure) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CloseVirtualAccountError as a ForbiddenError
func (t CloseVirtualAccountError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CloseVirtualAccountError as the provided ForbiddenError
func (t *CloseVirtualAccountError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CloseVirtualAccountError, using the provided ForbiddenError
func (t *CloseVirtualAccountError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CloseVirtualAccountError as a InvalidRequestError
func (t CloseVirtualAccountError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CloseVirtualAccountError as the provided InvalidRequestError
func (t *CloseVirtualAccountError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CloseVirtualAccountError, using the provided InvalidRequestError
func (t *CloseVirtualAccountError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the CloseVirtualAccountError as a PaymentNotFoundError
func (t CloseVirtualAccountError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the CloseVirtualAccountError as the provided PaymentNotFoundError
func (t *CloseVirtualAccountError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the CloseVirtualAccountError, using the provided PaymentNotFoundError
func (t *CloseVirtualAccountError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotWaitingForDepositError returns the union data inside the CloseVirtualAccountError as a PaymentNotWaitingForDepositError
func (t CloseVirtualAccountError) AsPaymentNotWaitingForDepositError() (PaymentNotWaitingForDepositError, error) {
	var body PaymentNotWaitingForDepositError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotWaitingForDepositError overwrites any union data inside the CloseVirtualAccountError as the provided PaymentNotWaitingForDepositError
func (t *CloseVirtualAccountError) FromPaymentNotWaitingForDepositError(v PaymentNotWaitingForDepositError) error {
	v.Type = "PAYMENT_NOT_WAITING_FOR_DEPOSIT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotWaitingForDepositError performs a merge with any union data inside the CloseVirtualAccountError, using the provided PaymentNotWaitingForDepositError
func (t *CloseVirtualAccountError) MergePaymentNotWaitingForDepositError(v PaymentNotWaitingForDepositError) error {
	v.Type = "PAYMENT_NOT_WAITING_FOR_DEPOSIT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the CloseVirtualAccountError as a PgProviderError
func (t CloseVirtualAccountError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the CloseVirtualAccountError as the provided PgProviderError
func (t *CloseVirtualAccountError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the CloseVirtualAccountError, using the provided PgProviderError
func (t *CloseVirtualAccountError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CloseVirtualAccountError as a UnauthorizedError
func (t CloseVirtualAccountError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CloseVirtualAccountError as the provided UnauthorizedError
func (t *CloseVirtualAccountError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CloseVirtualAccountError, using the provided UnauthorizedError
func (t *CloseVirtualAccountError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CloseVirtualAccountError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CloseVirtualAccountError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_WAITING_FOR_DEPOSIT":
		return t.AsPaymentNotWaitingForDepositError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CloseVirtualAccountError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CloseVirtualAccountError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyAlreadyIssuedError returns the union data inside the ConfirmBillingKeyError as a BillingKeyAlreadyIssuedError
func (t ConfirmBillingKeyError) AsBillingKeyAlreadyIssuedError() (BillingKeyAlreadyIssuedError, error) {
	var body BillingKeyAlreadyIssuedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyIssuedError overwrites any union data inside the ConfirmBillingKeyError as the provided BillingKeyAlreadyIssuedError
func (t *ConfirmBillingKeyError) FromBillingKeyAlreadyIssuedError(v BillingKeyAlreadyIssuedError) error {
	v.Type = "BILLING_KEY_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyIssuedError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided BillingKeyAlreadyIssuedError
func (t *ConfirmBillingKeyError) MergeBillingKeyAlreadyIssuedError(v BillingKeyAlreadyIssuedError) error {
	v.Type = "BILLING_KEY_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the ConfirmBillingKeyError as a BillingKeyNotFoundError
func (t ConfirmBillingKeyError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the ConfirmBillingKeyError as the provided BillingKeyNotFoundError
func (t *ConfirmBillingKeyError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided BillingKeyNotFoundError
func (t *ConfirmBillingKeyError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the ConfirmBillingKeyError as a ForbiddenError
func (t ConfirmBillingKeyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConfirmBillingKeyError as the provided ForbiddenError
func (t *ConfirmBillingKeyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided ForbiddenError
func (t *ConfirmBillingKeyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInformationMismatchError returns the union data inside the ConfirmBillingKeyError as a InformationMismatchError
func (t ConfirmBillingKeyError) AsInformationMismatchError() (InformationMismatchError, error) {
	var body InformationMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInformationMismatchError overwrites any union data inside the ConfirmBillingKeyError as the provided InformationMismatchError
func (t *ConfirmBillingKeyError) FromInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInformationMismatchError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided InformationMismatchError
func (t *ConfirmBillingKeyError) MergeInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConfirmBillingKeyError as a InvalidRequestError
func (t ConfirmBillingKeyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConfirmBillingKeyError as the provided InvalidRequestError
func (t *ConfirmBillingKeyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided InvalidRequestError
func (t *ConfirmBillingKeyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ConfirmBillingKeyError as a PgProviderError
func (t ConfirmBillingKeyError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ConfirmBillingKeyError as the provided PgProviderError
func (t *ConfirmBillingKeyError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided PgProviderError
func (t *ConfirmBillingKeyError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConfirmBillingKeyError as a UnauthorizedError
func (t ConfirmBillingKeyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConfirmBillingKeyError as the provided UnauthorizedError
func (t *ConfirmBillingKeyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConfirmBillingKeyError, using the provided UnauthorizedError
func (t *ConfirmBillingKeyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfirmBillingKeyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfirmBillingKeyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BILLING_KEY_ALREADY_ISSUED":
		return t.AsBillingKeyAlreadyIssuedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INFORMATION_MISMATCH":
		return t.AsInformationMismatchError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfirmBillingKeyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfirmBillingKeyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyAlreadyIssuedError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a BillingKeyAlreadyIssuedError
func (t ConfirmBillingKeyIssueAndPayError) AsBillingKeyAlreadyIssuedError() (BillingKeyAlreadyIssuedError, error) {
	var body BillingKeyAlreadyIssuedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyIssuedError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided BillingKeyAlreadyIssuedError
func (t *ConfirmBillingKeyIssueAndPayError) FromBillingKeyAlreadyIssuedError(v BillingKeyAlreadyIssuedError) error {
	v.Type = "BILLING_KEY_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyIssuedError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided BillingKeyAlreadyIssuedError
func (t *ConfirmBillingKeyIssueAndPayError) MergeBillingKeyAlreadyIssuedError(v BillingKeyAlreadyIssuedError) error {
	v.Type = "BILLING_KEY_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a BillingKeyNotFoundError
func (t ConfirmBillingKeyIssueAndPayError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided BillingKeyNotFoundError
func (t *ConfirmBillingKeyIssueAndPayError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided BillingKeyNotFoundError
func (t *ConfirmBillingKeyIssueAndPayError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a ForbiddenError
func (t ConfirmBillingKeyIssueAndPayError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided ForbiddenError
func (t *ConfirmBillingKeyIssueAndPayError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided ForbiddenError
func (t *ConfirmBillingKeyIssueAndPayError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInformationMismatchError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a InformationMismatchError
func (t ConfirmBillingKeyIssueAndPayError) AsInformationMismatchError() (InformationMismatchError, error) {
	var body InformationMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInformationMismatchError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided InformationMismatchError
func (t *ConfirmBillingKeyIssueAndPayError) FromInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInformationMismatchError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided InformationMismatchError
func (t *ConfirmBillingKeyIssueAndPayError) MergeInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a InvalidRequestError
func (t ConfirmBillingKeyIssueAndPayError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided InvalidRequestError
func (t *ConfirmBillingKeyIssueAndPayError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided InvalidRequestError
func (t *ConfirmBillingKeyIssueAndPayError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a PgProviderError
func (t ConfirmBillingKeyIssueAndPayError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided PgProviderError
func (t *ConfirmBillingKeyIssueAndPayError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided PgProviderError
func (t *ConfirmBillingKeyIssueAndPayError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConfirmBillingKeyIssueAndPayError as a UnauthorizedError
func (t ConfirmBillingKeyIssueAndPayError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConfirmBillingKeyIssueAndPayError as the provided UnauthorizedError
func (t *ConfirmBillingKeyIssueAndPayError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConfirmBillingKeyIssueAndPayError, using the provided UnauthorizedError
func (t *ConfirmBillingKeyIssueAndPayError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfirmBillingKeyIssueAndPayError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfirmBillingKeyIssueAndPayError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BILLING_KEY_ALREADY_ISSUED":
		return t.AsBillingKeyAlreadyIssuedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INFORMATION_MISMATCH":
		return t.AsInformationMismatchError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfirmBillingKeyIssueAndPayError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfirmBillingKeyIssueAndPayError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ConfirmEscrowError as a ForbiddenError
func (t ConfirmEscrowError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConfirmEscrowError as the provided ForbiddenError
func (t *ConfirmEscrowError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConfirmEscrowError, using the provided ForbiddenError
func (t *ConfirmEscrowError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConfirmEscrowError as a InvalidRequestError
func (t ConfirmEscrowError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConfirmEscrowError as the provided InvalidRequestError
func (t *ConfirmEscrowError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConfirmEscrowError, using the provided InvalidRequestError
func (t *ConfirmEscrowError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the ConfirmEscrowError as a PaymentNotFoundError
func (t ConfirmEscrowError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the ConfirmEscrowError as the provided PaymentNotFoundError
func (t *ConfirmEscrowError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the ConfirmEscrowError, using the provided PaymentNotFoundError
func (t *ConfirmEscrowError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the ConfirmEscrowError as a PaymentNotPaidError
func (t ConfirmEscrowError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the ConfirmEscrowError as the provided PaymentNotPaidError
func (t *ConfirmEscrowError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the ConfirmEscrowError, using the provided PaymentNotPaidError
func (t *ConfirmEscrowError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ConfirmEscrowError as a PgProviderError
func (t ConfirmEscrowError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ConfirmEscrowError as the provided PgProviderError
func (t *ConfirmEscrowError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ConfirmEscrowError, using the provided PgProviderError
func (t *ConfirmEscrowError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConfirmEscrowError as a UnauthorizedError
func (t ConfirmEscrowError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConfirmEscrowError as the provided UnauthorizedError
func (t *ConfirmEscrowError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConfirmEscrowError, using the provided UnauthorizedError
func (t *ConfirmEscrowError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfirmEscrowError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfirmEscrowError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfirmEscrowError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfirmEscrowError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ConfirmIdentityVerificationError as a ForbiddenError
func (t ConfirmIdentityVerificationError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConfirmIdentityVerificationError as the provided ForbiddenError
func (t *ConfirmIdentityVerificationError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided ForbiddenError
func (t *ConfirmIdentityVerificationError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationAlreadyVerifiedError returns the union data inside the ConfirmIdentityVerificationError as a IdentityVerificationAlreadyVerifiedError
func (t ConfirmIdentityVerificationError) AsIdentityVerificationAlreadyVerifiedError() (IdentityVerificationAlreadyVerifiedError, error) {
	var body IdentityVerificationAlreadyVerifiedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationAlreadyVerifiedError overwrites any union data inside the ConfirmIdentityVerificationError as the provided IdentityVerificationAlreadyVerifiedError
func (t *ConfirmIdentityVerificationError) FromIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationAlreadyVerifiedError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided IdentityVerificationAlreadyVerifiedError
func (t *ConfirmIdentityVerificationError) MergeIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotFoundError returns the union data inside the ConfirmIdentityVerificationError as a IdentityVerificationNotFoundError
func (t ConfirmIdentityVerificationError) AsIdentityVerificationNotFoundError() (IdentityVerificationNotFoundError, error) {
	var body IdentityVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotFoundError overwrites any union data inside the ConfirmIdentityVerificationError as the provided IdentityVerificationNotFoundError
func (t *ConfirmIdentityVerificationError) FromIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotFoundError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided IdentityVerificationNotFoundError
func (t *ConfirmIdentityVerificationError) MergeIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotSentError returns the union data inside the ConfirmIdentityVerificationError as a IdentityVerificationNotSentError
func (t ConfirmIdentityVerificationError) AsIdentityVerificationNotSentError() (IdentityVerificationNotSentError, error) {
	var body IdentityVerificationNotSentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotSentError overwrites any union data inside the ConfirmIdentityVerificationError as the provided IdentityVerificationNotSentError
func (t *ConfirmIdentityVerificationError) FromIdentityVerificationNotSentError(v IdentityVerificationNotSentError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_SENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotSentError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided IdentityVerificationNotSentError
func (t *ConfirmIdentityVerificationError) MergeIdentityVerificationNotSentError(v IdentityVerificationNotSentError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_SENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConfirmIdentityVerificationError as a InvalidRequestError
func (t ConfirmIdentityVerificationError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConfirmIdentityVerificationError as the provided InvalidRequestError
func (t *ConfirmIdentityVerificationError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided InvalidRequestError
func (t *ConfirmIdentityVerificationError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ConfirmIdentityVerificationError as a PgProviderError
func (t ConfirmIdentityVerificationError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ConfirmIdentityVerificationError as the provided PgProviderError
func (t *ConfirmIdentityVerificationError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided PgProviderError
func (t *ConfirmIdentityVerificationError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConfirmIdentityVerificationError as a UnauthorizedError
func (t ConfirmIdentityVerificationError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConfirmIdentityVerificationError as the provided UnauthorizedError
func (t *ConfirmIdentityVerificationError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConfirmIdentityVerificationError, using the provided UnauthorizedError
func (t *ConfirmIdentityVerificationError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfirmIdentityVerificationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfirmIdentityVerificationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "IDENTITY_VERIFICATION_ALREADY_VERIFIED":
		return t.AsIdentityVerificationAlreadyVerifiedError()
	case "IDENTITY_VERIFICATION_NOT_FOUND":
		return t.AsIdentityVerificationNotFoundError()
	case "IDENTITY_VERIFICATION_NOT_SENT":
		return t.AsIdentityVerificationNotSentError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfirmIdentityVerificationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfirmIdentityVerificationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlreadyPaidError returns the union data inside the ConfirmPaymentError as a AlreadyPaidError
func (t ConfirmPaymentError) AsAlreadyPaidError() (AlreadyPaidError, error) {
	var body AlreadyPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlreadyPaidError overwrites any union data inside the ConfirmPaymentError as the provided AlreadyPaidError
func (t *ConfirmPaymentError) FromAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlreadyPaidError performs a merge with any union data inside the ConfirmPaymentError, using the provided AlreadyPaidError
func (t *ConfirmPaymentError) MergeAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the ConfirmPaymentError as a ForbiddenError
func (t ConfirmPaymentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConfirmPaymentError as the provided ForbiddenError
func (t *ConfirmPaymentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConfirmPaymentError, using the provided ForbiddenError
func (t *ConfirmPaymentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInformationMismatchError returns the union data inside the ConfirmPaymentError as a InformationMismatchError
func (t ConfirmPaymentError) AsInformationMismatchError() (InformationMismatchError, error) {
	var body InformationMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInformationMismatchError overwrites any union data inside the ConfirmPaymentError as the provided InformationMismatchError
func (t *ConfirmPaymentError) FromInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInformationMismatchError performs a merge with any union data inside the ConfirmPaymentError, using the provided InformationMismatchError
func (t *ConfirmPaymentError) MergeInformationMismatchError(v InformationMismatchError) error {
	v.Type = "INFORMATION_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidPaymentTokenError returns the union data inside the ConfirmPaymentError as a InvalidPaymentTokenError
func (t ConfirmPaymentError) AsInvalidPaymentTokenError() (InvalidPaymentTokenError, error) {
	var body InvalidPaymentTokenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidPaymentTokenError overwrites any union data inside the ConfirmPaymentError as the provided InvalidPaymentTokenError
func (t *ConfirmPaymentError) FromInvalidPaymentTokenError(v InvalidPaymentTokenError) error {
	v.Type = "INVALID_PAYMENT_TOKEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidPaymentTokenError performs a merge with any union data inside the ConfirmPaymentError, using the provided InvalidPaymentTokenError
func (t *ConfirmPaymentError) MergeInvalidPaymentTokenError(v InvalidPaymentTokenError) error {
	v.Type = "INVALID_PAYMENT_TOKEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConfirmPaymentError as a InvalidRequestError
func (t ConfirmPaymentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConfirmPaymentError as the provided InvalidRequestError
func (t *ConfirmPaymentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConfirmPaymentError, using the provided InvalidRequestError
func (t *ConfirmPaymentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the ConfirmPaymentError as a PaymentNotFoundError
func (t ConfirmPaymentError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the ConfirmPaymentError as the provided PaymentNotFoundError
func (t *ConfirmPaymentError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the ConfirmPaymentError, using the provided PaymentNotFoundError
func (t *ConfirmPaymentError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ConfirmPaymentError as a PgProviderError
func (t ConfirmPaymentError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ConfirmPaymentError as the provided PgProviderError
func (t *ConfirmPaymentError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ConfirmPaymentError, using the provided PgProviderError
func (t *ConfirmPaymentError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConfirmPaymentError as a UnauthorizedError
func (t ConfirmPaymentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConfirmPaymentError as the provided UnauthorizedError
func (t *ConfirmPaymentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConfirmPaymentError, using the provided UnauthorizedError
func (t *ConfirmPaymentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfirmPaymentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfirmPaymentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ALREADY_PAID":
		return t.AsAlreadyPaidError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INFORMATION_MISMATCH":
		return t.AsInformationMismatchError()
	case "INVALID_PAYMENT_TOKEN":
		return t.AsInvalidPaymentTokenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfirmPaymentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfirmPaymentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a ForbiddenError
func (t ConnectBulkPartnerMemberCompanyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided ForbiddenError
func (t *ConnectBulkPartnerMemberCompanyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided ForbiddenError
func (t *ConnectBulkPartnerMemberCompanyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a InvalidRequestError
func (t ConnectBulkPartnerMemberCompanyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided InvalidRequestError
func (t *ConnectBulkPartnerMemberCompanyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided InvalidRequestError
func (t *ConnectBulkPartnerMemberCompanyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformBtxNotEnabledError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a PlatformBtxNotEnabledError
func (t ConnectBulkPartnerMemberCompanyError) AsPlatformBtxNotEnabledError() (PlatformBtxNotEnabledError, error) {
	var body PlatformBtxNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformBtxNotEnabledError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided PlatformBtxNotEnabledError
func (t *ConnectBulkPartnerMemberCompanyError) FromPlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformBtxNotEnabledError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided PlatformBtxNotEnabledError
func (t *ConnectBulkPartnerMemberCompanyError) MergePlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a PlatformExternalApiFailedError
func (t ConnectBulkPartnerMemberCompanyError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided PlatformExternalApiFailedError
func (t *ConnectBulkPartnerMemberCompanyError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided PlatformExternalApiFailedError
func (t *ConnectBulkPartnerMemberCompanyError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a PlatformNotEnabledError
func (t ConnectBulkPartnerMemberCompanyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided PlatformNotEnabledError
func (t *ConnectBulkPartnerMemberCompanyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided PlatformNotEnabledError
func (t *ConnectBulkPartnerMemberCompanyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a PlatformPartnerNotFoundError
func (t ConnectBulkPartnerMemberCompanyError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided PlatformPartnerNotFoundError
func (t *ConnectBulkPartnerMemberCompanyError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided PlatformPartnerNotFoundError
func (t *ConnectBulkPartnerMemberCompanyError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTargetPartnerNotFoundError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a PlatformTargetPartnerNotFoundError
func (t ConnectBulkPartnerMemberCompanyError) AsPlatformTargetPartnerNotFoundError() (PlatformTargetPartnerNotFoundError, error) {
	var body PlatformTargetPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTargetPartnerNotFoundError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided PlatformTargetPartnerNotFoundError
func (t *ConnectBulkPartnerMemberCompanyError) FromPlatformTargetPartnerNotFoundError(v PlatformTargetPartnerNotFoundError) error {
	v.Type = "PLATFORM_TARGET_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTargetPartnerNotFoundError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided PlatformTargetPartnerNotFoundError
func (t *ConnectBulkPartnerMemberCompanyError) MergePlatformTargetPartnerNotFoundError(v PlatformTargetPartnerNotFoundError) error {
	v.Type = "PLATFORM_TARGET_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConnectBulkPartnerMemberCompanyError as a UnauthorizedError
func (t ConnectBulkPartnerMemberCompanyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConnectBulkPartnerMemberCompanyError as the provided UnauthorizedError
func (t *ConnectBulkPartnerMemberCompanyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConnectBulkPartnerMemberCompanyError, using the provided UnauthorizedError
func (t *ConnectBulkPartnerMemberCompanyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConnectBulkPartnerMemberCompanyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConnectBulkPartnerMemberCompanyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_BTX_NOT_ENABLED":
		return t.AsPlatformBtxNotEnabledError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_TARGET_PARTNER_NOT_FOUND":
		return t.AsPlatformTargetPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConnectBulkPartnerMemberCompanyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConnectBulkPartnerMemberCompanyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ConnectPartnerMemberCompanyError as a ForbiddenError
func (t ConnectPartnerMemberCompanyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided ForbiddenError
func (t *ConnectPartnerMemberCompanyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided ForbiddenError
func (t *ConnectPartnerMemberCompanyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ConnectPartnerMemberCompanyError as a InvalidRequestError
func (t ConnectPartnerMemberCompanyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided InvalidRequestError
func (t *ConnectPartnerMemberCompanyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided InvalidRequestError
func (t *ConnectPartnerMemberCompanyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformBtxNotEnabledError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformBtxNotEnabledError
func (t ConnectPartnerMemberCompanyError) AsPlatformBtxNotEnabledError() (PlatformBtxNotEnabledError, error) {
	var body PlatformBtxNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformBtxNotEnabledError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformBtxNotEnabledError
func (t *ConnectPartnerMemberCompanyError) FromPlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformBtxNotEnabledError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformBtxNotEnabledError
func (t *ConnectPartnerMemberCompanyError) MergePlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformExternalApiFailedError
func (t ConnectPartnerMemberCompanyError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformExternalApiFailedError
func (t *ConnectPartnerMemberCompanyError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformExternalApiFailedError
func (t *ConnectPartnerMemberCompanyError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyNotConnectableStatusError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformMemberCompanyNotConnectableStatusError
func (t ConnectPartnerMemberCompanyError) AsPlatformMemberCompanyNotConnectableStatusError() (PlatformMemberCompanyNotConnectableStatusError, error) {
	var body PlatformMemberCompanyNotConnectableStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyNotConnectableStatusError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformMemberCompanyNotConnectableStatusError
func (t *ConnectPartnerMemberCompanyError) FromPlatformMemberCompanyNotConnectableStatusError(v PlatformMemberCompanyNotConnectableStatusError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_NOT_CONNECTABLE_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyNotConnectableStatusError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformMemberCompanyNotConnectableStatusError
func (t *ConnectPartnerMemberCompanyError) MergePlatformMemberCompanyNotConnectableStatusError(v PlatformMemberCompanyNotConnectableStatusError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_NOT_CONNECTABLE_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformNotEnabledError
func (t ConnectPartnerMemberCompanyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformNotEnabledError
func (t *ConnectPartnerMemberCompanyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformNotEnabledError
func (t *ConnectPartnerMemberCompanyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformPartnerNotFoundError
func (t ConnectPartnerMemberCompanyError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformPartnerNotFoundError
func (t *ConnectPartnerMemberCompanyError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformPartnerNotFoundError
func (t *ConnectPartnerMemberCompanyError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerScheduleExistsError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformPartnerScheduleExistsError
func (t ConnectPartnerMemberCompanyError) AsPlatformPartnerScheduleExistsError() (PlatformPartnerScheduleExistsError, error) {
	var body PlatformPartnerScheduleExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerScheduleExistsError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformPartnerScheduleExistsError
func (t *ConnectPartnerMemberCompanyError) FromPlatformPartnerScheduleExistsError(v PlatformPartnerScheduleExistsError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULE_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerScheduleExistsError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformPartnerScheduleExistsError
func (t *ConnectPartnerMemberCompanyError) MergePlatformPartnerScheduleExistsError(v PlatformPartnerScheduleExistsError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULE_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTaxationTypeIsSimpleError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformPartnerTaxationTypeIsSimpleError
func (t ConnectPartnerMemberCompanyError) AsPlatformPartnerTaxationTypeIsSimpleError() (PlatformPartnerTaxationTypeIsSimpleError, error) {
	var body PlatformPartnerTaxationTypeIsSimpleError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTaxationTypeIsSimpleError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformPartnerTaxationTypeIsSimpleError
func (t *ConnectPartnerMemberCompanyError) FromPlatformPartnerTaxationTypeIsSimpleError(v PlatformPartnerTaxationTypeIsSimpleError) error {
	v.Type = "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTaxationTypeIsSimpleError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformPartnerTaxationTypeIsSimpleError
func (t *ConnectPartnerMemberCompanyError) MergePlatformPartnerTaxationTypeIsSimpleError(v PlatformPartnerTaxationTypeIsSimpleError) error {
	v.Type = "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTypeIsNotBusinessError returns the union data inside the ConnectPartnerMemberCompanyError as a PlatformPartnerTypeIsNotBusinessError
func (t ConnectPartnerMemberCompanyError) AsPlatformPartnerTypeIsNotBusinessError() (PlatformPartnerTypeIsNotBusinessError, error) {
	var body PlatformPartnerTypeIsNotBusinessError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTypeIsNotBusinessError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided PlatformPartnerTypeIsNotBusinessError
func (t *ConnectPartnerMemberCompanyError) FromPlatformPartnerTypeIsNotBusinessError(v PlatformPartnerTypeIsNotBusinessError) error {
	v.Type = "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTypeIsNotBusinessError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided PlatformPartnerTypeIsNotBusinessError
func (t *ConnectPartnerMemberCompanyError) MergePlatformPartnerTypeIsNotBusinessError(v PlatformPartnerTypeIsNotBusinessError) error {
	v.Type = "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ConnectPartnerMemberCompanyError as a UnauthorizedError
func (t ConnectPartnerMemberCompanyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ConnectPartnerMemberCompanyError as the provided UnauthorizedError
func (t *ConnectPartnerMemberCompanyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ConnectPartnerMemberCompanyError, using the provided UnauthorizedError
func (t *ConnectPartnerMemberCompanyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConnectPartnerMemberCompanyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConnectPartnerMemberCompanyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_BTX_NOT_ENABLED":
		return t.AsPlatformBtxNotEnabledError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_MEMBER_COMPANY_NOT_CONNECTABLE_STATUS":
		return t.AsPlatformMemberCompanyNotConnectableStatusError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_PARTNER_SCHEDULE_EXISTS":
		return t.AsPlatformPartnerScheduleExistsError()
	case "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE":
		return t.AsPlatformPartnerTaxationTypeIsSimpleError()
	case "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS":
		return t.AsPlatformPartnerTypeIsNotBusinessError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConnectPartnerMemberCompanyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConnectPartnerMemberCompanyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the CreateB2bFileUploadUrlError as a B2bExternalServiceError
func (t CreateB2bFileUploadUrlError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the CreateB2bFileUploadUrlError as the provided B2bExternalServiceError
func (t *CreateB2bFileUploadUrlError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the CreateB2bFileUploadUrlError, using the provided B2bExternalServiceError
func (t *CreateB2bFileUploadUrlError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the CreateB2bFileUploadUrlError as a B2bNotEnabledError
func (t CreateB2bFileUploadUrlError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the CreateB2bFileUploadUrlError as the provided B2bNotEnabledError
func (t *CreateB2bFileUploadUrlError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the CreateB2bFileUploadUrlError, using the provided B2bNotEnabledError
func (t *CreateB2bFileUploadUrlError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CreateB2bFileUploadUrlError as a ForbiddenError
func (t CreateB2bFileUploadUrlError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreateB2bFileUploadUrlError as the provided ForbiddenError
func (t *CreateB2bFileUploadUrlError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreateB2bFileUploadUrlError, using the provided ForbiddenError
func (t *CreateB2bFileUploadUrlError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreateB2bFileUploadUrlError as a InvalidRequestError
func (t CreateB2bFileUploadUrlError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreateB2bFileUploadUrlError as the provided InvalidRequestError
func (t *CreateB2bFileUploadUrlError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreateB2bFileUploadUrlError, using the provided InvalidRequestError
func (t *CreateB2bFileUploadUrlError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreateB2bFileUploadUrlError as a UnauthorizedError
func (t CreateB2bFileUploadUrlError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreateB2bFileUploadUrlError as the provided UnauthorizedError
func (t *CreateB2bFileUploadUrlError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreateB2bFileUploadUrlError, using the provided UnauthorizedError
func (t *CreateB2bFileUploadUrlError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateB2bFileUploadUrlError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreateB2bFileUploadUrlError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreateB2bFileUploadUrlError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateB2bFileUploadUrlError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlreadyPaidOrWaitingError returns the union data inside the CreatePaymentScheduleError as a AlreadyPaidOrWaitingError
func (t CreatePaymentScheduleError) AsAlreadyPaidOrWaitingError() (AlreadyPaidOrWaitingError, error) {
	var body AlreadyPaidOrWaitingError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlreadyPaidOrWaitingError overwrites any union data inside the CreatePaymentScheduleError as the provided AlreadyPaidOrWaitingError
func (t *CreatePaymentScheduleError) FromAlreadyPaidOrWaitingError(v AlreadyPaidOrWaitingError) error {
	v.Type = "ALREADY_PAID_OR_WAITING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlreadyPaidOrWaitingError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided AlreadyPaidOrWaitingError
func (t *CreatePaymentScheduleError) MergeAlreadyPaidOrWaitingError(v AlreadyPaidOrWaitingError) error {
	v.Type = "ALREADY_PAID_OR_WAITING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyAlreadyDeletedError returns the union data inside the CreatePaymentScheduleError as a BillingKeyAlreadyDeletedError
func (t CreatePaymentScheduleError) AsBillingKeyAlreadyDeletedError() (BillingKeyAlreadyDeletedError, error) {
	var body BillingKeyAlreadyDeletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyDeletedError overwrites any union data inside the CreatePaymentScheduleError as the provided BillingKeyAlreadyDeletedError
func (t *CreatePaymentScheduleError) FromBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyDeletedError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided BillingKeyAlreadyDeletedError
func (t *CreatePaymentScheduleError) MergeBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the CreatePaymentScheduleError as a BillingKeyNotFoundError
func (t CreatePaymentScheduleError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the CreatePaymentScheduleError as the provided BillingKeyNotFoundError
func (t *CreatePaymentScheduleError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided BillingKeyNotFoundError
func (t *CreatePaymentScheduleError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the CreatePaymentScheduleError as a ForbiddenError
func (t CreatePaymentScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePaymentScheduleError as the provided ForbiddenError
func (t *CreatePaymentScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided ForbiddenError
func (t *CreatePaymentScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePaymentScheduleError as a InvalidRequestError
func (t CreatePaymentScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePaymentScheduleError as the provided InvalidRequestError
func (t *CreatePaymentScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided InvalidRequestError
func (t *CreatePaymentScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyExistsError returns the union data inside the CreatePaymentScheduleError as a PaymentScheduleAlreadyExistsError
func (t CreatePaymentScheduleError) AsPaymentScheduleAlreadyExistsError() (PaymentScheduleAlreadyExistsError, error) {
	var body PaymentScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyExistsError overwrites any union data inside the CreatePaymentScheduleError as the provided PaymentScheduleAlreadyExistsError
func (t *CreatePaymentScheduleError) FromPaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyExistsError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided PaymentScheduleAlreadyExistsError
func (t *CreatePaymentScheduleError) MergePaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSumOfPartsExceedsTotalAmountError returns the union data inside the CreatePaymentScheduleError as a SumOfPartsExceedsTotalAmountError
func (t CreatePaymentScheduleError) AsSumOfPartsExceedsTotalAmountError() (SumOfPartsExceedsTotalAmountError, error) {
	var body SumOfPartsExceedsTotalAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSumOfPartsExceedsTotalAmountError overwrites any union data inside the CreatePaymentScheduleError as the provided SumOfPartsExceedsTotalAmountError
func (t *CreatePaymentScheduleError) FromSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSumOfPartsExceedsTotalAmountError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided SumOfPartsExceedsTotalAmountError
func (t *CreatePaymentScheduleError) MergeSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePaymentScheduleError as a UnauthorizedError
func (t CreatePaymentScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePaymentScheduleError as the provided UnauthorizedError
func (t *CreatePaymentScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePaymentScheduleError, using the provided UnauthorizedError
func (t *CreatePaymentScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePaymentScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePaymentScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ALREADY_PAID_OR_WAITING":
		return t.AsAlreadyPaidOrWaitingError()
	case "BILLING_KEY_ALREADY_DELETED":
		return t.AsBillingKeyAlreadyDeletedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_SCHEDULE_ALREADY_EXISTS":
		return t.AsPaymentScheduleAlreadyExistsError()
	case "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT":
		return t.AsSumOfPartsExceedsTotalAmountError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePaymentScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePaymentScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformAdditionalFeePolicyError as a ForbiddenError
func (t CreatePlatformAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformAdditionalFeePolicyError as the provided ForbiddenError
func (t *CreatePlatformAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformAdditionalFeePolicyError, using the provided ForbiddenError
func (t *CreatePlatformAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformAdditionalFeePolicyError as a InvalidRequestError
func (t CreatePlatformAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformAdditionalFeePolicyError as the provided InvalidRequestError
func (t *CreatePlatformAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *CreatePlatformAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyAlreadyExistsError returns the union data inside the CreatePlatformAdditionalFeePolicyError as a PlatformAdditionalFeePolicyAlreadyExistsError
func (t CreatePlatformAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyAlreadyExistsError() (PlatformAdditionalFeePolicyAlreadyExistsError, error) {
	var body PlatformAdditionalFeePolicyAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyAlreadyExistsError overwrites any union data inside the CreatePlatformAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyAlreadyExistsError
func (t *CreatePlatformAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyAlreadyExistsError(v PlatformAdditionalFeePolicyAlreadyExistsError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyAlreadyExistsError performs a merge with any union data inside the CreatePlatformAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyAlreadyExistsError
func (t *CreatePlatformAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyAlreadyExistsError(v PlatformAdditionalFeePolicyAlreadyExistsError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformAdditionalFeePolicyError as a PlatformNotEnabledError
func (t CreatePlatformAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *CreatePlatformAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *CreatePlatformAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformAdditionalFeePolicyError as a UnauthorizedError
func (t CreatePlatformAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformAdditionalFeePolicyError as the provided UnauthorizedError
func (t *CreatePlatformAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *CreatePlatformAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_ALREADY_EXISTS":
		return t.AsPlatformAdditionalFeePolicyAlreadyExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformContractError as a ForbiddenError
func (t CreatePlatformContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformContractError as the provided ForbiddenError
func (t *CreatePlatformContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformContractError, using the provided ForbiddenError
func (t *CreatePlatformContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformContractError as a InvalidRequestError
func (t CreatePlatformContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformContractError as the provided InvalidRequestError
func (t *CreatePlatformContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformContractError, using the provided InvalidRequestError
func (t *CreatePlatformContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractAlreadyExistsError returns the union data inside the CreatePlatformContractError as a PlatformContractAlreadyExistsError
func (t CreatePlatformContractError) AsPlatformContractAlreadyExistsError() (PlatformContractAlreadyExistsError, error) {
	var body PlatformContractAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractAlreadyExistsError overwrites any union data inside the CreatePlatformContractError as the provided PlatformContractAlreadyExistsError
func (t *CreatePlatformContractError) FromPlatformContractAlreadyExistsError(v PlatformContractAlreadyExistsError) error {
	v.Type = "PLATFORM_CONTRACT_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractAlreadyExistsError performs a merge with any union data inside the CreatePlatformContractError, using the provided PlatformContractAlreadyExistsError
func (t *CreatePlatformContractError) MergePlatformContractAlreadyExistsError(v PlatformContractAlreadyExistsError) error {
	v.Type = "PLATFORM_CONTRACT_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformContractError as a PlatformNotEnabledError
func (t CreatePlatformContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformContractError as the provided PlatformNotEnabledError
func (t *CreatePlatformContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformContractError, using the provided PlatformNotEnabledError
func (t *CreatePlatformContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformContractError as a UnauthorizedError
func (t CreatePlatformContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformContractError as the provided UnauthorizedError
func (t *CreatePlatformContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformContractError, using the provided UnauthorizedError
func (t *CreatePlatformContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_ALREADY_EXISTS":
		return t.AsPlatformContractAlreadyExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformDiscountSharePolicyError as a ForbiddenError
func (t CreatePlatformDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformDiscountSharePolicyError as the provided ForbiddenError
func (t *CreatePlatformDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformDiscountSharePolicyError, using the provided ForbiddenError
func (t *CreatePlatformDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformDiscountSharePolicyError as a InvalidRequestError
func (t CreatePlatformDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformDiscountSharePolicyError as the provided InvalidRequestError
func (t *CreatePlatformDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformDiscountSharePolicyError, using the provided InvalidRequestError
func (t *CreatePlatformDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyAlreadyExistsError returns the union data inside the CreatePlatformDiscountSharePolicyError as a PlatformDiscountSharePolicyAlreadyExistsError
func (t CreatePlatformDiscountSharePolicyError) AsPlatformDiscountSharePolicyAlreadyExistsError() (PlatformDiscountSharePolicyAlreadyExistsError, error) {
	var body PlatformDiscountSharePolicyAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyAlreadyExistsError overwrites any union data inside the CreatePlatformDiscountSharePolicyError as the provided PlatformDiscountSharePolicyAlreadyExistsError
func (t *CreatePlatformDiscountSharePolicyError) FromPlatformDiscountSharePolicyAlreadyExistsError(v PlatformDiscountSharePolicyAlreadyExistsError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyAlreadyExistsError performs a merge with any union data inside the CreatePlatformDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyAlreadyExistsError
func (t *CreatePlatformDiscountSharePolicyError) MergePlatformDiscountSharePolicyAlreadyExistsError(v PlatformDiscountSharePolicyAlreadyExistsError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformDiscountSharePolicyError as a PlatformNotEnabledError
func (t CreatePlatformDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *CreatePlatformDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *CreatePlatformDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformDiscountSharePolicyError as a UnauthorizedError
func (t CreatePlatformDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformDiscountSharePolicyError as the provided UnauthorizedError
func (t *CreatePlatformDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformDiscountSharePolicyError, using the provided UnauthorizedError
func (t *CreatePlatformDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_ALREADY_EXISTS":
		return t.AsPlatformDiscountSharePolicyAlreadyExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformManualTransferError as a ForbiddenError
func (t CreatePlatformManualTransferError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformManualTransferError as the provided ForbiddenError
func (t *CreatePlatformManualTransferError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided ForbiddenError
func (t *CreatePlatformManualTransferError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformManualTransferError as a InvalidRequestError
func (t CreatePlatformManualTransferError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformManualTransferError as the provided InvalidRequestError
func (t *CreatePlatformManualTransferError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided InvalidRequestError
func (t *CreatePlatformManualTransferError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformManualTransferError as a PlatformNotEnabledError
func (t CreatePlatformManualTransferError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformManualTransferError as the provided PlatformNotEnabledError
func (t *CreatePlatformManualTransferError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided PlatformNotEnabledError
func (t *CreatePlatformManualTransferError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the CreatePlatformManualTransferError as a PlatformPartnerNotFoundError
func (t CreatePlatformManualTransferError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the CreatePlatformManualTransferError as the provided PlatformPartnerNotFoundError
func (t *CreatePlatformManualTransferError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided PlatformPartnerNotFoundError
func (t *CreatePlatformManualTransferError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the CreatePlatformManualTransferError as a PlatformUserDefinedPropertyNotFoundError
func (t CreatePlatformManualTransferError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the CreatePlatformManualTransferError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformManualTransferError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformManualTransferError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformManualTransferError as a UnauthorizedError
func (t CreatePlatformManualTransferError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformManualTransferError as the provided UnauthorizedError
func (t *CreatePlatformManualTransferError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformManualTransferError, using the provided UnauthorizedError
func (t *CreatePlatformManualTransferError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformManualTransferError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformManualTransferError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformManualTransferError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformManualTransferError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformOrderCancelTransferError as a ForbiddenError
func (t CreatePlatformOrderCancelTransferError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided ForbiddenError
func (t *CreatePlatformOrderCancelTransferError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided ForbiddenError
func (t *CreatePlatformOrderCancelTransferError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformOrderCancelTransferError as a InvalidRequestError
func (t CreatePlatformOrderCancelTransferError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided InvalidRequestError
func (t *CreatePlatformOrderCancelTransferError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided InvalidRequestError
func (t *CreatePlatformOrderCancelTransferError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellableAmountExceededError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellableAmountExceededError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellableAmountExceededError() (PlatformCancellableAmountExceededError, error) {
	var body PlatformCancellableAmountExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellableAmountExceededError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellableAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellableAmountExceededError(v PlatformCancellableAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellableAmountExceededError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellableAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellableAmountExceededError(v PlatformCancellableAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellableDiscountAmountExceededError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellableDiscountAmountExceededError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellableDiscountAmountExceededError() (PlatformCancellableDiscountAmountExceededError, error) {
	var body PlatformCancellableDiscountAmountExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellableDiscountAmountExceededError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellableDiscountAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellableDiscountAmountExceededError(v PlatformCancellableDiscountAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_DISCOUNT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellableDiscountAmountExceededError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellableDiscountAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellableDiscountAmountExceededError(v PlatformCancellableDiscountAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_DISCOUNT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellableDiscountTaxFreeAmountExceededError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellableDiscountTaxFreeAmountExceededError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellableDiscountTaxFreeAmountExceededError() (PlatformCancellableDiscountTaxFreeAmountExceededError, error) {
	var body PlatformCancellableDiscountTaxFreeAmountExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellableDiscountTaxFreeAmountExceededError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellableDiscountTaxFreeAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellableDiscountTaxFreeAmountExceededError(v PlatformCancellableDiscountTaxFreeAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_DISCOUNT_TAX_FREE_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellableDiscountTaxFreeAmountExceededError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellableDiscountTaxFreeAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellableDiscountTaxFreeAmountExceededError(v PlatformCancellableDiscountTaxFreeAmountExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_DISCOUNT_TAX_FREE_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellableProductQuantityExceededError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellableProductQuantityExceededError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellableProductQuantityExceededError() (PlatformCancellableProductQuantityExceededError, error) {
	var body PlatformCancellableProductQuantityExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellableProductQuantityExceededError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellableProductQuantityExceededError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellableProductQuantityExceededError(v PlatformCancellableProductQuantityExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_PRODUCT_QUANTITY_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellableProductQuantityExceededError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellableProductQuantityExceededError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellableProductQuantityExceededError(v PlatformCancellableProductQuantityExceededError) error {
	v.Type = "PLATFORM_CANCELLABLE_PRODUCT_QUANTITY_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellationAndPaymentTypeMismatchedError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellationAndPaymentTypeMismatchedError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellationAndPaymentTypeMismatchedError() (PlatformCancellationAndPaymentTypeMismatchedError, error) {
	var body PlatformCancellationAndPaymentTypeMismatchedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellationAndPaymentTypeMismatchedError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellationAndPaymentTypeMismatchedError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellationAndPaymentTypeMismatchedError(v PlatformCancellationAndPaymentTypeMismatchedError) error {
	v.Type = "PLATFORM_CANCELLATION_AND_PAYMENT_TYPE_MISMATCHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellationAndPaymentTypeMismatchedError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellationAndPaymentTypeMismatchedError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellationAndPaymentTypeMismatchedError(v PlatformCancellationAndPaymentTypeMismatchedError) error {
	v.Type = "PLATFORM_CANCELLATION_AND_PAYMENT_TYPE_MISMATCHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancellationNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCancellationNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCancellationNotFoundError() (PlatformCancellationNotFoundError, error) {
	var body PlatformCancellationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancellationNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCancellationNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCancellationNotFoundError(v PlatformCancellationNotFoundError) error {
	v.Type = "PLATFORM_CANCELLATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancellationNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCancellationNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCancellationNotFoundError(v PlatformCancellationNotFoundError) error {
	v.Type = "PLATFORM_CANCELLATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCannotSpecifyTransferError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformCannotSpecifyTransferError
func (t CreatePlatformOrderCancelTransferError) AsPlatformCannotSpecifyTransferError() (PlatformCannotSpecifyTransferError, error) {
	var body PlatformCannotSpecifyTransferError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCannotSpecifyTransferError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformCannotSpecifyTransferError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformCannotSpecifyTransferError(v PlatformCannotSpecifyTransferError) error {
	v.Type = "PLATFORM_CANNOT_SPECIFY_TRANSFER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCannotSpecifyTransferError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformCannotSpecifyTransferError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformCannotSpecifyTransferError(v PlatformCannotSpecifyTransferError) error {
	v.Type = "PLATFORM_CANNOT_SPECIFY_TRANSFER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyIdDuplicatedError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformDiscountSharePolicyIdDuplicatedError
func (t CreatePlatformOrderCancelTransferError) AsPlatformDiscountSharePolicyIdDuplicatedError() (PlatformDiscountSharePolicyIdDuplicatedError, error) {
	var body PlatformDiscountSharePolicyIdDuplicatedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyIdDuplicatedError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformDiscountSharePolicyIdDuplicatedError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformDiscountSharePolicyIdDuplicatedError(v PlatformDiscountSharePolicyIdDuplicatedError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_ID_DUPLICATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyIdDuplicatedError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformDiscountSharePolicyIdDuplicatedError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformDiscountSharePolicyIdDuplicatedError(v PlatformDiscountSharePolicyIdDuplicatedError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_ID_DUPLICATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformNotEnabledError
func (t CreatePlatformOrderCancelTransferError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformNotEnabledError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformNotEnabledError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderDetailMismatchedError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformOrderDetailMismatchedError
func (t CreatePlatformOrderCancelTransferError) AsPlatformOrderDetailMismatchedError() (PlatformOrderDetailMismatchedError, error) {
	var body PlatformOrderDetailMismatchedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderDetailMismatchedError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformOrderDetailMismatchedError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformOrderDetailMismatchedError(v PlatformOrderDetailMismatchedError) error {
	v.Type = "PLATFORM_ORDER_DETAIL_MISMATCHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderDetailMismatchedError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformOrderDetailMismatchedError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformOrderDetailMismatchedError(v PlatformOrderDetailMismatchedError) error {
	v.Type = "PLATFORM_ORDER_DETAIL_MISMATCHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderTransferAlreadyCancelledError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformOrderTransferAlreadyCancelledError
func (t CreatePlatformOrderCancelTransferError) AsPlatformOrderTransferAlreadyCancelledError() (PlatformOrderTransferAlreadyCancelledError, error) {
	var body PlatformOrderTransferAlreadyCancelledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderTransferAlreadyCancelledError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformOrderTransferAlreadyCancelledError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformOrderTransferAlreadyCancelledError(v PlatformOrderTransferAlreadyCancelledError) error {
	v.Type = "PLATFORM_ORDER_TRANSFER_ALREADY_CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderTransferAlreadyCancelledError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformOrderTransferAlreadyCancelledError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformOrderTransferAlreadyCancelledError(v PlatformOrderTransferAlreadyCancelledError) error {
	v.Type = "PLATFORM_ORDER_TRANSFER_ALREADY_CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformPaymentNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformPaymentNotFoundError() (PlatformPaymentNotFoundError, error) {
	var body PlatformPaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformPaymentNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformPaymentNotFoundError(v PlatformPaymentNotFoundError) error {
	v.Type = "PLATFORM_PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformPaymentNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformPaymentNotFoundError(v PlatformPaymentNotFoundError) error {
	v.Type = "PLATFORM_PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformProductIdDuplicatedError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformProductIdDuplicatedError
func (t CreatePlatformOrderCancelTransferError) AsPlatformProductIdDuplicatedError() (PlatformProductIdDuplicatedError, error) {
	var body PlatformProductIdDuplicatedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformProductIdDuplicatedError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformProductIdDuplicatedError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformProductIdDuplicatedError(v PlatformProductIdDuplicatedError) error {
	v.Type = "PLATFORM_PRODUCT_ID_DUPLICATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformProductIdDuplicatedError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformProductIdDuplicatedError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformProductIdDuplicatedError(v PlatformProductIdDuplicatedError) error {
	v.Type = "PLATFORM_PRODUCT_ID_DUPLICATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformProductIdNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformProductIdNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformProductIdNotFoundError() (PlatformProductIdNotFoundError, error) {
	var body PlatformProductIdNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformProductIdNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformProductIdNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformProductIdNotFoundError(v PlatformProductIdNotFoundError) error {
	v.Type = "PLATFORM_PRODUCT_ID_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformProductIdNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformProductIdNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformProductIdNotFoundError(v PlatformProductIdNotFoundError) error {
	v.Type = "PLATFORM_PRODUCT_ID_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementAmountExceededError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformSettlementAmountExceededError
func (t CreatePlatformOrderCancelTransferError) AsPlatformSettlementAmountExceededError() (PlatformSettlementAmountExceededError, error) {
	var body PlatformSettlementAmountExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementAmountExceededError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformSettlementAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformSettlementAmountExceededError(v PlatformSettlementAmountExceededError) error {
	v.Type = "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementAmountExceededError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformSettlementAmountExceededError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformSettlementAmountExceededError(v PlatformSettlementAmountExceededError) error {
	v.Type = "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementCancelAmountExceededPortOneCancelError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformSettlementCancelAmountExceededPortOneCancelError
func (t CreatePlatformOrderCancelTransferError) AsPlatformSettlementCancelAmountExceededPortOneCancelError() (PlatformSettlementCancelAmountExceededPortOneCancelError, error) {
	var body PlatformSettlementCancelAmountExceededPortOneCancelError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementCancelAmountExceededPortOneCancelError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformSettlementCancelAmountExceededPortOneCancelError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformSettlementCancelAmountExceededPortOneCancelError(v PlatformSettlementCancelAmountExceededPortOneCancelError) error {
	v.Type = "PLATFORM_SETTLEMENT_CANCEL_AMOUNT_EXCEEDED_PORT_ONE_CANCEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementCancelAmountExceededPortOneCancelError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformSettlementCancelAmountExceededPortOneCancelError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformSettlementCancelAmountExceededPortOneCancelError(v PlatformSettlementCancelAmountExceededPortOneCancelError) error {
	v.Type = "PLATFORM_SETTLEMENT_CANCEL_AMOUNT_EXCEEDED_PORT_ONE_CANCEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementDateEarlierThanSettlementStartDateError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformSettlementDateEarlierThanSettlementStartDateError
func (t CreatePlatformOrderCancelTransferError) AsPlatformSettlementDateEarlierThanSettlementStartDateError() (PlatformSettlementDateEarlierThanSettlementStartDateError, error) {
	var body PlatformSettlementDateEarlierThanSettlementStartDateError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementDateEarlierThanSettlementStartDateError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformSettlementDateEarlierThanSettlementStartDateError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformSettlementDateEarlierThanSettlementStartDateError(v PlatformSettlementDateEarlierThanSettlementStartDateError) error {
	v.Type = "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementDateEarlierThanSettlementStartDateError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformSettlementDateEarlierThanSettlementStartDateError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformSettlementDateEarlierThanSettlementStartDateError(v PlatformSettlementDateEarlierThanSettlementStartDateError) error {
	v.Type = "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferAlreadyExistsError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformTransferAlreadyExistsError
func (t CreatePlatformOrderCancelTransferError) AsPlatformTransferAlreadyExistsError() (PlatformTransferAlreadyExistsError, error) {
	var body PlatformTransferAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferAlreadyExistsError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformTransferAlreadyExistsError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformTransferAlreadyExistsError(v PlatformTransferAlreadyExistsError) error {
	v.Type = "PLATFORM_TRANSFER_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferAlreadyExistsError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformTransferAlreadyExistsError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformTransferAlreadyExistsError(v PlatformTransferAlreadyExistsError) error {
	v.Type = "PLATFORM_TRANSFER_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferDiscountSharePolicyNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformTransferDiscountSharePolicyNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformTransferDiscountSharePolicyNotFoundError() (PlatformTransferDiscountSharePolicyNotFoundError, error) {
	var body PlatformTransferDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferDiscountSharePolicyNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformTransferDiscountSharePolicyNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformTransferDiscountSharePolicyNotFoundError(v PlatformTransferDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferDiscountSharePolicyNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformTransferDiscountSharePolicyNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformTransferDiscountSharePolicyNotFoundError(v PlatformTransferDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformTransferNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformTransferNotFoundError() (PlatformTransferNotFoundError, error) {
	var body PlatformTransferNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformTransferNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformTransferNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the CreatePlatformOrderCancelTransferError as a PlatformUserDefinedPropertyNotFoundError
func (t CreatePlatformOrderCancelTransferError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformOrderCancelTransferError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformOrderCancelTransferError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformOrderCancelTransferError as a UnauthorizedError
func (t CreatePlatformOrderCancelTransferError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformOrderCancelTransferError as the provided UnauthorizedError
func (t *CreatePlatformOrderCancelTransferError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformOrderCancelTransferError, using the provided UnauthorizedError
func (t *CreatePlatformOrderCancelTransferError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformOrderCancelTransferError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformOrderCancelTransferError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CANCELLABLE_AMOUNT_EXCEEDED":
		return t.AsPlatformCancellableAmountExceededError()
	case "PLATFORM_CANCELLABLE_DISCOUNT_AMOUNT_EXCEEDED":
		return t.AsPlatformCancellableDiscountAmountExceededError()
	case "PLATFORM_CANCELLABLE_DISCOUNT_TAX_FREE_AMOUNT_EXCEEDED":
		return t.AsPlatformCancellableDiscountTaxFreeAmountExceededError()
	case "PLATFORM_CANCELLABLE_PRODUCT_QUANTITY_EXCEEDED":
		return t.AsPlatformCancellableProductQuantityExceededError()
	case "PLATFORM_CANCELLATION_AND_PAYMENT_TYPE_MISMATCHED":
		return t.AsPlatformCancellationAndPaymentTypeMismatchedError()
	case "PLATFORM_CANCELLATION_NOT_FOUND":
		return t.AsPlatformCancellationNotFoundError()
	case "PLATFORM_CANNOT_SPECIFY_TRANSFER":
		return t.AsPlatformCannotSpecifyTransferError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_ID_DUPLICATED":
		return t.AsPlatformDiscountSharePolicyIdDuplicatedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_ORDER_DETAIL_MISMATCHED":
		return t.AsPlatformOrderDetailMismatchedError()
	case "PLATFORM_ORDER_TRANSFER_ALREADY_CANCELLED":
		return t.AsPlatformOrderTransferAlreadyCancelledError()
	case "PLATFORM_PAYMENT_NOT_FOUND":
		return t.AsPlatformPaymentNotFoundError()
	case "PLATFORM_PRODUCT_ID_DUPLICATED":
		return t.AsPlatformProductIdDuplicatedError()
	case "PLATFORM_PRODUCT_ID_NOT_FOUND":
		return t.AsPlatformProductIdNotFoundError()
	case "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED":
		return t.AsPlatformSettlementAmountExceededError()
	case "PLATFORM_SETTLEMENT_CANCEL_AMOUNT_EXCEEDED_PORT_ONE_CANCEL":
		return t.AsPlatformSettlementCancelAmountExceededPortOneCancelError()
	case "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE":
		return t.AsPlatformSettlementDateEarlierThanSettlementStartDateError()
	case "PLATFORM_TRANSFER_ALREADY_EXISTS":
		return t.AsPlatformTransferAlreadyExistsError()
	case "PLATFORM_TRANSFER_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformTransferDiscountSharePolicyNotFoundError()
	case "PLATFORM_TRANSFER_NOT_FOUND":
		return t.AsPlatformTransferNotFoundError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformOrderCancelTransferError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformOrderCancelTransferError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformOrderTransferError as a ForbiddenError
func (t CreatePlatformOrderTransferError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformOrderTransferError as the provided ForbiddenError
func (t *CreatePlatformOrderTransferError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided ForbiddenError
func (t *CreatePlatformOrderTransferError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformOrderTransferError as a InvalidRequestError
func (t CreatePlatformOrderTransferError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformOrderTransferError as the provided InvalidRequestError
func (t *CreatePlatformOrderTransferError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided InvalidRequestError
func (t *CreatePlatformOrderTransferError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePoliciesNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformAdditionalFeePoliciesNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformAdditionalFeePoliciesNotFoundError() (PlatformAdditionalFeePoliciesNotFoundError, error) {
	var body PlatformAdditionalFeePoliciesNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePoliciesNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformAdditionalFeePoliciesNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformAdditionalFeePoliciesNotFoundError(v PlatformAdditionalFeePoliciesNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICIES_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePoliciesNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformAdditionalFeePoliciesNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformAdditionalFeePoliciesNotFoundError(v PlatformAdditionalFeePoliciesNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICIES_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError returns the union data inside the CreatePlatformOrderTransferError as a PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t CreatePlatformOrderTransferError) AsPlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError() (PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError, error) {
	var body PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t *CreatePlatformOrderTransferError) FromPlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError(v PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError) error {
	v.Type = "PLATFORM_ADDITIONAL_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t *CreatePlatformOrderTransferError) MergePlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError(v PlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError) error {
	v.Type = "PLATFORM_ADDITIONAL_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformContractNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformContractNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformContractNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError returns the union data inside the CreatePlatformOrderTransferError as a PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t CreatePlatformOrderTransferError) AsPlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError() (PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError, error) {
	var body PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t *CreatePlatformOrderTransferError) FromPlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError(v PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError) error {
	v.Type = "PLATFORM_CONTRACT_PLATFORM_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError
func (t *CreatePlatformOrderTransferError) MergePlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError(v PlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError) error {
	v.Type = "PLATFORM_CONTRACT_PLATFORM_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCurrencyNotSupportedError returns the union data inside the CreatePlatformOrderTransferError as a PlatformCurrencyNotSupportedError
func (t CreatePlatformOrderTransferError) AsPlatformCurrencyNotSupportedError() (PlatformCurrencyNotSupportedError, error) {
	var body PlatformCurrencyNotSupportedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCurrencyNotSupportedError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformOrderTransferError) FromPlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCurrencyNotSupportedError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformOrderTransferError) MergePlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePoliciesNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformDiscountSharePoliciesNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformDiscountSharePoliciesNotFoundError() (PlatformDiscountSharePoliciesNotFoundError, error) {
	var body PlatformDiscountSharePoliciesNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePoliciesNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformDiscountSharePoliciesNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformDiscountSharePoliciesNotFoundError(v PlatformDiscountSharePoliciesNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICIES_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePoliciesNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformDiscountSharePoliciesNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformDiscountSharePoliciesNotFoundError(v PlatformDiscountSharePoliciesNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICIES_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformOrderTransferError as a PlatformNotEnabledError
func (t CreatePlatformOrderTransferError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformNotEnabledError
func (t *CreatePlatformOrderTransferError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformNotEnabledError
func (t *CreatePlatformOrderTransferError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformPartnerNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformPartnerNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformPartnerNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformPaymentNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformPaymentNotFoundError() (PlatformPaymentNotFoundError, error) {
	var body PlatformPaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformPaymentNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformPaymentNotFoundError(v PlatformPaymentNotFoundError) error {
	v.Type = "PLATFORM_PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformPaymentNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformPaymentNotFoundError(v PlatformPaymentNotFoundError) error {
	v.Type = "PLATFORM_PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformProductIdDuplicatedError returns the union data inside the CreatePlatformOrderTransferError as a PlatformProductIdDuplicatedError
func (t CreatePlatformOrderTransferError) AsPlatformProductIdDuplicatedError() (PlatformProductIdDuplicatedError, error) {
	var body PlatformProductIdDuplicatedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformProductIdDuplicatedError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformProductIdDuplicatedError
func (t *CreatePlatformOrderTransferError) FromPlatformProductIdDuplicatedError(v PlatformProductIdDuplicatedError) error {
	v.Type = "PLATFORM_PRODUCT_ID_DUPLICATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformProductIdDuplicatedError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformProductIdDuplicatedError
func (t *CreatePlatformOrderTransferError) MergePlatformProductIdDuplicatedError(v PlatformProductIdDuplicatedError) error {
	v.Type = "PLATFORM_PRODUCT_ID_DUPLICATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementAmountExceededError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementAmountExceededError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementAmountExceededError() (PlatformSettlementAmountExceededError, error) {
	var body PlatformSettlementAmountExceededError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementAmountExceededError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementAmountExceededError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementAmountExceededError(v PlatformSettlementAmountExceededError) error {
	v.Type = "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementAmountExceededError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementAmountExceededError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementAmountExceededError(v PlatformSettlementAmountExceededError) error {
	v.Type = "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementDateEarlierThanSettlementStartDateError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementDateEarlierThanSettlementStartDateError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementDateEarlierThanSettlementStartDateError() (PlatformSettlementDateEarlierThanSettlementStartDateError, error) {
	var body PlatformSettlementDateEarlierThanSettlementStartDateError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementDateEarlierThanSettlementStartDateError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementDateEarlierThanSettlementStartDateError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementDateEarlierThanSettlementStartDateError(v PlatformSettlementDateEarlierThanSettlementStartDateError) error {
	v.Type = "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementDateEarlierThanSettlementStartDateError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementDateEarlierThanSettlementStartDateError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementDateEarlierThanSettlementStartDateError(v PlatformSettlementDateEarlierThanSettlementStartDateError) error {
	v.Type = "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementParameterNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementParameterNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementParameterNotFoundError() (PlatformSettlementParameterNotFoundError, error) {
	var body PlatformSettlementParameterNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementParameterNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementParameterNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementParameterNotFoundError(v PlatformSettlementParameterNotFoundError) error {
	v.Type = "PLATFORM_SETTLEMENT_PARAMETER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementParameterNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementParameterNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementParameterNotFoundError(v PlatformSettlementParameterNotFoundError) error {
	v.Type = "PLATFORM_SETTLEMENT_PARAMETER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementPaymentAmountExceededPortOnePaymentError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementPaymentAmountExceededPortOnePaymentError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementPaymentAmountExceededPortOnePaymentError() (PlatformSettlementPaymentAmountExceededPortOnePaymentError, error) {
	var body PlatformSettlementPaymentAmountExceededPortOnePaymentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementPaymentAmountExceededPortOnePaymentError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementPaymentAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementPaymentAmountExceededPortOnePaymentError(v PlatformSettlementPaymentAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_PAYMENT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementPaymentAmountExceededPortOnePaymentError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementPaymentAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementPaymentAmountExceededPortOnePaymentError(v PlatformSettlementPaymentAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_PAYMENT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError() (PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError, error) {
	var body PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError(v PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_SUPPLY_WITH_VAT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError(v PlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_SUPPLY_WITH_VAT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementTaxFreeAmountExceededPortOnePaymentError returns the union data inside the CreatePlatformOrderTransferError as a PlatformSettlementTaxFreeAmountExceededPortOnePaymentError
func (t CreatePlatformOrderTransferError) AsPlatformSettlementTaxFreeAmountExceededPortOnePaymentError() (PlatformSettlementTaxFreeAmountExceededPortOnePaymentError, error) {
	var body PlatformSettlementTaxFreeAmountExceededPortOnePaymentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementTaxFreeAmountExceededPortOnePaymentError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformSettlementTaxFreeAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) FromPlatformSettlementTaxFreeAmountExceededPortOnePaymentError(v PlatformSettlementTaxFreeAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_TAX_FREE_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementTaxFreeAmountExceededPortOnePaymentError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformSettlementTaxFreeAmountExceededPortOnePaymentError
func (t *CreatePlatformOrderTransferError) MergePlatformSettlementTaxFreeAmountExceededPortOnePaymentError(v PlatformSettlementTaxFreeAmountExceededPortOnePaymentError) error {
	v.Type = "PLATFORM_SETTLEMENT_TAX_FREE_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferAlreadyExistsError returns the union data inside the CreatePlatformOrderTransferError as a PlatformTransferAlreadyExistsError
func (t CreatePlatformOrderTransferError) AsPlatformTransferAlreadyExistsError() (PlatformTransferAlreadyExistsError, error) {
	var body PlatformTransferAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferAlreadyExistsError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformTransferAlreadyExistsError
func (t *CreatePlatformOrderTransferError) FromPlatformTransferAlreadyExistsError(v PlatformTransferAlreadyExistsError) error {
	v.Type = "PLATFORM_TRANSFER_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferAlreadyExistsError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformTransferAlreadyExistsError
func (t *CreatePlatformOrderTransferError) MergePlatformTransferAlreadyExistsError(v PlatformTransferAlreadyExistsError) error {
	v.Type = "PLATFORM_TRANSFER_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the CreatePlatformOrderTransferError as a PlatformUserDefinedPropertyNotFoundError
func (t CreatePlatformOrderTransferError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the CreatePlatformOrderTransferError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformOrderTransferError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformOrderTransferError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformOrderTransferError as a UnauthorizedError
func (t CreatePlatformOrderTransferError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformOrderTransferError as the provided UnauthorizedError
func (t *CreatePlatformOrderTransferError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformOrderTransferError, using the provided UnauthorizedError
func (t *CreatePlatformOrderTransferError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformOrderTransferError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformOrderTransferError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICIES_NOT_FOUND":
		return t.AsPlatformAdditionalFeePoliciesNotFoundError()
	case "PLATFORM_ADDITIONAL_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED":
		return t.AsPlatformAdditionalFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_CONTRACT_PLATFORM_FIXED_AMOUNT_FEE_CURRENCY_AND_SETTLEMENT_CURRENCY_MISMATCHED":
		return t.AsPlatformContractPlatformFixedAmountFeeCurrencyAndSettlementCurrencyMismatchedError()
	case "PLATFORM_CURRENCY_NOT_SUPPORTED":
		return t.AsPlatformCurrencyNotSupportedError()
	case "PLATFORM_DISCOUNT_SHARE_POLICIES_NOT_FOUND":
		return t.AsPlatformDiscountSharePoliciesNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_PAYMENT_NOT_FOUND":
		return t.AsPlatformPaymentNotFoundError()
	case "PLATFORM_PRODUCT_ID_DUPLICATED":
		return t.AsPlatformProductIdDuplicatedError()
	case "PLATFORM_SETTLEMENT_AMOUNT_EXCEEDED":
		return t.AsPlatformSettlementAmountExceededError()
	case "PLATFORM_SETTLEMENT_DATE_EARLIER_THAN_SETTLEMENT_START_DATE":
		return t.AsPlatformSettlementDateEarlierThanSettlementStartDateError()
	case "PLATFORM_SETTLEMENT_PARAMETER_NOT_FOUND":
		return t.AsPlatformSettlementParameterNotFoundError()
	case "PLATFORM_SETTLEMENT_PAYMENT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT":
		return t.AsPlatformSettlementPaymentAmountExceededPortOnePaymentError()
	case "PLATFORM_SETTLEMENT_SUPPLY_WITH_VAT_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT":
		return t.AsPlatformSettlementSupplyWithVatAmountExceededPortOnePaymentError()
	case "PLATFORM_SETTLEMENT_TAX_FREE_AMOUNT_EXCEEDED_PORT_ONE_PAYMENT":
		return t.AsPlatformSettlementTaxFreeAmountExceededPortOnePaymentError()
	case "PLATFORM_TRANSFER_ALREADY_EXISTS":
		return t.AsPlatformTransferAlreadyExistsError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformOrderTransferError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformOrderTransferError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformPartnerError as a ForbiddenError
func (t CreatePlatformPartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformPartnerError as the provided ForbiddenError
func (t *CreatePlatformPartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided ForbiddenError
func (t *CreatePlatformPartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformPartnerError as a InvalidRequestError
func (t CreatePlatformPartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformPartnerError as the provided InvalidRequestError
func (t *CreatePlatformPartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided InvalidRequestError
func (t *CreatePlatformPartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationAlreadyUsedError returns the union data inside the CreatePlatformPartnerError as a PlatformAccountVerificationAlreadyUsedError
func (t CreatePlatformPartnerError) AsPlatformAccountVerificationAlreadyUsedError() (PlatformAccountVerificationAlreadyUsedError, error) {
	var body PlatformAccountVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationAlreadyUsedError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformAccountVerificationAlreadyUsedError
func (t *CreatePlatformPartnerError) FromPlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationAlreadyUsedError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformAccountVerificationAlreadyUsedError
func (t *CreatePlatformPartnerError) MergePlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationFailedError returns the union data inside the CreatePlatformPartnerError as a PlatformAccountVerificationFailedError
func (t CreatePlatformPartnerError) AsPlatformAccountVerificationFailedError() (PlatformAccountVerificationFailedError, error) {
	var body PlatformAccountVerificationFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationFailedError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformAccountVerificationFailedError
func (t *CreatePlatformPartnerError) FromPlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationFailedError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformAccountVerificationFailedError
func (t *CreatePlatformPartnerError) MergePlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationNotFoundError returns the union data inside the CreatePlatformPartnerError as a PlatformAccountVerificationNotFoundError
func (t CreatePlatformPartnerError) AsPlatformAccountVerificationNotFoundError() (PlatformAccountVerificationNotFoundError, error) {
	var body PlatformAccountVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationNotFoundError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformAccountVerificationNotFoundError
func (t *CreatePlatformPartnerError) FromPlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationNotFoundError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformAccountVerificationNotFoundError
func (t *CreatePlatformPartnerError) MergePlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCompanyVerificationAlreadyUsedError returns the union data inside the CreatePlatformPartnerError as a PlatformCompanyVerificationAlreadyUsedError
func (t CreatePlatformPartnerError) AsPlatformCompanyVerificationAlreadyUsedError() (PlatformCompanyVerificationAlreadyUsedError, error) {
	var body PlatformCompanyVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCompanyVerificationAlreadyUsedError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformCompanyVerificationAlreadyUsedError
func (t *CreatePlatformPartnerError) FromPlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCompanyVerificationAlreadyUsedError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformCompanyVerificationAlreadyUsedError
func (t *CreatePlatformPartnerError) MergePlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the CreatePlatformPartnerError as a PlatformContractNotFoundError
func (t CreatePlatformPartnerError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformContractNotFoundError
func (t *CreatePlatformPartnerError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformContractNotFoundError
func (t *CreatePlatformPartnerError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCurrencyNotSupportedError returns the union data inside the CreatePlatformPartnerError as a PlatformCurrencyNotSupportedError
func (t CreatePlatformPartnerError) AsPlatformCurrencyNotSupportedError() (PlatformCurrencyNotSupportedError, error) {
	var body PlatformCurrencyNotSupportedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCurrencyNotSupportedError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformPartnerError) FromPlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCurrencyNotSupportedError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformPartnerError) MergePlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformPartnerError as a PlatformNotEnabledError
func (t CreatePlatformPartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformNotEnabledError
func (t *CreatePlatformPartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformNotEnabledError
func (t *CreatePlatformPartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerIdAlreadyExistsError returns the union data inside the CreatePlatformPartnerError as a PlatformPartnerIdAlreadyExistsError
func (t CreatePlatformPartnerError) AsPlatformPartnerIdAlreadyExistsError() (PlatformPartnerIdAlreadyExistsError, error) {
	var body PlatformPartnerIdAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerIdAlreadyExistsError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformPartnerIdAlreadyExistsError
func (t *CreatePlatformPartnerError) FromPlatformPartnerIdAlreadyExistsError(v PlatformPartnerIdAlreadyExistsError) error {
	v.Type = "PLATFORM_PARTNER_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerIdAlreadyExistsError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformPartnerIdAlreadyExistsError
func (t *CreatePlatformPartnerError) MergePlatformPartnerIdAlreadyExistsError(v PlatformPartnerIdAlreadyExistsError) error {
	v.Type = "PLATFORM_PARTNER_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the CreatePlatformPartnerError as a PlatformUserDefinedPropertyNotFoundError
func (t CreatePlatformPartnerError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the CreatePlatformPartnerError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformPartnerError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformPartnerError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformPartnerError as a UnauthorizedError
func (t CreatePlatformPartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformPartnerError as the provided UnauthorizedError
func (t *CreatePlatformPartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformPartnerError, using the provided UnauthorizedError
func (t *CreatePlatformPartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformPartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformPartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED":
		return t.AsPlatformAccountVerificationAlreadyUsedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_FAILED":
		return t.AsPlatformAccountVerificationFailedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND":
		return t.AsPlatformAccountVerificationNotFoundError()
	case "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED":
		return t.AsPlatformCompanyVerificationAlreadyUsedError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_CURRENCY_NOT_SUPPORTED":
		return t.AsPlatformCurrencyNotSupportedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_ID_ALREADY_EXISTS":
		return t.AsPlatformPartnerIdAlreadyExistsError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformPartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformPartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the CreatePlatformPartnersError as a ForbiddenError
func (t CreatePlatformPartnersError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the CreatePlatformPartnersError as the provided ForbiddenError
func (t *CreatePlatformPartnersError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided ForbiddenError
func (t *CreatePlatformPartnersError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the CreatePlatformPartnersError as a InvalidRequestError
func (t CreatePlatformPartnersError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the CreatePlatformPartnersError as the provided InvalidRequestError
func (t *CreatePlatformPartnersError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided InvalidRequestError
func (t *CreatePlatformPartnersError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractsNotFoundError returns the union data inside the CreatePlatformPartnersError as a PlatformContractsNotFoundError
func (t CreatePlatformPartnersError) AsPlatformContractsNotFoundError() (PlatformContractsNotFoundError, error) {
	var body PlatformContractsNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractsNotFoundError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformContractsNotFoundError
func (t *CreatePlatformPartnersError) FromPlatformContractsNotFoundError(v PlatformContractsNotFoundError) error {
	v.Type = "PLATFORM_CONTRACTS_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractsNotFoundError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformContractsNotFoundError
func (t *CreatePlatformPartnersError) MergePlatformContractsNotFoundError(v PlatformContractsNotFoundError) error {
	v.Type = "PLATFORM_CONTRACTS_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCurrencyNotSupportedError returns the union data inside the CreatePlatformPartnersError as a PlatformCurrencyNotSupportedError
func (t CreatePlatformPartnersError) AsPlatformCurrencyNotSupportedError() (PlatformCurrencyNotSupportedError, error) {
	var body PlatformCurrencyNotSupportedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCurrencyNotSupportedError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformPartnersError) FromPlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCurrencyNotSupportedError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformCurrencyNotSupportedError
func (t *CreatePlatformPartnersError) MergePlatformCurrencyNotSupportedError(v PlatformCurrencyNotSupportedError) error {
	v.Type = "PLATFORM_CURRENCY_NOT_SUPPORTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the CreatePlatformPartnersError as a PlatformNotEnabledError
func (t CreatePlatformPartnersError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformNotEnabledError
func (t *CreatePlatformPartnersError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformNotEnabledError
func (t *CreatePlatformPartnersError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerIdsAlreadyExistError returns the union data inside the CreatePlatformPartnersError as a PlatformPartnerIdsAlreadyExistError
func (t CreatePlatformPartnersError) AsPlatformPartnerIdsAlreadyExistError() (PlatformPartnerIdsAlreadyExistError, error) {
	var body PlatformPartnerIdsAlreadyExistError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerIdsAlreadyExistError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformPartnerIdsAlreadyExistError
func (t *CreatePlatformPartnersError) FromPlatformPartnerIdsAlreadyExistError(v PlatformPartnerIdsAlreadyExistError) error {
	v.Type = "PLATFORM_PARTNER_IDS_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerIdsAlreadyExistError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformPartnerIdsAlreadyExistError
func (t *CreatePlatformPartnersError) MergePlatformPartnerIdsAlreadyExistError(v PlatformPartnerIdsAlreadyExistError) error {
	v.Type = "PLATFORM_PARTNER_IDS_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerIdsDuplicatedError returns the union data inside the CreatePlatformPartnersError as a PlatformPartnerIdsDuplicatedError
func (t CreatePlatformPartnersError) AsPlatformPartnerIdsDuplicatedError() (PlatformPartnerIdsDuplicatedError, error) {
	var body PlatformPartnerIdsDuplicatedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerIdsDuplicatedError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformPartnerIdsDuplicatedError
func (t *CreatePlatformPartnersError) FromPlatformPartnerIdsDuplicatedError(v PlatformPartnerIdsDuplicatedError) error {
	v.Type = "PLATFORM_PARTNER_IDS_DUPLICATED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerIdsDuplicatedError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformPartnerIdsDuplicatedError
func (t *CreatePlatformPartnersError) MergePlatformPartnerIdsDuplicatedError(v PlatformPartnerIdsDuplicatedError) error {
	v.Type = "PLATFORM_PARTNER_IDS_DUPLICATED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the CreatePlatformPartnersError as a PlatformUserDefinedPropertyNotFoundError
func (t CreatePlatformPartnersError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the CreatePlatformPartnersError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformPartnersError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *CreatePlatformPartnersError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the CreatePlatformPartnersError as a UnauthorizedError
func (t CreatePlatformPartnersError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the CreatePlatformPartnersError as the provided UnauthorizedError
func (t *CreatePlatformPartnersError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the CreatePlatformPartnersError, using the provided UnauthorizedError
func (t *CreatePlatformPartnersError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePlatformPartnersError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreatePlatformPartnersError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACTS_NOT_FOUND":
		return t.AsPlatformContractsNotFoundError()
	case "PLATFORM_CURRENCY_NOT_SUPPORTED":
		return t.AsPlatformCurrencyNotSupportedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_IDS_ALREADY_EXISTS":
		return t.AsPlatformPartnerIdsAlreadyExistError()
	case "PLATFORM_PARTNER_IDS_DUPLICATED":
		return t.AsPlatformPartnerIdsDuplicatedError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreatePlatformPartnersError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePlatformPartnersError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a B2bExternalServiceError
func (t DeleteB2bTaxInvoiceAttachmentError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided B2bExternalServiceError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided B2bExternalServiceError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a B2bNotEnabledError
func (t DeleteB2bTaxInvoiceAttachmentError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided B2bNotEnabledError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided B2bNotEnabledError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceAttachmentNotFoundError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a B2bTaxInvoiceAttachmentNotFoundError
func (t DeleteB2bTaxInvoiceAttachmentError) AsB2bTaxInvoiceAttachmentNotFoundError() (B2bTaxInvoiceAttachmentNotFoundError, error) {
	var body B2bTaxInvoiceAttachmentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceAttachmentNotFoundError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided B2bTaxInvoiceAttachmentNotFoundError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromB2bTaxInvoiceAttachmentNotFoundError(v B2bTaxInvoiceAttachmentNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_ATTACHMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceAttachmentNotFoundError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided B2bTaxInvoiceAttachmentNotFoundError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeB2bTaxInvoiceAttachmentNotFoundError(v B2bTaxInvoiceAttachmentNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_ATTACHMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotDraftedStatusError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a B2bTaxInvoiceNotDraftedStatusError
func (t DeleteB2bTaxInvoiceAttachmentError) AsB2bTaxInvoiceNotDraftedStatusError() (B2bTaxInvoiceNotDraftedStatusError, error) {
	var body B2bTaxInvoiceNotDraftedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotDraftedStatusError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided B2bTaxInvoiceNotDraftedStatusError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotDraftedStatusError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided B2bTaxInvoiceNotDraftedStatusError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a B2bTaxInvoiceNotFoundError
func (t DeleteB2bTaxInvoiceAttachmentError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided B2bTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided B2bTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a ForbiddenError
func (t DeleteB2bTaxInvoiceAttachmentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided ForbiddenError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided ForbiddenError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a InvalidRequestError
func (t DeleteB2bTaxInvoiceAttachmentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided InvalidRequestError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided InvalidRequestError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DeleteB2bTaxInvoiceAttachmentError as a UnauthorizedError
func (t DeleteB2bTaxInvoiceAttachmentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DeleteB2bTaxInvoiceAttachmentError as the provided UnauthorizedError
func (t *DeleteB2bTaxInvoiceAttachmentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DeleteB2bTaxInvoiceAttachmentError, using the provided UnauthorizedError
func (t *DeleteB2bTaxInvoiceAttachmentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeleteB2bTaxInvoiceAttachmentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DeleteB2bTaxInvoiceAttachmentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_ATTACHMENT_NOT_FOUND":
		return t.AsB2bTaxInvoiceAttachmentNotFoundError()
	case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
		return t.AsB2bTaxInvoiceNotDraftedStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DeleteB2bTaxInvoiceAttachmentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeleteB2bTaxInvoiceAttachmentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bBulkTaxInvoiceNotFoundError returns the union data inside the DeleteB2bTaxInvoiceError as a B2bBulkTaxInvoiceNotFoundError
func (t DeleteB2bTaxInvoiceError) AsB2bBulkTaxInvoiceNotFoundError() (B2bBulkTaxInvoiceNotFoundError, error) {
	var body B2bBulkTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bBulkTaxInvoiceNotFoundError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided B2bBulkTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceError) FromB2bBulkTaxInvoiceNotFoundError(v B2bBulkTaxInvoiceNotFoundError) error {
	v.Type = "B2B_BULK_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bBulkTaxInvoiceNotFoundError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided B2bBulkTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceError) MergeB2bBulkTaxInvoiceNotFoundError(v B2bBulkTaxInvoiceNotFoundError) error {
	v.Type = "B2B_BULK_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the DeleteB2bTaxInvoiceError as a B2bExternalServiceError
func (t DeleteB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *DeleteB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *DeleteB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the DeleteB2bTaxInvoiceError as a B2bNotEnabledError
func (t DeleteB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *DeleteB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *DeleteB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNonDeletableStatusError returns the union data inside the DeleteB2bTaxInvoiceError as a B2bTaxInvoiceNonDeletableStatusError
func (t DeleteB2bTaxInvoiceError) AsB2bTaxInvoiceNonDeletableStatusError() (B2bTaxInvoiceNonDeletableStatusError, error) {
	var body B2bTaxInvoiceNonDeletableStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNonDeletableStatusError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided B2bTaxInvoiceNonDeletableStatusError
func (t *DeleteB2bTaxInvoiceError) FromB2bTaxInvoiceNonDeletableStatusError(v B2bTaxInvoiceNonDeletableStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NON_DELETABLE_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNonDeletableStatusError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided B2bTaxInvoiceNonDeletableStatusError
func (t *DeleteB2bTaxInvoiceError) MergeB2bTaxInvoiceNonDeletableStatusError(v B2bTaxInvoiceNonDeletableStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NON_DELETABLE_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the DeleteB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t DeleteB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *DeleteB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the DeleteB2bTaxInvoiceError as a ForbiddenError
func (t DeleteB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided ForbiddenError
func (t *DeleteB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided ForbiddenError
func (t *DeleteB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DeleteB2bTaxInvoiceError as a InvalidRequestError
func (t DeleteB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided InvalidRequestError
func (t *DeleteB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *DeleteB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DeleteB2bTaxInvoiceError as a UnauthorizedError
func (t DeleteB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DeleteB2bTaxInvoiceError as the provided UnauthorizedError
func (t *DeleteB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DeleteB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *DeleteB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeleteB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DeleteB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_BULK_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bBulkTaxInvoiceNotFoundError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NON_DELETABLE_STATUS":
		return t.AsB2bTaxInvoiceNonDeletableStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DeleteB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeleteB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyAlreadyDeletedError returns the union data inside the DeleteBillingKeyError as a BillingKeyAlreadyDeletedError
func (t DeleteBillingKeyError) AsBillingKeyAlreadyDeletedError() (BillingKeyAlreadyDeletedError, error) {
	var body BillingKeyAlreadyDeletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyDeletedError overwrites any union data inside the DeleteBillingKeyError as the provided BillingKeyAlreadyDeletedError
func (t *DeleteBillingKeyError) FromBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyDeletedError performs a merge with any union data inside the DeleteBillingKeyError, using the provided BillingKeyAlreadyDeletedError
func (t *DeleteBillingKeyError) MergeBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the DeleteBillingKeyError as a BillingKeyNotFoundError
func (t DeleteBillingKeyError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the DeleteBillingKeyError as the provided BillingKeyNotFoundError
func (t *DeleteBillingKeyError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the DeleteBillingKeyError, using the provided BillingKeyNotFoundError
func (t *DeleteBillingKeyError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotIssuedError returns the union data inside the DeleteBillingKeyError as a BillingKeyNotIssuedError
func (t DeleteBillingKeyError) AsBillingKeyNotIssuedError() (BillingKeyNotIssuedError, error) {
	var body BillingKeyNotIssuedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotIssuedError overwrites any union data inside the DeleteBillingKeyError as the provided BillingKeyNotIssuedError
func (t *DeleteBillingKeyError) FromBillingKeyNotIssuedError(v BillingKeyNotIssuedError) error {
	v.Type = "BILLING_KEY_NOT_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotIssuedError performs a merge with any union data inside the DeleteBillingKeyError, using the provided BillingKeyNotIssuedError
func (t *DeleteBillingKeyError) MergeBillingKeyNotIssuedError(v BillingKeyNotIssuedError) error {
	v.Type = "BILLING_KEY_NOT_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelSpecificError returns the union data inside the DeleteBillingKeyError as a ChannelSpecificError
func (t DeleteBillingKeyError) AsChannelSpecificError() (ChannelSpecificError, error) {
	var body ChannelSpecificError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelSpecificError overwrites any union data inside the DeleteBillingKeyError as the provided ChannelSpecificError
func (t *DeleteBillingKeyError) FromChannelSpecificError(v ChannelSpecificError) error {
	v.Type = "CHANNEL_SPECIFIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelSpecificError performs a merge with any union data inside the DeleteBillingKeyError, using the provided ChannelSpecificError
func (t *DeleteBillingKeyError) MergeChannelSpecificError(v ChannelSpecificError) error {
	v.Type = "CHANNEL_SPECIFIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the DeleteBillingKeyError as a ForbiddenError
func (t DeleteBillingKeyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DeleteBillingKeyError as the provided ForbiddenError
func (t *DeleteBillingKeyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DeleteBillingKeyError, using the provided ForbiddenError
func (t *DeleteBillingKeyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DeleteBillingKeyError as a InvalidRequestError
func (t DeleteBillingKeyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DeleteBillingKeyError as the provided InvalidRequestError
func (t *DeleteBillingKeyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DeleteBillingKeyError, using the provided InvalidRequestError
func (t *DeleteBillingKeyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyExistsError returns the union data inside the DeleteBillingKeyError as a PaymentScheduleAlreadyExistsError
func (t DeleteBillingKeyError) AsPaymentScheduleAlreadyExistsError() (PaymentScheduleAlreadyExistsError, error) {
	var body PaymentScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyExistsError overwrites any union data inside the DeleteBillingKeyError as the provided PaymentScheduleAlreadyExistsError
func (t *DeleteBillingKeyError) FromPaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyExistsError performs a merge with any union data inside the DeleteBillingKeyError, using the provided PaymentScheduleAlreadyExistsError
func (t *DeleteBillingKeyError) MergePaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the DeleteBillingKeyError as a PgProviderError
func (t DeleteBillingKeyError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the DeleteBillingKeyError as the provided PgProviderError
func (t *DeleteBillingKeyError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the DeleteBillingKeyError, using the provided PgProviderError
func (t *DeleteBillingKeyError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DeleteBillingKeyError as a UnauthorizedError
func (t DeleteBillingKeyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DeleteBillingKeyError as the provided UnauthorizedError
func (t *DeleteBillingKeyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DeleteBillingKeyError, using the provided UnauthorizedError
func (t *DeleteBillingKeyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeleteBillingKeyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DeleteBillingKeyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BILLING_KEY_ALREADY_DELETED":
		return t.AsBillingKeyAlreadyDeletedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "BILLING_KEY_NOT_ISSUED":
		return t.AsBillingKeyNotIssuedError()
	case "CHANNEL_SPECIFIC":
		return t.AsChannelSpecificError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_SCHEDULE_ALREADY_EXISTS":
		return t.AsPaymentScheduleAlreadyExistsError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DeleteBillingKeyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeleteBillingKeyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the DeletePlatformTransferError as a ForbiddenError
func (t DeletePlatformTransferError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DeletePlatformTransferError as the provided ForbiddenError
func (t *DeletePlatformTransferError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DeletePlatformTransferError, using the provided ForbiddenError
func (t *DeletePlatformTransferError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DeletePlatformTransferError as a InvalidRequestError
func (t DeletePlatformTransferError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DeletePlatformTransferError as the provided InvalidRequestError
func (t *DeletePlatformTransferError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DeletePlatformTransferError, using the provided InvalidRequestError
func (t *DeletePlatformTransferError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCancelOrderTransfersExistsError returns the union data inside the DeletePlatformTransferError as a PlatformCancelOrderTransfersExistsError
func (t DeletePlatformTransferError) AsPlatformCancelOrderTransfersExistsError() (PlatformCancelOrderTransfersExistsError, error) {
	var body PlatformCancelOrderTransfersExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCancelOrderTransfersExistsError overwrites any union data inside the DeletePlatformTransferError as the provided PlatformCancelOrderTransfersExistsError
func (t *DeletePlatformTransferError) FromPlatformCancelOrderTransfersExistsError(v PlatformCancelOrderTransfersExistsError) error {
	v.Type = "PLATFORM_CANCEL_ORDER_TRANSFERS_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCancelOrderTransfersExistsError performs a merge with any union data inside the DeletePlatformTransferError, using the provided PlatformCancelOrderTransfersExistsError
func (t *DeletePlatformTransferError) MergePlatformCancelOrderTransfersExistsError(v PlatformCancelOrderTransfersExistsError) error {
	v.Type = "PLATFORM_CANCEL_ORDER_TRANSFERS_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the DeletePlatformTransferError as a PlatformNotEnabledError
func (t DeletePlatformTransferError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the DeletePlatformTransferError as the provided PlatformNotEnabledError
func (t *DeletePlatformTransferError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the DeletePlatformTransferError, using the provided PlatformNotEnabledError
func (t *DeletePlatformTransferError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferNonDeletableStatusError returns the union data inside the DeletePlatformTransferError as a PlatformTransferNonDeletableStatusError
func (t DeletePlatformTransferError) AsPlatformTransferNonDeletableStatusError() (PlatformTransferNonDeletableStatusError, error) {
	var body PlatformTransferNonDeletableStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferNonDeletableStatusError overwrites any union data inside the DeletePlatformTransferError as the provided PlatformTransferNonDeletableStatusError
func (t *DeletePlatformTransferError) FromPlatformTransferNonDeletableStatusError(v PlatformTransferNonDeletableStatusError) error {
	v.Type = "PLATFORM_TRANSFER_NON_DELETABLE_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferNonDeletableStatusError performs a merge with any union data inside the DeletePlatformTransferError, using the provided PlatformTransferNonDeletableStatusError
func (t *DeletePlatformTransferError) MergePlatformTransferNonDeletableStatusError(v PlatformTransferNonDeletableStatusError) error {
	v.Type = "PLATFORM_TRANSFER_NON_DELETABLE_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferNotFoundError returns the union data inside the DeletePlatformTransferError as a PlatformTransferNotFoundError
func (t DeletePlatformTransferError) AsPlatformTransferNotFoundError() (PlatformTransferNotFoundError, error) {
	var body PlatformTransferNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferNotFoundError overwrites any union data inside the DeletePlatformTransferError as the provided PlatformTransferNotFoundError
func (t *DeletePlatformTransferError) FromPlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferNotFoundError performs a merge with any union data inside the DeletePlatformTransferError, using the provided PlatformTransferNotFoundError
func (t *DeletePlatformTransferError) MergePlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DeletePlatformTransferError as a UnauthorizedError
func (t DeletePlatformTransferError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DeletePlatformTransferError as the provided UnauthorizedError
func (t *DeletePlatformTransferError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DeletePlatformTransferError, using the provided UnauthorizedError
func (t *DeletePlatformTransferError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeletePlatformTransferError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DeletePlatformTransferError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CANCEL_ORDER_TRANSFERS_EXISTS":
		return t.AsPlatformCancelOrderTransfersExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_TRANSFER_NON_DELETABLE_STATUS":
		return t.AsPlatformTransferNonDeletableStatusError()
	case "PLATFORM_TRANSFER_NOT_FOUND":
		return t.AsPlatformTransferNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DeletePlatformTransferError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeletePlatformTransferError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a ForbiddenError
func (t DisconnectBulkPartnerMemberCompanyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided ForbiddenError
func (t *DisconnectBulkPartnerMemberCompanyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided ForbiddenError
func (t *DisconnectBulkPartnerMemberCompanyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a InvalidRequestError
func (t DisconnectBulkPartnerMemberCompanyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided InvalidRequestError
func (t *DisconnectBulkPartnerMemberCompanyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided InvalidRequestError
func (t *DisconnectBulkPartnerMemberCompanyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformBtxNotEnabledError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a PlatformBtxNotEnabledError
func (t DisconnectBulkPartnerMemberCompanyError) AsPlatformBtxNotEnabledError() (PlatformBtxNotEnabledError, error) {
	var body PlatformBtxNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformBtxNotEnabledError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided PlatformBtxNotEnabledError
func (t *DisconnectBulkPartnerMemberCompanyError) FromPlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformBtxNotEnabledError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided PlatformBtxNotEnabledError
func (t *DisconnectBulkPartnerMemberCompanyError) MergePlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a PlatformExternalApiFailedError
func (t DisconnectBulkPartnerMemberCompanyError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided PlatformExternalApiFailedError
func (t *DisconnectBulkPartnerMemberCompanyError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided PlatformExternalApiFailedError
func (t *DisconnectBulkPartnerMemberCompanyError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a PlatformNotEnabledError
func (t DisconnectBulkPartnerMemberCompanyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided PlatformNotEnabledError
func (t *DisconnectBulkPartnerMemberCompanyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided PlatformNotEnabledError
func (t *DisconnectBulkPartnerMemberCompanyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a PlatformPartnerNotFoundError
func (t DisconnectBulkPartnerMemberCompanyError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided PlatformPartnerNotFoundError
func (t *DisconnectBulkPartnerMemberCompanyError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided PlatformPartnerNotFoundError
func (t *DisconnectBulkPartnerMemberCompanyError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTargetPartnerNotFoundError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a PlatformTargetPartnerNotFoundError
func (t DisconnectBulkPartnerMemberCompanyError) AsPlatformTargetPartnerNotFoundError() (PlatformTargetPartnerNotFoundError, error) {
	var body PlatformTargetPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTargetPartnerNotFoundError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided PlatformTargetPartnerNotFoundError
func (t *DisconnectBulkPartnerMemberCompanyError) FromPlatformTargetPartnerNotFoundError(v PlatformTargetPartnerNotFoundError) error {
	v.Type = "PLATFORM_TARGET_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTargetPartnerNotFoundError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided PlatformTargetPartnerNotFoundError
func (t *DisconnectBulkPartnerMemberCompanyError) MergePlatformTargetPartnerNotFoundError(v PlatformTargetPartnerNotFoundError) error {
	v.Type = "PLATFORM_TARGET_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DisconnectBulkPartnerMemberCompanyError as a UnauthorizedError
func (t DisconnectBulkPartnerMemberCompanyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DisconnectBulkPartnerMemberCompanyError as the provided UnauthorizedError
func (t *DisconnectBulkPartnerMemberCompanyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DisconnectBulkPartnerMemberCompanyError, using the provided UnauthorizedError
func (t *DisconnectBulkPartnerMemberCompanyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DisconnectBulkPartnerMemberCompanyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DisconnectBulkPartnerMemberCompanyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_BTX_NOT_ENABLED":
		return t.AsPlatformBtxNotEnabledError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_TARGET_PARTNER_NOT_FOUND":
		return t.AsPlatformTargetPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DisconnectBulkPartnerMemberCompanyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DisconnectBulkPartnerMemberCompanyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the DisconnectPartnerMemberCompanyError as a ForbiddenError
func (t DisconnectPartnerMemberCompanyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided ForbiddenError
func (t *DisconnectPartnerMemberCompanyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided ForbiddenError
func (t *DisconnectPartnerMemberCompanyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DisconnectPartnerMemberCompanyError as a InvalidRequestError
func (t DisconnectPartnerMemberCompanyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided InvalidRequestError
func (t *DisconnectPartnerMemberCompanyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided InvalidRequestError
func (t *DisconnectPartnerMemberCompanyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformBtxNotEnabledError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformBtxNotEnabledError
func (t DisconnectPartnerMemberCompanyError) AsPlatformBtxNotEnabledError() (PlatformBtxNotEnabledError, error) {
	var body PlatformBtxNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformBtxNotEnabledError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformBtxNotEnabledError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformBtxNotEnabledError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformBtxNotEnabledError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformBtxNotEnabledError(v PlatformBtxNotEnabledError) error {
	v.Type = "PLATFORM_BTX_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformExternalApiFailedError
func (t DisconnectPartnerMemberCompanyError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformExternalApiFailedError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformExternalApiFailedError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyNotConnectedError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformMemberCompanyNotConnectedError
func (t DisconnectPartnerMemberCompanyError) AsPlatformMemberCompanyNotConnectedError() (PlatformMemberCompanyNotConnectedError, error) {
	var body PlatformMemberCompanyNotConnectedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyNotConnectedError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformMemberCompanyNotConnectedError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformMemberCompanyNotConnectedError(v PlatformMemberCompanyNotConnectedError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_NOT_CONNECTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyNotConnectedError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformMemberCompanyNotConnectedError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformMemberCompanyNotConnectedError(v PlatformMemberCompanyNotConnectedError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_NOT_CONNECTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformNotEnabledError
func (t DisconnectPartnerMemberCompanyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformNotEnabledError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformNotEnabledError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOngoingTaxInvoiceExistsError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformOngoingTaxInvoiceExistsError
func (t DisconnectPartnerMemberCompanyError) AsPlatformOngoingTaxInvoiceExistsError() (PlatformOngoingTaxInvoiceExistsError, error) {
	var body PlatformOngoingTaxInvoiceExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOngoingTaxInvoiceExistsError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformOngoingTaxInvoiceExistsError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformOngoingTaxInvoiceExistsError(v PlatformOngoingTaxInvoiceExistsError) error {
	v.Type = "PLATFORM_ONGOING_TAX_INVOICE_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOngoingTaxInvoiceExistsError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformOngoingTaxInvoiceExistsError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformOngoingTaxInvoiceExistsError(v PlatformOngoingTaxInvoiceExistsError) error {
	v.Type = "PLATFORM_ONGOING_TAX_INVOICE_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformPartnerNotFoundError
func (t DisconnectPartnerMemberCompanyError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformPartnerNotFoundError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformPartnerNotFoundError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTaxationTypeIsSimpleError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformPartnerTaxationTypeIsSimpleError
func (t DisconnectPartnerMemberCompanyError) AsPlatformPartnerTaxationTypeIsSimpleError() (PlatformPartnerTaxationTypeIsSimpleError, error) {
	var body PlatformPartnerTaxationTypeIsSimpleError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTaxationTypeIsSimpleError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformPartnerTaxationTypeIsSimpleError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformPartnerTaxationTypeIsSimpleError(v PlatformPartnerTaxationTypeIsSimpleError) error {
	v.Type = "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTaxationTypeIsSimpleError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformPartnerTaxationTypeIsSimpleError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformPartnerTaxationTypeIsSimpleError(v PlatformPartnerTaxationTypeIsSimpleError) error {
	v.Type = "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTypeIsNotBusinessError returns the union data inside the DisconnectPartnerMemberCompanyError as a PlatformPartnerTypeIsNotBusinessError
func (t DisconnectPartnerMemberCompanyError) AsPlatformPartnerTypeIsNotBusinessError() (PlatformPartnerTypeIsNotBusinessError, error) {
	var body PlatformPartnerTypeIsNotBusinessError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTypeIsNotBusinessError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided PlatformPartnerTypeIsNotBusinessError
func (t *DisconnectPartnerMemberCompanyError) FromPlatformPartnerTypeIsNotBusinessError(v PlatformPartnerTypeIsNotBusinessError) error {
	v.Type = "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTypeIsNotBusinessError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided PlatformPartnerTypeIsNotBusinessError
func (t *DisconnectPartnerMemberCompanyError) MergePlatformPartnerTypeIsNotBusinessError(v PlatformPartnerTypeIsNotBusinessError) error {
	v.Type = "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DisconnectPartnerMemberCompanyError as a UnauthorizedError
func (t DisconnectPartnerMemberCompanyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DisconnectPartnerMemberCompanyError as the provided UnauthorizedError
func (t *DisconnectPartnerMemberCompanyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DisconnectPartnerMemberCompanyError, using the provided UnauthorizedError
func (t *DisconnectPartnerMemberCompanyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DisconnectPartnerMemberCompanyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DisconnectPartnerMemberCompanyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_BTX_NOT_ENABLED":
		return t.AsPlatformBtxNotEnabledError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_MEMBER_COMPANY_NOT_CONNECTED":
		return t.AsPlatformMemberCompanyNotConnectedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_ONGOING_TAX_INVOICE_EXISTS":
		return t.AsPlatformOngoingTaxInvoiceExistsError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_PARTNER_TAXATION_TYPE_IS_SIMPLE":
		return t.AsPlatformPartnerTaxationTypeIsSimpleError()
	case "PLATFORM_PARTNER_TYPE_IS_NOT_BUSINESS":
		return t.AsPlatformPartnerTypeIsNotBusinessError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DisconnectPartnerMemberCompanyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DisconnectPartnerMemberCompanyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the DownloadB2bTaxInvoicesSheetError as a InvalidRequestError
func (t DownloadB2bTaxInvoicesSheetError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DownloadB2bTaxInvoicesSheetError as the provided InvalidRequestError
func (t *DownloadB2bTaxInvoicesSheetError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DownloadB2bTaxInvoicesSheetError, using the provided InvalidRequestError
func (t *DownloadB2bTaxInvoicesSheetError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DownloadB2bTaxInvoicesSheetError as a UnauthorizedError
func (t DownloadB2bTaxInvoicesSheetError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DownloadB2bTaxInvoicesSheetError as the provided UnauthorizedError
func (t *DownloadB2bTaxInvoicesSheetError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DownloadB2bTaxInvoicesSheetError, using the provided UnauthorizedError
func (t *DownloadB2bTaxInvoicesSheetError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DownloadB2bTaxInvoicesSheetError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DownloadB2bTaxInvoicesSheetError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DownloadB2bTaxInvoicesSheetError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DownloadB2bTaxInvoicesSheetError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the DownloadPlatformTransferSheetError as a InvalidRequestError
func (t DownloadPlatformTransferSheetError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DownloadPlatformTransferSheetError as the provided InvalidRequestError
func (t *DownloadPlatformTransferSheetError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DownloadPlatformTransferSheetError, using the provided InvalidRequestError
func (t *DownloadPlatformTransferSheetError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DownloadPlatformTransferSheetError as a UnauthorizedError
func (t DownloadPlatformTransferSheetError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DownloadPlatformTransferSheetError as the provided UnauthorizedError
func (t *DownloadPlatformTransferSheetError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DownloadPlatformTransferSheetError, using the provided UnauthorizedError
func (t *DownloadPlatformTransferSheetError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DownloadPlatformTransferSheetError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DownloadPlatformTransferSheetError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DownloadPlatformTransferSheetError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DownloadPlatformTransferSheetError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2BCannotChangeTaxTypeError returns the union data inside the DraftB2bTaxInvoiceError as a B2BCannotChangeTaxTypeError
func (t DraftB2bTaxInvoiceError) AsB2BCannotChangeTaxTypeError() (B2BCannotChangeTaxTypeError, error) {
	var body B2BCannotChangeTaxTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BCannotChangeTaxTypeError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2BCannotChangeTaxTypeError
func (t *DraftB2bTaxInvoiceError) FromB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BCannotChangeTaxTypeError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2BCannotChangeTaxTypeError
func (t *DraftB2bTaxInvoiceError) MergeB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2BTaxInvoiceStatusNotSendingCompletedError returns the union data inside the DraftB2bTaxInvoiceError as a B2BTaxInvoiceStatusNotSendingCompletedError
func (t DraftB2bTaxInvoiceError) AsB2BTaxInvoiceStatusNotSendingCompletedError() (B2BTaxInvoiceStatusNotSendingCompletedError, error) {
	var body B2BTaxInvoiceStatusNotSendingCompletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BTaxInvoiceStatusNotSendingCompletedError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *DraftB2bTaxInvoiceError) FromB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BTaxInvoiceStatusNotSendingCompletedError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *DraftB2bTaxInvoiceError) MergeB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the DraftB2bTaxInvoiceError as a B2bExternalServiceError
func (t DraftB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *DraftB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *DraftB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIdAlreadyExistsError returns the union data inside the DraftB2bTaxInvoiceError as a B2bIdAlreadyExistsError
func (t DraftB2bTaxInvoiceError) AsB2bIdAlreadyExistsError() (B2bIdAlreadyExistsError, error) {
	var body B2bIdAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIdAlreadyExistsError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bIdAlreadyExistsError
func (t *DraftB2bTaxInvoiceError) FromB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIdAlreadyExistsError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bIdAlreadyExistsError
func (t *DraftB2bTaxInvoiceError) MergeB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIssuanceTypeMismatchError returns the union data inside the DraftB2bTaxInvoiceError as a B2bIssuanceTypeMismatchError
func (t DraftB2bTaxInvoiceError) AsB2bIssuanceTypeMismatchError() (B2bIssuanceTypeMismatchError, error) {
	var body B2bIssuanceTypeMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIssuanceTypeMismatchError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bIssuanceTypeMismatchError
func (t *DraftB2bTaxInvoiceError) FromB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIssuanceTypeMismatchError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bIssuanceTypeMismatchError
func (t *DraftB2bTaxInvoiceError) MergeB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bModificationNotProvidedError returns the union data inside the DraftB2bTaxInvoiceError as a B2bModificationNotProvidedError
func (t DraftB2bTaxInvoiceError) AsB2bModificationNotProvidedError() (B2bModificationNotProvidedError, error) {
	var body B2bModificationNotProvidedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bModificationNotProvidedError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bModificationNotProvidedError
func (t *DraftB2bTaxInvoiceError) FromB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bModificationNotProvidedError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bModificationNotProvidedError
func (t *DraftB2bTaxInvoiceError) MergeB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the DraftB2bTaxInvoiceError as a B2bNotEnabledError
func (t DraftB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *DraftB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *DraftB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bOriginalTaxInvoiceNotFoundError returns the union data inside the DraftB2bTaxInvoiceError as a B2bOriginalTaxInvoiceNotFoundError
func (t DraftB2bTaxInvoiceError) AsB2bOriginalTaxInvoiceNotFoundError() (B2bOriginalTaxInvoiceNotFoundError, error) {
	var body B2bOriginalTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bOriginalTaxInvoiceNotFoundError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bOriginalTaxInvoiceNotFoundError
func (t *DraftB2bTaxInvoiceError) FromB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bOriginalTaxInvoiceNotFoundError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bOriginalTaxInvoiceNotFoundError
func (t *DraftB2bTaxInvoiceError) MergeB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bRecipientNotFoundError returns the union data inside the DraftB2bTaxInvoiceError as a B2bRecipientNotFoundError
func (t DraftB2bTaxInvoiceError) AsB2bRecipientNotFoundError() (B2bRecipientNotFoundError, error) {
	var body B2bRecipientNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bRecipientNotFoundError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bRecipientNotFoundError
func (t *DraftB2bTaxInvoiceError) FromB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bRecipientNotFoundError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bRecipientNotFoundError
func (t *DraftB2bTaxInvoiceError) MergeB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bSupplierNotFoundError returns the union data inside the DraftB2bTaxInvoiceError as a B2bSupplierNotFoundError
func (t DraftB2bTaxInvoiceError) AsB2bSupplierNotFoundError() (B2bSupplierNotFoundError, error) {
	var body B2bSupplierNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bSupplierNotFoundError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bSupplierNotFoundError
func (t *DraftB2bTaxInvoiceError) FromB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bSupplierNotFoundError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bSupplierNotFoundError
func (t *DraftB2bTaxInvoiceError) MergeB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the DraftB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t DraftB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *DraftB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *DraftB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError returns the union data inside the DraftB2bTaxInvoiceError as a B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t DraftB2bTaxInvoiceError) AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError() (B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *DraftB2bTaxInvoiceError) FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *DraftB2bTaxInvoiceError) MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError returns the union data inside the DraftB2bTaxInvoiceError as a B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t DraftB2bTaxInvoiceError) AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError() (B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *DraftB2bTaxInvoiceError) FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *DraftB2bTaxInvoiceError) MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the DraftB2bTaxInvoiceError as a ForbiddenError
func (t DraftB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided ForbiddenError
func (t *DraftB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided ForbiddenError
func (t *DraftB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the DraftB2bTaxInvoiceError as a InvalidRequestError
func (t DraftB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided InvalidRequestError
func (t *DraftB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *DraftB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the DraftB2bTaxInvoiceError as a UnauthorizedError
func (t DraftB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the DraftB2bTaxInvoiceError as the provided UnauthorizedError
func (t *DraftB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the DraftB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *DraftB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DraftB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t DraftB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_CANNOT_CHANGE_TAX_TYPE":
		return t.AsB2BCannotChangeTaxTypeError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_ID_ALREADY_EXISTS":
		return t.AsB2bIdAlreadyExistsError()
	case "B2B_ISSUANCE_TYPE_MISMATCH":
		return t.AsB2bIssuanceTypeMismatchError()
	case "B2B_MODIFICATION_NOT_PROVIDED":
		return t.AsB2bModificationNotProvidedError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bOriginalTaxInvoiceNotFoundError()
	case "B2B_RECIPIENT_NOT_FOUND":
		return t.AsB2bRecipientNotFoundError()
	case "B2B_SUPPLIER_NOT_FOUND":
		return t.AsB2bSupplierNotFoundError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError()
	case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
		return t.AsB2BTaxInvoiceStatusNotSendingCompletedError()
	case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t DraftB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DraftB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetAllPaymentEventsError as a ForbiddenError
func (t GetAllPaymentEventsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetAllPaymentEventsError as the provided ForbiddenError
func (t *GetAllPaymentEventsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetAllPaymentEventsError, using the provided ForbiddenError
func (t *GetAllPaymentEventsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetAllPaymentEventsError as a InvalidRequestError
func (t GetAllPaymentEventsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetAllPaymentEventsError as the provided InvalidRequestError
func (t *GetAllPaymentEventsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetAllPaymentEventsError, using the provided InvalidRequestError
func (t *GetAllPaymentEventsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetAllPaymentEventsError as a UnauthorizedError
func (t GetAllPaymentEventsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetAllPaymentEventsError as the provided UnauthorizedError
func (t *GetAllPaymentEventsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetAllPaymentEventsError, using the provided UnauthorizedError
func (t *GetAllPaymentEventsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAllPaymentEventsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetAllPaymentEventsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetAllPaymentEventsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAllPaymentEventsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetAllPaymentsError as a ForbiddenError
func (t GetAllPaymentsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetAllPaymentsError as the provided ForbiddenError
func (t *GetAllPaymentsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetAllPaymentsError, using the provided ForbiddenError
func (t *GetAllPaymentsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetAllPaymentsError as a InvalidRequestError
func (t GetAllPaymentsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetAllPaymentsError as the provided InvalidRequestError
func (t *GetAllPaymentsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetAllPaymentsError, using the provided InvalidRequestError
func (t *GetAllPaymentsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetAllPaymentsError as a UnauthorizedError
func (t GetAllPaymentsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetAllPaymentsError as the provided UnauthorizedError
func (t *GetAllPaymentsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetAllPaymentsError, using the provided UnauthorizedError
func (t *GetAllPaymentsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetAllPaymentsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetAllPaymentsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetAllPaymentsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetAllPaymentsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bBulkTaxInvoiceNotFoundError returns the union data inside the GetB2bBulkTaxInvoiceError as a B2bBulkTaxInvoiceNotFoundError
func (t GetB2bBulkTaxInvoiceError) AsB2bBulkTaxInvoiceNotFoundError() (B2bBulkTaxInvoiceNotFoundError, error) {
	var body B2bBulkTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bBulkTaxInvoiceNotFoundError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided B2bBulkTaxInvoiceNotFoundError
func (t *GetB2bBulkTaxInvoiceError) FromB2bBulkTaxInvoiceNotFoundError(v B2bBulkTaxInvoiceNotFoundError) error {
	v.Type = "B2B_BULK_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bBulkTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided B2bBulkTaxInvoiceNotFoundError
func (t *GetB2bBulkTaxInvoiceError) MergeB2bBulkTaxInvoiceNotFoundError(v B2bBulkTaxInvoiceNotFoundError) error {
	v.Type = "B2B_BULK_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bBulkTaxInvoiceError as a B2bExternalServiceError
func (t GetB2bBulkTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided B2bExternalServiceError
func (t *GetB2bBulkTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided B2bExternalServiceError
func (t *GetB2bBulkTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bBulkTaxInvoiceError as a B2bNotEnabledError
func (t GetB2bBulkTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided B2bNotEnabledError
func (t *GetB2bBulkTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided B2bNotEnabledError
func (t *GetB2bBulkTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bBulkTaxInvoiceError as a ForbiddenError
func (t GetB2bBulkTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided ForbiddenError
func (t *GetB2bBulkTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided ForbiddenError
func (t *GetB2bBulkTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bBulkTaxInvoiceError as a InvalidRequestError
func (t GetB2bBulkTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided InvalidRequestError
func (t *GetB2bBulkTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided InvalidRequestError
func (t *GetB2bBulkTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bBulkTaxInvoiceError as a UnauthorizedError
func (t GetB2bBulkTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bBulkTaxInvoiceError as the provided UnauthorizedError
func (t *GetB2bBulkTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bBulkTaxInvoiceError, using the provided UnauthorizedError
func (t *GetB2bBulkTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bBulkTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bBulkTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_BULK_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bBulkTaxInvoiceNotFoundError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bBulkTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bBulkTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bBusinessInfosError as a B2bExternalServiceError
func (t GetB2bBusinessInfosError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bBusinessInfosError as the provided B2bExternalServiceError
func (t *GetB2bBusinessInfosError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bBusinessInfosError, using the provided B2bExternalServiceError
func (t *GetB2bBusinessInfosError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bBusinessInfosError as a B2bNotEnabledError
func (t GetB2bBusinessInfosError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bBusinessInfosError as the provided B2bNotEnabledError
func (t *GetB2bBusinessInfosError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bBusinessInfosError, using the provided B2bNotEnabledError
func (t *GetB2bBusinessInfosError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bBusinessInfosError as a ForbiddenError
func (t GetB2bBusinessInfosError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bBusinessInfosError as the provided ForbiddenError
func (t *GetB2bBusinessInfosError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bBusinessInfosError, using the provided ForbiddenError
func (t *GetB2bBusinessInfosError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bBusinessInfosError as a InvalidRequestError
func (t GetB2bBusinessInfosError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bBusinessInfosError as the provided InvalidRequestError
func (t *GetB2bBusinessInfosError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bBusinessInfosError, using the provided InvalidRequestError
func (t *GetB2bBusinessInfosError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bBusinessInfosError as a UnauthorizedError
func (t GetB2bBusinessInfosError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bBusinessInfosError as the provided UnauthorizedError
func (t *GetB2bBusinessInfosError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bBusinessInfosError, using the provided UnauthorizedError
func (t *GetB2bBusinessInfosError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bBusinessInfosError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bBusinessInfosError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bBusinessInfosError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bBusinessInfosError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a B2bExternalServiceError
func (t GetB2bTaxInvoiceAttachmentsError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoiceAttachmentsError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a B2bNotEnabledError
func (t GetB2bTaxInvoiceAttachmentsError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoiceAttachmentsError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoiceAttachmentsError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoiceAttachmentsError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a ForbiddenError
func (t GetB2bTaxInvoiceAttachmentsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided ForbiddenError
func (t *GetB2bTaxInvoiceAttachmentsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided ForbiddenError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a InvalidRequestError
func (t GetB2bTaxInvoiceAttachmentsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided InvalidRequestError
func (t *GetB2bTaxInvoiceAttachmentsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoiceAttachmentsError as a UnauthorizedError
func (t GetB2bTaxInvoiceAttachmentsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoiceAttachmentsError as the provided UnauthorizedError
func (t *GetB2bTaxInvoiceAttachmentsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoiceAttachmentsError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoiceAttachmentsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoiceAttachmentsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoiceAttachmentsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoiceAttachmentsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoiceAttachmentsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoiceError as a B2bExternalServiceError
func (t GetB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoiceError as a B2bNotEnabledError
func (t GetB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoiceError as a ForbiddenError
func (t GetB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoiceError as the provided ForbiddenError
func (t *GetB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided ForbiddenError
func (t *GetB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoiceError as a InvalidRequestError
func (t GetB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoiceError as the provided InvalidRequestError
func (t *GetB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoiceError as a UnauthorizedError
func (t GetB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoiceError as the provided UnauthorizedError
func (t *GetB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a B2bExternalServiceError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a B2bNotEnabledError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a ForbiddenError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided ForbiddenError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided ForbiddenError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a InvalidRequestError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided InvalidRequestError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoicePdfDownloadUrlError as a UnauthorizedError
func (t GetB2bTaxInvoicePdfDownloadUrlError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoicePdfDownloadUrlError as the provided UnauthorizedError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoicePdfDownloadUrlError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoicePdfDownloadUrlError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoicePdfDownloadUrlError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoicePdfDownloadUrlError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoicePdfDownloadUrlError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoicePdfDownloadUrlError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a B2bExternalServiceError
func (t GetB2bTaxInvoicePopupUrlError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePopupUrlError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePopupUrlError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a B2bNotEnabledError
func (t GetB2bTaxInvoicePopupUrlError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePopupUrlError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePopupUrlError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoicePopupUrlError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePopupUrlError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePopupUrlError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a ForbiddenError
func (t GetB2bTaxInvoicePopupUrlError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided ForbiddenError
func (t *GetB2bTaxInvoicePopupUrlError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided ForbiddenError
func (t *GetB2bTaxInvoicePopupUrlError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a InvalidRequestError
func (t GetB2bTaxInvoicePopupUrlError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided InvalidRequestError
func (t *GetB2bTaxInvoicePopupUrlError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoicePopupUrlError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoicePopupUrlError as a UnauthorizedError
func (t GetB2bTaxInvoicePopupUrlError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoicePopupUrlError as the provided UnauthorizedError
func (t *GetB2bTaxInvoicePopupUrlError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoicePopupUrlError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoicePopupUrlError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoicePopupUrlError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoicePopupUrlError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoicePopupUrlError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoicePopupUrlError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a B2bExternalServiceError
func (t GetB2bTaxInvoicePrintUrlError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePrintUrlError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicePrintUrlError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a B2bNotEnabledError
func (t GetB2bTaxInvoicePrintUrlError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePrintUrlError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicePrintUrlError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoicePrintUrlError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePrintUrlError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicePrintUrlError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a ForbiddenError
func (t GetB2bTaxInvoicePrintUrlError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided ForbiddenError
func (t *GetB2bTaxInvoicePrintUrlError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided ForbiddenError
func (t *GetB2bTaxInvoicePrintUrlError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a InvalidRequestError
func (t GetB2bTaxInvoicePrintUrlError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided InvalidRequestError
func (t *GetB2bTaxInvoicePrintUrlError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoicePrintUrlError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoicePrintUrlError as a UnauthorizedError
func (t GetB2bTaxInvoicePrintUrlError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoicePrintUrlError as the provided UnauthorizedError
func (t *GetB2bTaxInvoicePrintUrlError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoicePrintUrlError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoicePrintUrlError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoicePrintUrlError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoicePrintUrlError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoicePrintUrlError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoicePrintUrlError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the GetB2bTaxInvoicesError as a B2bExternalServiceError
func (t GetB2bTaxInvoicesError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the GetB2bTaxInvoicesError as the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicesError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided B2bExternalServiceError
func (t *GetB2bTaxInvoicesError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the GetB2bTaxInvoicesError as a B2bNotEnabledError
func (t GetB2bTaxInvoicesError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the GetB2bTaxInvoicesError as the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicesError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided B2bNotEnabledError
func (t *GetB2bTaxInvoicesError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the GetB2bTaxInvoicesError as a B2bTaxInvoiceNotFoundError
func (t GetB2bTaxInvoicesError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the GetB2bTaxInvoicesError as the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicesError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided B2bTaxInvoiceNotFoundError
func (t *GetB2bTaxInvoicesError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetB2bTaxInvoicesError as a ForbiddenError
func (t GetB2bTaxInvoicesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetB2bTaxInvoicesError as the provided ForbiddenError
func (t *GetB2bTaxInvoicesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided ForbiddenError
func (t *GetB2bTaxInvoicesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetB2bTaxInvoicesError as a InvalidRequestError
func (t GetB2bTaxInvoicesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetB2bTaxInvoicesError as the provided InvalidRequestError
func (t *GetB2bTaxInvoicesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided InvalidRequestError
func (t *GetB2bTaxInvoicesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetB2bTaxInvoicesError as a UnauthorizedError
func (t GetB2bTaxInvoicesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetB2bTaxInvoicesError as the provided UnauthorizedError
func (t *GetB2bTaxInvoicesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetB2bTaxInvoicesError, using the provided UnauthorizedError
func (t *GetB2bTaxInvoicesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetB2bTaxInvoicesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetB2bTaxInvoicesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetB2bTaxInvoicesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetB2bTaxInvoicesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the GetBankInfosError as a InvalidRequestError
func (t GetBankInfosError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetBankInfosError as the provided InvalidRequestError
func (t *GetBankInfosError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetBankInfosError, using the provided InvalidRequestError
func (t *GetBankInfosError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetBankInfosError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetBankInfosError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetBankInfosError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetBankInfosError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the GetBillingKeyInfoError as a BillingKeyNotFoundError
func (t GetBillingKeyInfoError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the GetBillingKeyInfoError as the provided BillingKeyNotFoundError
func (t *GetBillingKeyInfoError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the GetBillingKeyInfoError, using the provided BillingKeyNotFoundError
func (t *GetBillingKeyInfoError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetBillingKeyInfoError as a ForbiddenError
func (t GetBillingKeyInfoError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetBillingKeyInfoError as the provided ForbiddenError
func (t *GetBillingKeyInfoError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetBillingKeyInfoError, using the provided ForbiddenError
func (t *GetBillingKeyInfoError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetBillingKeyInfoError as a InvalidRequestError
func (t GetBillingKeyInfoError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetBillingKeyInfoError as the provided InvalidRequestError
func (t *GetBillingKeyInfoError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetBillingKeyInfoError, using the provided InvalidRequestError
func (t *GetBillingKeyInfoError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetBillingKeyInfoError as a UnauthorizedError
func (t GetBillingKeyInfoError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetBillingKeyInfoError as the provided UnauthorizedError
func (t *GetBillingKeyInfoError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetBillingKeyInfoError, using the provided UnauthorizedError
func (t *GetBillingKeyInfoError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetBillingKeyInfoError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetBillingKeyInfoError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetBillingKeyInfoError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetBillingKeyInfoError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetBillingKeyInfosError as a ForbiddenError
func (t GetBillingKeyInfosError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetBillingKeyInfosError as the provided ForbiddenError
func (t *GetBillingKeyInfosError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetBillingKeyInfosError, using the provided ForbiddenError
func (t *GetBillingKeyInfosError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetBillingKeyInfosError as a InvalidRequestError
func (t GetBillingKeyInfosError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetBillingKeyInfosError as the provided InvalidRequestError
func (t *GetBillingKeyInfosError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetBillingKeyInfosError, using the provided InvalidRequestError
func (t *GetBillingKeyInfosError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetBillingKeyInfosError as a UnauthorizedError
func (t GetBillingKeyInfosError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetBillingKeyInfosError as the provided UnauthorizedError
func (t *GetBillingKeyInfosError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetBillingKeyInfosError, using the provided UnauthorizedError
func (t *GetBillingKeyInfosError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetBillingKeyInfosError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetBillingKeyInfosError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetBillingKeyInfosError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetBillingKeyInfosError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashReceiptNotFoundError returns the union data inside the GetCashReceiptError as a CashReceiptNotFoundError
func (t GetCashReceiptError) AsCashReceiptNotFoundError() (CashReceiptNotFoundError, error) {
	var body CashReceiptNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashReceiptNotFoundError overwrites any union data inside the GetCashReceiptError as the provided CashReceiptNotFoundError
func (t *GetCashReceiptError) FromCashReceiptNotFoundError(v CashReceiptNotFoundError) error {
	v.Type = "CASH_RECEIPT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashReceiptNotFoundError performs a merge with any union data inside the GetCashReceiptError, using the provided CashReceiptNotFoundError
func (t *GetCashReceiptError) MergeCashReceiptNotFoundError(v CashReceiptNotFoundError) error {
	v.Type = "CASH_RECEIPT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the GetCashReceiptError as a ForbiddenError
func (t GetCashReceiptError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetCashReceiptError as the provided ForbiddenError
func (t *GetCashReceiptError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetCashReceiptError, using the provided ForbiddenError
func (t *GetCashReceiptError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetCashReceiptError as a InvalidRequestError
func (t GetCashReceiptError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetCashReceiptError as the provided InvalidRequestError
func (t *GetCashReceiptError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetCashReceiptError, using the provided InvalidRequestError
func (t *GetCashReceiptError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetCashReceiptError as a UnauthorizedError
func (t GetCashReceiptError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetCashReceiptError as the provided UnauthorizedError
func (t *GetCashReceiptError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetCashReceiptError, using the provided UnauthorizedError
func (t *GetCashReceiptError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetCashReceiptError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetCashReceiptError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CASH_RECEIPT_NOT_FOUND":
		return t.AsCashReceiptNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetCashReceiptError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetCashReceiptError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetCashReceiptsError as a ForbiddenError
func (t GetCashReceiptsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetCashReceiptsError as the provided ForbiddenError
func (t *GetCashReceiptsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetCashReceiptsError, using the provided ForbiddenError
func (t *GetCashReceiptsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetCashReceiptsError as a InvalidRequestError
func (t GetCashReceiptsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetCashReceiptsError as the provided InvalidRequestError
func (t *GetCashReceiptsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetCashReceiptsError, using the provided InvalidRequestError
func (t *GetCashReceiptsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetCashReceiptsError as a UnauthorizedError
func (t GetCashReceiptsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetCashReceiptsError as the provided UnauthorizedError
func (t *GetCashReceiptsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetCashReceiptsError, using the provided UnauthorizedError
func (t *GetCashReceiptsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetCashReceiptsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetCashReceiptsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetCashReceiptsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetCashReceiptsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetIdentityVerificationError as a ForbiddenError
func (t GetIdentityVerificationError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetIdentityVerificationError as the provided ForbiddenError
func (t *GetIdentityVerificationError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetIdentityVerificationError, using the provided ForbiddenError
func (t *GetIdentityVerificationError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotFoundError returns the union data inside the GetIdentityVerificationError as a IdentityVerificationNotFoundError
func (t GetIdentityVerificationError) AsIdentityVerificationNotFoundError() (IdentityVerificationNotFoundError, error) {
	var body IdentityVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotFoundError overwrites any union data inside the GetIdentityVerificationError as the provided IdentityVerificationNotFoundError
func (t *GetIdentityVerificationError) FromIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotFoundError performs a merge with any union data inside the GetIdentityVerificationError, using the provided IdentityVerificationNotFoundError
func (t *GetIdentityVerificationError) MergeIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetIdentityVerificationError as a InvalidRequestError
func (t GetIdentityVerificationError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetIdentityVerificationError as the provided InvalidRequestError
func (t *GetIdentityVerificationError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetIdentityVerificationError, using the provided InvalidRequestError
func (t *GetIdentityVerificationError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetIdentityVerificationError as a UnauthorizedError
func (t GetIdentityVerificationError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetIdentityVerificationError as the provided UnauthorizedError
func (t *GetIdentityVerificationError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetIdentityVerificationError, using the provided UnauthorizedError
func (t *GetIdentityVerificationError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetIdentityVerificationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetIdentityVerificationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "IDENTITY_VERIFICATION_NOT_FOUND":
		return t.AsIdentityVerificationNotFoundError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetIdentityVerificationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetIdentityVerificationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetIdentityVerificationsError as a ForbiddenError
func (t GetIdentityVerificationsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetIdentityVerificationsError as the provided ForbiddenError
func (t *GetIdentityVerificationsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetIdentityVerificationsError, using the provided ForbiddenError
func (t *GetIdentityVerificationsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetIdentityVerificationsError as a InvalidRequestError
func (t GetIdentityVerificationsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetIdentityVerificationsError as the provided InvalidRequestError
func (t *GetIdentityVerificationsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetIdentityVerificationsError, using the provided InvalidRequestError
func (t *GetIdentityVerificationsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetIdentityVerificationsError as a UnauthorizedError
func (t GetIdentityVerificationsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetIdentityVerificationsError as the provided UnauthorizedError
func (t *GetIdentityVerificationsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetIdentityVerificationsError, using the provided UnauthorizedError
func (t *GetIdentityVerificationsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetIdentityVerificationsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetIdentityVerificationsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetIdentityVerificationsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetIdentityVerificationsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the GetKakaopayPaymentOrderError as a InvalidRequestError
func (t GetKakaopayPaymentOrderError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetKakaopayPaymentOrderError as the provided InvalidRequestError
func (t *GetKakaopayPaymentOrderError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetKakaopayPaymentOrderError, using the provided InvalidRequestError
func (t *GetKakaopayPaymentOrderError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetKakaopayPaymentOrderError as a UnauthorizedError
func (t GetKakaopayPaymentOrderError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetKakaopayPaymentOrderError as the provided UnauthorizedError
func (t *GetKakaopayPaymentOrderError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetKakaopayPaymentOrderError, using the provided UnauthorizedError
func (t *GetKakaopayPaymentOrderError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetKakaopayPaymentOrderError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetKakaopayPaymentOrderError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetKakaopayPaymentOrderError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetKakaopayPaymentOrderError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPaymentError as a ForbiddenError
func (t GetPaymentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPaymentError as the provided ForbiddenError
func (t *GetPaymentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPaymentError, using the provided ForbiddenError
func (t *GetPaymentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPaymentError as a InvalidRequestError
func (t GetPaymentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPaymentError as the provided InvalidRequestError
func (t *GetPaymentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPaymentError, using the provided InvalidRequestError
func (t *GetPaymentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the GetPaymentError as a PaymentNotFoundError
func (t GetPaymentError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the GetPaymentError as the provided PaymentNotFoundError
func (t *GetPaymentError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the GetPaymentError, using the provided PaymentNotFoundError
func (t *GetPaymentError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPaymentError as a UnauthorizedError
func (t GetPaymentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPaymentError as the provided UnauthorizedError
func (t *GetPaymentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPaymentError, using the provided UnauthorizedError
func (t *GetPaymentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPaymentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPaymentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPaymentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPaymentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPaymentScheduleError as a ForbiddenError
func (t GetPaymentScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPaymentScheduleError as the provided ForbiddenError
func (t *GetPaymentScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPaymentScheduleError, using the provided ForbiddenError
func (t *GetPaymentScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPaymentScheduleError as a InvalidRequestError
func (t GetPaymentScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPaymentScheduleError as the provided InvalidRequestError
func (t *GetPaymentScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPaymentScheduleError, using the provided InvalidRequestError
func (t *GetPaymentScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleNotFoundError returns the union data inside the GetPaymentScheduleError as a PaymentScheduleNotFoundError
func (t GetPaymentScheduleError) AsPaymentScheduleNotFoundError() (PaymentScheduleNotFoundError, error) {
	var body PaymentScheduleNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleNotFoundError overwrites any union data inside the GetPaymentScheduleError as the provided PaymentScheduleNotFoundError
func (t *GetPaymentScheduleError) FromPaymentScheduleNotFoundError(v PaymentScheduleNotFoundError) error {
	v.Type = "PAYMENT_SCHEDULE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleNotFoundError performs a merge with any union data inside the GetPaymentScheduleError, using the provided PaymentScheduleNotFoundError
func (t *GetPaymentScheduleError) MergePaymentScheduleNotFoundError(v PaymentScheduleNotFoundError) error {
	v.Type = "PAYMENT_SCHEDULE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPaymentScheduleError as a UnauthorizedError
func (t GetPaymentScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPaymentScheduleError as the provided UnauthorizedError
func (t *GetPaymentScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPaymentScheduleError, using the provided UnauthorizedError
func (t *GetPaymentScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPaymentScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPaymentScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_SCHEDULE_NOT_FOUND":
		return t.AsPaymentScheduleNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPaymentScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPaymentScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPaymentSchedulesError as a ForbiddenError
func (t GetPaymentSchedulesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPaymentSchedulesError as the provided ForbiddenError
func (t *GetPaymentSchedulesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPaymentSchedulesError, using the provided ForbiddenError
func (t *GetPaymentSchedulesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPaymentSchedulesError as a InvalidRequestError
func (t GetPaymentSchedulesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPaymentSchedulesError as the provided InvalidRequestError
func (t *GetPaymentSchedulesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPaymentSchedulesError, using the provided InvalidRequestError
func (t *GetPaymentSchedulesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPaymentSchedulesError as a UnauthorizedError
func (t GetPaymentSchedulesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPaymentSchedulesError as the provided UnauthorizedError
func (t *GetPaymentSchedulesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPaymentSchedulesError, using the provided UnauthorizedError
func (t *GetPaymentSchedulesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPaymentSchedulesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPaymentSchedulesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPaymentSchedulesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPaymentSchedulesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPaymentTransactionsError as a ForbiddenError
func (t GetPaymentTransactionsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPaymentTransactionsError as the provided ForbiddenError
func (t *GetPaymentTransactionsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPaymentTransactionsError, using the provided ForbiddenError
func (t *GetPaymentTransactionsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPaymentTransactionsError as a InvalidRequestError
func (t GetPaymentTransactionsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPaymentTransactionsError as the provided InvalidRequestError
func (t *GetPaymentTransactionsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPaymentTransactionsError, using the provided InvalidRequestError
func (t *GetPaymentTransactionsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the GetPaymentTransactionsError as a PaymentNotFoundError
func (t GetPaymentTransactionsError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the GetPaymentTransactionsError as the provided PaymentNotFoundError
func (t *GetPaymentTransactionsError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the GetPaymentTransactionsError, using the provided PaymentNotFoundError
func (t *GetPaymentTransactionsError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPaymentTransactionsError as a UnauthorizedError
func (t GetPaymentTransactionsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPaymentTransactionsError as the provided UnauthorizedError
func (t *GetPaymentTransactionsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPaymentTransactionsError, using the provided UnauthorizedError
func (t *GetPaymentTransactionsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPaymentTransactionsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPaymentTransactionsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPaymentTransactionsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPaymentTransactionsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPaymentsError as a ForbiddenError
func (t GetPaymentsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPaymentsError as the provided ForbiddenError
func (t *GetPaymentsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPaymentsError, using the provided ForbiddenError
func (t *GetPaymentsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPaymentsError as a InvalidRequestError
func (t GetPaymentsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPaymentsError as the provided InvalidRequestError
func (t *GetPaymentsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPaymentsError, using the provided InvalidRequestError
func (t *GetPaymentsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPaymentsError as a UnauthorizedError
func (t GetPaymentsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPaymentsError as the provided UnauthorizedError
func (t *GetPaymentsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPaymentsError, using the provided UnauthorizedError
func (t *GetPaymentsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPaymentsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPaymentsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPaymentsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPaymentsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformAccountHolderError as a ForbiddenError
func (t GetPlatformAccountHolderError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformAccountHolderError as the provided ForbiddenError
func (t *GetPlatformAccountHolderError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided ForbiddenError
func (t *GetPlatformAccountHolderError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformAccountHolderError as a InvalidRequestError
func (t GetPlatformAccountHolderError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformAccountHolderError as the provided InvalidRequestError
func (t *GetPlatformAccountHolderError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided InvalidRequestError
func (t *GetPlatformAccountHolderError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the GetPlatformAccountHolderError as a PlatformExternalApiFailedError
func (t GetPlatformAccountHolderError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the GetPlatformAccountHolderError as the provided PlatformExternalApiFailedError
func (t *GetPlatformAccountHolderError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided PlatformExternalApiFailedError
func (t *GetPlatformAccountHolderError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiTemporarilyFailedError returns the union data inside the GetPlatformAccountHolderError as a PlatformExternalApiTemporarilyFailedError
func (t GetPlatformAccountHolderError) AsPlatformExternalApiTemporarilyFailedError() (PlatformExternalApiTemporarilyFailedError, error) {
	var body PlatformExternalApiTemporarilyFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiTemporarilyFailedError overwrites any union data inside the GetPlatformAccountHolderError as the provided PlatformExternalApiTemporarilyFailedError
func (t *GetPlatformAccountHolderError) FromPlatformExternalApiTemporarilyFailedError(v PlatformExternalApiTemporarilyFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_TEMPORARILY_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiTemporarilyFailedError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided PlatformExternalApiTemporarilyFailedError
func (t *GetPlatformAccountHolderError) MergePlatformExternalApiTemporarilyFailedError(v PlatformExternalApiTemporarilyFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_TEMPORARILY_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformAccountHolderError as a PlatformNotEnabledError
func (t GetPlatformAccountHolderError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformAccountHolderError as the provided PlatformNotEnabledError
func (t *GetPlatformAccountHolderError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided PlatformNotEnabledError
func (t *GetPlatformAccountHolderError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotSupportedBankError returns the union data inside the GetPlatformAccountHolderError as a PlatformNotSupportedBankError
func (t GetPlatformAccountHolderError) AsPlatformNotSupportedBankError() (PlatformNotSupportedBankError, error) {
	var body PlatformNotSupportedBankError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotSupportedBankError overwrites any union data inside the GetPlatformAccountHolderError as the provided PlatformNotSupportedBankError
func (t *GetPlatformAccountHolderError) FromPlatformNotSupportedBankError(v PlatformNotSupportedBankError) error {
	v.Type = "PLATFORM_NOT_SUPPORTED_BANK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotSupportedBankError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided PlatformNotSupportedBankError
func (t *GetPlatformAccountHolderError) MergePlatformNotSupportedBankError(v PlatformNotSupportedBankError) error {
	v.Type = "PLATFORM_NOT_SUPPORTED_BANK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformAccountHolderError as a UnauthorizedError
func (t GetPlatformAccountHolderError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformAccountHolderError as the provided UnauthorizedError
func (t *GetPlatformAccountHolderError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformAccountHolderError, using the provided UnauthorizedError
func (t *GetPlatformAccountHolderError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformAccountHolderError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformAccountHolderError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_EXTERNAL_API_TEMPORARILY_FAILED":
		return t.AsPlatformExternalApiTemporarilyFailedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_NOT_SUPPORTED_BANK":
		return t.AsPlatformNotSupportedBankError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformAccountHolderError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformAccountHolderError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformAccountTransfersError as a ForbiddenError
func (t GetPlatformAccountTransfersError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformAccountTransfersError as the provided ForbiddenError
func (t *GetPlatformAccountTransfersError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformAccountTransfersError, using the provided ForbiddenError
func (t *GetPlatformAccountTransfersError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformAccountTransfersError as a InvalidRequestError
func (t GetPlatformAccountTransfersError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformAccountTransfersError as the provided InvalidRequestError
func (t *GetPlatformAccountTransfersError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformAccountTransfersError, using the provided InvalidRequestError
func (t *GetPlatformAccountTransfersError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformAccountTransfersError as a PlatformNotEnabledError
func (t GetPlatformAccountTransfersError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformAccountTransfersError as the provided PlatformNotEnabledError
func (t *GetPlatformAccountTransfersError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformAccountTransfersError, using the provided PlatformNotEnabledError
func (t *GetPlatformAccountTransfersError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformAccountTransfersError as a UnauthorizedError
func (t GetPlatformAccountTransfersError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformAccountTransfersError as the provided UnauthorizedError
func (t *GetPlatformAccountTransfersError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformAccountTransfersError, using the provided UnauthorizedError
func (t *GetPlatformAccountTransfersError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformAccountTransfersError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformAccountTransfersError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformAccountTransfersError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformAccountTransfersError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformAdditionalFeePoliciesError as a ForbiddenError
func (t GetPlatformAdditionalFeePoliciesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformAdditionalFeePoliciesError as the provided ForbiddenError
func (t *GetPlatformAdditionalFeePoliciesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformAdditionalFeePoliciesError, using the provided ForbiddenError
func (t *GetPlatformAdditionalFeePoliciesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformAdditionalFeePoliciesError as a InvalidRequestError
func (t GetPlatformAdditionalFeePoliciesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformAdditionalFeePoliciesError as the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePoliciesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformAdditionalFeePoliciesError, using the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePoliciesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformAdditionalFeePoliciesError as a PlatformNotEnabledError
func (t GetPlatformAdditionalFeePoliciesError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformAdditionalFeePoliciesError as the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePoliciesError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformAdditionalFeePoliciesError, using the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePoliciesError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformAdditionalFeePoliciesError as a UnauthorizedError
func (t GetPlatformAdditionalFeePoliciesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformAdditionalFeePoliciesError as the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePoliciesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformAdditionalFeePoliciesError, using the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePoliciesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformAdditionalFeePoliciesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformAdditionalFeePoliciesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformAdditionalFeePoliciesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformAdditionalFeePoliciesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformAdditionalFeePolicyError as a ForbiddenError
func (t GetPlatformAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformAdditionalFeePolicyError as the provided ForbiddenError
func (t *GetPlatformAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyError, using the provided ForbiddenError
func (t *GetPlatformAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformAdditionalFeePolicyError as a InvalidRequestError
func (t GetPlatformAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformAdditionalFeePolicyError as the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the GetPlatformAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t GetPlatformAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the GetPlatformAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *GetPlatformAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *GetPlatformAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformAdditionalFeePolicyError as a PlatformNotEnabledError
func (t GetPlatformAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformAdditionalFeePolicyError as a UnauthorizedError
func (t GetPlatformAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformAdditionalFeePolicyError as the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformAdditionalFeePolicyScheduleError as a ForbiddenError
func (t GetPlatformAdditionalFeePolicyScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformAdditionalFeePolicyScheduleError as the provided ForbiddenError
func (t *GetPlatformAdditionalFeePolicyScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyScheduleError, using the provided ForbiddenError
func (t *GetPlatformAdditionalFeePolicyScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformAdditionalFeePolicyScheduleError as a InvalidRequestError
func (t GetPlatformAdditionalFeePolicyScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformAdditionalFeePolicyScheduleError as the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePolicyScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyScheduleError, using the provided InvalidRequestError
func (t *GetPlatformAdditionalFeePolicyScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the GetPlatformAdditionalFeePolicyScheduleError as a PlatformAdditionalFeePolicyNotFoundError
func (t GetPlatformAdditionalFeePolicyScheduleError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the GetPlatformAdditionalFeePolicyScheduleError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *GetPlatformAdditionalFeePolicyScheduleError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyScheduleError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *GetPlatformAdditionalFeePolicyScheduleError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformAdditionalFeePolicyScheduleError as a PlatformNotEnabledError
func (t GetPlatformAdditionalFeePolicyScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformAdditionalFeePolicyScheduleError as the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePolicyScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyScheduleError, using the provided PlatformNotEnabledError
func (t *GetPlatformAdditionalFeePolicyScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformAdditionalFeePolicyScheduleError as a UnauthorizedError
func (t GetPlatformAdditionalFeePolicyScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformAdditionalFeePolicyScheduleError as the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePolicyScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformAdditionalFeePolicyScheduleError, using the provided UnauthorizedError
func (t *GetPlatformAdditionalFeePolicyScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformAdditionalFeePolicyScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformAdditionalFeePolicyScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformAdditionalFeePolicyScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformAdditionalFeePolicyScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformBulkAccountTransfersError as a ForbiddenError
func (t GetPlatformBulkAccountTransfersError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformBulkAccountTransfersError as the provided ForbiddenError
func (t *GetPlatformBulkAccountTransfersError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformBulkAccountTransfersError, using the provided ForbiddenError
func (t *GetPlatformBulkAccountTransfersError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformBulkAccountTransfersError as a InvalidRequestError
func (t GetPlatformBulkAccountTransfersError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformBulkAccountTransfersError as the provided InvalidRequestError
func (t *GetPlatformBulkAccountTransfersError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformBulkAccountTransfersError, using the provided InvalidRequestError
func (t *GetPlatformBulkAccountTransfersError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformBulkAccountTransfersError as a PlatformNotEnabledError
func (t GetPlatformBulkAccountTransfersError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformBulkAccountTransfersError as the provided PlatformNotEnabledError
func (t *GetPlatformBulkAccountTransfersError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformBulkAccountTransfersError, using the provided PlatformNotEnabledError
func (t *GetPlatformBulkAccountTransfersError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformBulkAccountTransfersError as a UnauthorizedError
func (t GetPlatformBulkAccountTransfersError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformBulkAccountTransfersError as the provided UnauthorizedError
func (t *GetPlatformBulkAccountTransfersError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformBulkAccountTransfersError, using the provided UnauthorizedError
func (t *GetPlatformBulkAccountTransfersError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformBulkAccountTransfersError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformBulkAccountTransfersError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformBulkAccountTransfersError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformBulkAccountTransfersError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformBulkPayoutsError as a ForbiddenError
func (t GetPlatformBulkPayoutsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformBulkPayoutsError as the provided ForbiddenError
func (t *GetPlatformBulkPayoutsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformBulkPayoutsError, using the provided ForbiddenError
func (t *GetPlatformBulkPayoutsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformBulkPayoutsError as a InvalidRequestError
func (t GetPlatformBulkPayoutsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformBulkPayoutsError as the provided InvalidRequestError
func (t *GetPlatformBulkPayoutsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformBulkPayoutsError, using the provided InvalidRequestError
func (t *GetPlatformBulkPayoutsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformBulkPayoutsError as a PlatformNotEnabledError
func (t GetPlatformBulkPayoutsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformBulkPayoutsError as the provided PlatformNotEnabledError
func (t *GetPlatformBulkPayoutsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformBulkPayoutsError, using the provided PlatformNotEnabledError
func (t *GetPlatformBulkPayoutsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformBulkPayoutsError as a UnauthorizedError
func (t GetPlatformBulkPayoutsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformBulkPayoutsError as the provided UnauthorizedError
func (t *GetPlatformBulkPayoutsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformBulkPayoutsError, using the provided UnauthorizedError
func (t *GetPlatformBulkPayoutsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformBulkPayoutsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformBulkPayoutsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformBulkPayoutsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformBulkPayoutsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformCompanyStateError as a ForbiddenError
func (t GetPlatformCompanyStateError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformCompanyStateError as the provided ForbiddenError
func (t *GetPlatformCompanyStateError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided ForbiddenError
func (t *GetPlatformCompanyStateError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformCompanyStateError as a InvalidRequestError
func (t GetPlatformCompanyStateError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformCompanyStateError as the provided InvalidRequestError
func (t *GetPlatformCompanyStateError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided InvalidRequestError
func (t *GetPlatformCompanyStateError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCompanyNotFoundError returns the union data inside the GetPlatformCompanyStateError as a PlatformCompanyNotFoundError
func (t GetPlatformCompanyStateError) AsPlatformCompanyNotFoundError() (PlatformCompanyNotFoundError, error) {
	var body PlatformCompanyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCompanyNotFoundError overwrites any union data inside the GetPlatformCompanyStateError as the provided PlatformCompanyNotFoundError
func (t *GetPlatformCompanyStateError) FromPlatformCompanyNotFoundError(v PlatformCompanyNotFoundError) error {
	v.Type = "PLATFORM_COMPANY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCompanyNotFoundError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided PlatformCompanyNotFoundError
func (t *GetPlatformCompanyStateError) MergePlatformCompanyNotFoundError(v PlatformCompanyNotFoundError) error {
	v.Type = "PLATFORM_COMPANY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformExternalApiFailedError returns the union data inside the GetPlatformCompanyStateError as a PlatformExternalApiFailedError
func (t GetPlatformCompanyStateError) AsPlatformExternalApiFailedError() (PlatformExternalApiFailedError, error) {
	var body PlatformExternalApiFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalApiFailedError overwrites any union data inside the GetPlatformCompanyStateError as the provided PlatformExternalApiFailedError
func (t *GetPlatformCompanyStateError) FromPlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalApiFailedError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided PlatformExternalApiFailedError
func (t *GetPlatformCompanyStateError) MergePlatformExternalApiFailedError(v PlatformExternalApiFailedError) error {
	v.Type = "PLATFORM_EXTERNAL_API_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformCompanyStateError as a PlatformNotEnabledError
func (t GetPlatformCompanyStateError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformCompanyStateError as the provided PlatformNotEnabledError
func (t *GetPlatformCompanyStateError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided PlatformNotEnabledError
func (t *GetPlatformCompanyStateError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformCompanyStateError as a UnauthorizedError
func (t GetPlatformCompanyStateError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformCompanyStateError as the provided UnauthorizedError
func (t *GetPlatformCompanyStateError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformCompanyStateError, using the provided UnauthorizedError
func (t *GetPlatformCompanyStateError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformCompanyStateError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformCompanyStateError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_COMPANY_NOT_FOUND":
		return t.AsPlatformCompanyNotFoundError()
	case "PLATFORM_EXTERNAL_API_FAILED":
		return t.AsPlatformExternalApiFailedError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformCompanyStateError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformCompanyStateError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformContractError as a ForbiddenError
func (t GetPlatformContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformContractError as the provided ForbiddenError
func (t *GetPlatformContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformContractError, using the provided ForbiddenError
func (t *GetPlatformContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformContractError as a InvalidRequestError
func (t GetPlatformContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformContractError as the provided InvalidRequestError
func (t *GetPlatformContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformContractError, using the provided InvalidRequestError
func (t *GetPlatformContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the GetPlatformContractError as a PlatformContractNotFoundError
func (t GetPlatformContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the GetPlatformContractError as the provided PlatformContractNotFoundError
func (t *GetPlatformContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the GetPlatformContractError, using the provided PlatformContractNotFoundError
func (t *GetPlatformContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformContractError as a PlatformNotEnabledError
func (t GetPlatformContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformContractError as the provided PlatformNotEnabledError
func (t *GetPlatformContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformContractError, using the provided PlatformNotEnabledError
func (t *GetPlatformContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformContractError as a UnauthorizedError
func (t GetPlatformContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformContractError as the provided UnauthorizedError
func (t *GetPlatformContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformContractError, using the provided UnauthorizedError
func (t *GetPlatformContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformContractScheduleError as a ForbiddenError
func (t GetPlatformContractScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformContractScheduleError as the provided ForbiddenError
func (t *GetPlatformContractScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformContractScheduleError, using the provided ForbiddenError
func (t *GetPlatformContractScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformContractScheduleError as a InvalidRequestError
func (t GetPlatformContractScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformContractScheduleError as the provided InvalidRequestError
func (t *GetPlatformContractScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformContractScheduleError, using the provided InvalidRequestError
func (t *GetPlatformContractScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the GetPlatformContractScheduleError as a PlatformContractNotFoundError
func (t GetPlatformContractScheduleError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the GetPlatformContractScheduleError as the provided PlatformContractNotFoundError
func (t *GetPlatformContractScheduleError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the GetPlatformContractScheduleError, using the provided PlatformContractNotFoundError
func (t *GetPlatformContractScheduleError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformContractScheduleError as a PlatformNotEnabledError
func (t GetPlatformContractScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformContractScheduleError as the provided PlatformNotEnabledError
func (t *GetPlatformContractScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformContractScheduleError, using the provided PlatformNotEnabledError
func (t *GetPlatformContractScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformContractScheduleError as a UnauthorizedError
func (t GetPlatformContractScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformContractScheduleError as the provided UnauthorizedError
func (t *GetPlatformContractScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformContractScheduleError, using the provided UnauthorizedError
func (t *GetPlatformContractScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformContractScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformContractScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformContractScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformContractScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformContractsError as a ForbiddenError
func (t GetPlatformContractsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformContractsError as the provided ForbiddenError
func (t *GetPlatformContractsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformContractsError, using the provided ForbiddenError
func (t *GetPlatformContractsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformContractsError as a InvalidRequestError
func (t GetPlatformContractsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformContractsError as the provided InvalidRequestError
func (t *GetPlatformContractsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformContractsError, using the provided InvalidRequestError
func (t *GetPlatformContractsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformContractsError as a PlatformNotEnabledError
func (t GetPlatformContractsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformContractsError as the provided PlatformNotEnabledError
func (t *GetPlatformContractsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformContractsError, using the provided PlatformNotEnabledError
func (t *GetPlatformContractsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformContractsError as a UnauthorizedError
func (t GetPlatformContractsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformContractsError as the provided UnauthorizedError
func (t *GetPlatformContractsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformContractsError, using the provided UnauthorizedError
func (t *GetPlatformContractsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformContractsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformContractsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformContractsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformContractsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformDiscountSharePoliciesError as a ForbiddenError
func (t GetPlatformDiscountSharePoliciesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformDiscountSharePoliciesError as the provided ForbiddenError
func (t *GetPlatformDiscountSharePoliciesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformDiscountSharePoliciesError, using the provided ForbiddenError
func (t *GetPlatformDiscountSharePoliciesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformDiscountSharePoliciesError as a InvalidRequestError
func (t GetPlatformDiscountSharePoliciesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformDiscountSharePoliciesError as the provided InvalidRequestError
func (t *GetPlatformDiscountSharePoliciesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformDiscountSharePoliciesError, using the provided InvalidRequestError
func (t *GetPlatformDiscountSharePoliciesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformDiscountSharePoliciesError as a PlatformNotEnabledError
func (t GetPlatformDiscountSharePoliciesError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformDiscountSharePoliciesError as the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePoliciesError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformDiscountSharePoliciesError, using the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePoliciesError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformDiscountSharePoliciesError as a UnauthorizedError
func (t GetPlatformDiscountSharePoliciesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformDiscountSharePoliciesError as the provided UnauthorizedError
func (t *GetPlatformDiscountSharePoliciesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformDiscountSharePoliciesError, using the provided UnauthorizedError
func (t *GetPlatformDiscountSharePoliciesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformDiscountSharePoliciesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformDiscountSharePoliciesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformDiscountSharePoliciesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformDiscountSharePoliciesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformDiscountSharePolicyError as a ForbiddenError
func (t GetPlatformDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformDiscountSharePolicyError as the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformDiscountSharePolicyError, using the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformDiscountSharePolicyError as a InvalidRequestError
func (t GetPlatformDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformDiscountSharePolicyError as the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformDiscountSharePolicyError, using the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the GetPlatformDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t GetPlatformDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the GetPlatformDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *GetPlatformDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the GetPlatformDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *GetPlatformDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformDiscountSharePolicyError as a PlatformNotEnabledError
func (t GetPlatformDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformDiscountSharePolicyError as a UnauthorizedError
func (t GetPlatformDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformDiscountSharePolicyError as the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformDiscountSharePolicyError, using the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as a ForbiddenError
func (t GetPlatformDiscountSharePolicyFilterOptionsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError, using the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as a InvalidRequestError
func (t GetPlatformDiscountSharePolicyFilterOptionsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError, using the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as a PlatformNotEnabledError
func (t GetPlatformDiscountSharePolicyFilterOptionsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError, using the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as a UnauthorizedError
func (t GetPlatformDiscountSharePolicyFilterOptionsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError as the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformDiscountSharePolicyFilterOptionsError, using the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyFilterOptionsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformDiscountSharePolicyFilterOptionsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformDiscountSharePolicyFilterOptionsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformDiscountSharePolicyFilterOptionsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformDiscountSharePolicyFilterOptionsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformDiscountSharePolicyScheduleError as a ForbiddenError
func (t GetPlatformDiscountSharePolicyScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformDiscountSharePolicyScheduleError as the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformDiscountSharePolicyScheduleError, using the provided ForbiddenError
func (t *GetPlatformDiscountSharePolicyScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformDiscountSharePolicyScheduleError as a InvalidRequestError
func (t GetPlatformDiscountSharePolicyScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformDiscountSharePolicyScheduleError as the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformDiscountSharePolicyScheduleError, using the provided InvalidRequestError
func (t *GetPlatformDiscountSharePolicyScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the GetPlatformDiscountSharePolicyScheduleError as a PlatformDiscountSharePolicyNotFoundError
func (t GetPlatformDiscountSharePolicyScheduleError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the GetPlatformDiscountSharePolicyScheduleError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *GetPlatformDiscountSharePolicyScheduleError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the GetPlatformDiscountSharePolicyScheduleError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *GetPlatformDiscountSharePolicyScheduleError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformDiscountSharePolicyScheduleError as a PlatformNotEnabledError
func (t GetPlatformDiscountSharePolicyScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformDiscountSharePolicyScheduleError as the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformDiscountSharePolicyScheduleError, using the provided PlatformNotEnabledError
func (t *GetPlatformDiscountSharePolicyScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformDiscountSharePolicyScheduleError as a UnauthorizedError
func (t GetPlatformDiscountSharePolicyScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformDiscountSharePolicyScheduleError as the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformDiscountSharePolicyScheduleError, using the provided UnauthorizedError
func (t *GetPlatformDiscountSharePolicyScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformDiscountSharePolicyScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformDiscountSharePolicyScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformDiscountSharePolicyScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformDiscountSharePolicyScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPartnerError as a ForbiddenError
func (t GetPlatformPartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPartnerError as the provided ForbiddenError
func (t *GetPlatformPartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPartnerError, using the provided ForbiddenError
func (t *GetPlatformPartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPartnerError as a InvalidRequestError
func (t GetPlatformPartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPartnerError as the provided InvalidRequestError
func (t *GetPlatformPartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPartnerError, using the provided InvalidRequestError
func (t *GetPlatformPartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPartnerError as a PlatformNotEnabledError
func (t GetPlatformPartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPartnerError as the provided PlatformNotEnabledError
func (t *GetPlatformPartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPartnerError, using the provided PlatformNotEnabledError
func (t *GetPlatformPartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the GetPlatformPartnerError as a PlatformPartnerNotFoundError
func (t GetPlatformPartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the GetPlatformPartnerError as the provided PlatformPartnerNotFoundError
func (t *GetPlatformPartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the GetPlatformPartnerError, using the provided PlatformPartnerNotFoundError
func (t *GetPlatformPartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPartnerError as a UnauthorizedError
func (t GetPlatformPartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPartnerError as the provided UnauthorizedError
func (t *GetPlatformPartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPartnerError, using the provided UnauthorizedError
func (t *GetPlatformPartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPartnerFilterOptionsError as a ForbiddenError
func (t GetPlatformPartnerFilterOptionsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPartnerFilterOptionsError as the provided ForbiddenError
func (t *GetPlatformPartnerFilterOptionsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPartnerFilterOptionsError, using the provided ForbiddenError
func (t *GetPlatformPartnerFilterOptionsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPartnerFilterOptionsError as a InvalidRequestError
func (t GetPlatformPartnerFilterOptionsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPartnerFilterOptionsError as the provided InvalidRequestError
func (t *GetPlatformPartnerFilterOptionsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPartnerFilterOptionsError, using the provided InvalidRequestError
func (t *GetPlatformPartnerFilterOptionsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPartnerFilterOptionsError as a PlatformNotEnabledError
func (t GetPlatformPartnerFilterOptionsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPartnerFilterOptionsError as the provided PlatformNotEnabledError
func (t *GetPlatformPartnerFilterOptionsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPartnerFilterOptionsError, using the provided PlatformNotEnabledError
func (t *GetPlatformPartnerFilterOptionsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPartnerFilterOptionsError as a UnauthorizedError
func (t GetPlatformPartnerFilterOptionsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPartnerFilterOptionsError as the provided UnauthorizedError
func (t *GetPlatformPartnerFilterOptionsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPartnerFilterOptionsError, using the provided UnauthorizedError
func (t *GetPlatformPartnerFilterOptionsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPartnerFilterOptionsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPartnerFilterOptionsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPartnerFilterOptionsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPartnerFilterOptionsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPartnerScheduleError as a ForbiddenError
func (t GetPlatformPartnerScheduleError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPartnerScheduleError as the provided ForbiddenError
func (t *GetPlatformPartnerScheduleError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPartnerScheduleError, using the provided ForbiddenError
func (t *GetPlatformPartnerScheduleError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPartnerScheduleError as a InvalidRequestError
func (t GetPlatformPartnerScheduleError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPartnerScheduleError as the provided InvalidRequestError
func (t *GetPlatformPartnerScheduleError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPartnerScheduleError, using the provided InvalidRequestError
func (t *GetPlatformPartnerScheduleError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPartnerScheduleError as a PlatformNotEnabledError
func (t GetPlatformPartnerScheduleError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPartnerScheduleError as the provided PlatformNotEnabledError
func (t *GetPlatformPartnerScheduleError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPartnerScheduleError, using the provided PlatformNotEnabledError
func (t *GetPlatformPartnerScheduleError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the GetPlatformPartnerScheduleError as a PlatformPartnerNotFoundError
func (t GetPlatformPartnerScheduleError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the GetPlatformPartnerScheduleError as the provided PlatformPartnerNotFoundError
func (t *GetPlatformPartnerScheduleError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the GetPlatformPartnerScheduleError, using the provided PlatformPartnerNotFoundError
func (t *GetPlatformPartnerScheduleError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPartnerScheduleError as a UnauthorizedError
func (t GetPlatformPartnerScheduleError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPartnerScheduleError as the provided UnauthorizedError
func (t *GetPlatformPartnerScheduleError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPartnerScheduleError, using the provided UnauthorizedError
func (t *GetPlatformPartnerScheduleError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPartnerScheduleError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPartnerScheduleError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPartnerScheduleError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPartnerScheduleError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPartnerSettlementsError as a ForbiddenError
func (t GetPlatformPartnerSettlementsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPartnerSettlementsError as the provided ForbiddenError
func (t *GetPlatformPartnerSettlementsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPartnerSettlementsError, using the provided ForbiddenError
func (t *GetPlatformPartnerSettlementsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPartnerSettlementsError as a InvalidRequestError
func (t GetPlatformPartnerSettlementsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPartnerSettlementsError as the provided InvalidRequestError
func (t *GetPlatformPartnerSettlementsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPartnerSettlementsError, using the provided InvalidRequestError
func (t *GetPlatformPartnerSettlementsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPartnerSettlementsError as a PlatformNotEnabledError
func (t GetPlatformPartnerSettlementsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPartnerSettlementsError as the provided PlatformNotEnabledError
func (t *GetPlatformPartnerSettlementsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPartnerSettlementsError, using the provided PlatformNotEnabledError
func (t *GetPlatformPartnerSettlementsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPartnerSettlementsError as a UnauthorizedError
func (t GetPlatformPartnerSettlementsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPartnerSettlementsError as the provided UnauthorizedError
func (t *GetPlatformPartnerSettlementsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPartnerSettlementsError, using the provided UnauthorizedError
func (t *GetPlatformPartnerSettlementsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPartnerSettlementsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPartnerSettlementsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPartnerSettlementsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPartnerSettlementsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPartnersError as a ForbiddenError
func (t GetPlatformPartnersError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPartnersError as the provided ForbiddenError
func (t *GetPlatformPartnersError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPartnersError, using the provided ForbiddenError
func (t *GetPlatformPartnersError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPartnersError as a InvalidRequestError
func (t GetPlatformPartnersError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPartnersError as the provided InvalidRequestError
func (t *GetPlatformPartnersError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPartnersError, using the provided InvalidRequestError
func (t *GetPlatformPartnersError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPartnersError as a PlatformNotEnabledError
func (t GetPlatformPartnersError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPartnersError as the provided PlatformNotEnabledError
func (t *GetPlatformPartnersError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPartnersError, using the provided PlatformNotEnabledError
func (t *GetPlatformPartnersError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPartnersError as a UnauthorizedError
func (t GetPlatformPartnersError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPartnersError as the provided UnauthorizedError
func (t *GetPlatformPartnersError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPartnersError, using the provided UnauthorizedError
func (t *GetPlatformPartnersError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPartnersError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPartnersError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPartnersError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPartnersError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformPayoutsError as a ForbiddenError
func (t GetPlatformPayoutsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformPayoutsError as the provided ForbiddenError
func (t *GetPlatformPayoutsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformPayoutsError, using the provided ForbiddenError
func (t *GetPlatformPayoutsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformPayoutsError as a InvalidRequestError
func (t GetPlatformPayoutsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformPayoutsError as the provided InvalidRequestError
func (t *GetPlatformPayoutsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformPayoutsError, using the provided InvalidRequestError
func (t *GetPlatformPayoutsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformPayoutsError as a PlatformNotEnabledError
func (t GetPlatformPayoutsError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformPayoutsError as the provided PlatformNotEnabledError
func (t *GetPlatformPayoutsError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformPayoutsError, using the provided PlatformNotEnabledError
func (t *GetPlatformPayoutsError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformPayoutsError as a UnauthorizedError
func (t GetPlatformPayoutsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformPayoutsError as the provided UnauthorizedError
func (t *GetPlatformPayoutsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformPayoutsError, using the provided UnauthorizedError
func (t *GetPlatformPayoutsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformPayoutsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformPayoutsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformPayoutsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformPayoutsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformSettingError as a ForbiddenError
func (t GetPlatformSettingError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformSettingError as the provided ForbiddenError
func (t *GetPlatformSettingError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformSettingError, using the provided ForbiddenError
func (t *GetPlatformSettingError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformSettingError as a InvalidRequestError
func (t GetPlatformSettingError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformSettingError as the provided InvalidRequestError
func (t *GetPlatformSettingError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformSettingError, using the provided InvalidRequestError
func (t *GetPlatformSettingError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformSettingError as a PlatformNotEnabledError
func (t GetPlatformSettingError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformSettingError as the provided PlatformNotEnabledError
func (t *GetPlatformSettingError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformSettingError, using the provided PlatformNotEnabledError
func (t *GetPlatformSettingError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformSettingError as a UnauthorizedError
func (t GetPlatformSettingError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformSettingError as the provided UnauthorizedError
func (t *GetPlatformSettingError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformSettingError, using the provided UnauthorizedError
func (t *GetPlatformSettingError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformSettingError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformSettingError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformSettingError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformSettingError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformTransferError as a ForbiddenError
func (t GetPlatformTransferError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformTransferError as the provided ForbiddenError
func (t *GetPlatformTransferError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformTransferError, using the provided ForbiddenError
func (t *GetPlatformTransferError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformTransferError as a InvalidRequestError
func (t GetPlatformTransferError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformTransferError as the provided InvalidRequestError
func (t *GetPlatformTransferError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformTransferError, using the provided InvalidRequestError
func (t *GetPlatformTransferError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformTransferError as a PlatformNotEnabledError
func (t GetPlatformTransferError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformTransferError as the provided PlatformNotEnabledError
func (t *GetPlatformTransferError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformTransferError, using the provided PlatformNotEnabledError
func (t *GetPlatformTransferError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferNotFoundError returns the union data inside the GetPlatformTransferError as a PlatformTransferNotFoundError
func (t GetPlatformTransferError) AsPlatformTransferNotFoundError() (PlatformTransferNotFoundError, error) {
	var body PlatformTransferNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferNotFoundError overwrites any union data inside the GetPlatformTransferError as the provided PlatformTransferNotFoundError
func (t *GetPlatformTransferError) FromPlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferNotFoundError performs a merge with any union data inside the GetPlatformTransferError, using the provided PlatformTransferNotFoundError
func (t *GetPlatformTransferError) MergePlatformTransferNotFoundError(v PlatformTransferNotFoundError) error {
	v.Type = "PLATFORM_TRANSFER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformTransferError as a UnauthorizedError
func (t GetPlatformTransferError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformTransferError as the provided UnauthorizedError
func (t *GetPlatformTransferError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformTransferError, using the provided UnauthorizedError
func (t *GetPlatformTransferError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformTransferError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformTransferError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_TRANSFER_NOT_FOUND":
		return t.AsPlatformTransferNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformTransferError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformTransferError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPlatformTransferSummariesError as a ForbiddenError
func (t GetPlatformTransferSummariesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPlatformTransferSummariesError as the provided ForbiddenError
func (t *GetPlatformTransferSummariesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPlatformTransferSummariesError, using the provided ForbiddenError
func (t *GetPlatformTransferSummariesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPlatformTransferSummariesError as a InvalidRequestError
func (t GetPlatformTransferSummariesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPlatformTransferSummariesError as the provided InvalidRequestError
func (t *GetPlatformTransferSummariesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPlatformTransferSummariesError, using the provided InvalidRequestError
func (t *GetPlatformTransferSummariesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the GetPlatformTransferSummariesError as a PlatformNotEnabledError
func (t GetPlatformTransferSummariesError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the GetPlatformTransferSummariesError as the provided PlatformNotEnabledError
func (t *GetPlatformTransferSummariesError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the GetPlatformTransferSummariesError, using the provided PlatformNotEnabledError
func (t *GetPlatformTransferSummariesError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPlatformTransferSummariesError as a UnauthorizedError
func (t GetPlatformTransferSummariesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPlatformTransferSummariesError as the provided UnauthorizedError
func (t *GetPlatformTransferSummariesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPlatformTransferSummariesError, using the provided UnauthorizedError
func (t *GetPlatformTransferSummariesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPlatformTransferSummariesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPlatformTransferSummariesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPlatformTransferSummariesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPlatformTransferSummariesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the GetPromotionError as a ForbiddenError
func (t GetPromotionError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the GetPromotionError as the provided ForbiddenError
func (t *GetPromotionError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the GetPromotionError, using the provided ForbiddenError
func (t *GetPromotionError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the GetPromotionError as a InvalidRequestError
func (t GetPromotionError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the GetPromotionError as the provided InvalidRequestError
func (t *GetPromotionError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the GetPromotionError, using the provided InvalidRequestError
func (t *GetPromotionError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionNotFoundError returns the union data inside the GetPromotionError as a PromotionNotFoundError
func (t GetPromotionError) AsPromotionNotFoundError() (PromotionNotFoundError, error) {
	var body PromotionNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionNotFoundError overwrites any union data inside the GetPromotionError as the provided PromotionNotFoundError
func (t *GetPromotionError) FromPromotionNotFoundError(v PromotionNotFoundError) error {
	v.Type = "PROMOTION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionNotFoundError performs a merge with any union data inside the GetPromotionError, using the provided PromotionNotFoundError
func (t *GetPromotionError) MergePromotionNotFoundError(v PromotionNotFoundError) error {
	v.Type = "PROMOTION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the GetPromotionError as a UnauthorizedError
func (t GetPromotionError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the GetPromotionError as the provided UnauthorizedError
func (t *GetPromotionError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the GetPromotionError, using the provided UnauthorizedError
func (t *GetPromotionError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetPromotionError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t GetPromotionError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PROMOTION_NOT_FOUND":
		return t.AsPromotionNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t GetPromotionError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetPromotionError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFailedIdentityVerification returns the union data inside the IdentityVerification as a FailedIdentityVerification
func (t IdentityVerification) AsFailedIdentityVerification() (FailedIdentityVerification, error) {
	var body FailedIdentityVerification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedIdentityVerification overwrites any union data inside the IdentityVerification as the provided FailedIdentityVerification
func (t *IdentityVerification) FromFailedIdentityVerification(v FailedIdentityVerification) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedIdentityVerification performs a merge with any union data inside the IdentityVerification, using the provided FailedIdentityVerification
func (t *IdentityVerification) MergeFailedIdentityVerification(v FailedIdentityVerification) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReadyIdentityVerification returns the union data inside the IdentityVerification as a ReadyIdentityVerification
func (t IdentityVerification) AsReadyIdentityVerification() (ReadyIdentityVerification, error) {
	var body ReadyIdentityVerification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadyIdentityVerification overwrites any union data inside the IdentityVerification as the provided ReadyIdentityVerification
func (t *IdentityVerification) FromReadyIdentityVerification(v ReadyIdentityVerification) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadyIdentityVerification performs a merge with any union data inside the IdentityVerification, using the provided ReadyIdentityVerification
func (t *IdentityVerification) MergeReadyIdentityVerification(v ReadyIdentityVerification) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVerifiedIdentityVerification returns the union data inside the IdentityVerification as a VerifiedIdentityVerification
func (t IdentityVerification) AsVerifiedIdentityVerification() (VerifiedIdentityVerification, error) {
	var body VerifiedIdentityVerification
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVerifiedIdentityVerification overwrites any union data inside the IdentityVerification as the provided VerifiedIdentityVerification
func (t *IdentityVerification) FromVerifiedIdentityVerification(v VerifiedIdentityVerification) error {
	v.Status = "VERIFIED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVerifiedIdentityVerification performs a merge with any union data inside the IdentityVerification, using the provided VerifiedIdentityVerification
func (t *IdentityVerification) MergeVerifiedIdentityVerification(v VerifiedIdentityVerification) error {
	v.Status = "VERIFIED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IdentityVerification) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IdentityVerification) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FAILED":
		return t.AsFailedIdentityVerification()
	case "READY":
		return t.AsReadyIdentityVerification()
	case "VERIFIED":
		return t.AsVerifiedIdentityVerification()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IdentityVerification) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IdentityVerification) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the IssueB2bTaxInvoiceError as a B2bExternalServiceError
func (t IssueB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *IssueB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *IssueB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the IssueB2bTaxInvoiceError as a B2bNotEnabledError
func (t IssueB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *IssueB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *IssueB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNoSupplierDocumentKeyError returns the union data inside the IssueB2bTaxInvoiceError as a B2bTaxInvoiceNoSupplierDocumentKeyError
func (t IssueB2bTaxInvoiceError) AsB2bTaxInvoiceNoSupplierDocumentKeyError() (B2bTaxInvoiceNoSupplierDocumentKeyError, error) {
	var body B2bTaxInvoiceNoSupplierDocumentKeyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNoSupplierDocumentKeyError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bTaxInvoiceNoSupplierDocumentKeyError
func (t *IssueB2bTaxInvoiceError) FromB2bTaxInvoiceNoSupplierDocumentKeyError(v B2bTaxInvoiceNoSupplierDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNoSupplierDocumentKeyError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bTaxInvoiceNoSupplierDocumentKeyError
func (t *IssueB2bTaxInvoiceError) MergeB2bTaxInvoiceNoSupplierDocumentKeyError(v B2bTaxInvoiceNoSupplierDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotDraftedStatusError returns the union data inside the IssueB2bTaxInvoiceError as a B2bTaxInvoiceNotDraftedStatusError
func (t IssueB2bTaxInvoiceError) AsB2bTaxInvoiceNotDraftedStatusError() (B2bTaxInvoiceNotDraftedStatusError, error) {
	var body B2bTaxInvoiceNotDraftedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotDraftedStatusError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bTaxInvoiceNotDraftedStatusError
func (t *IssueB2bTaxInvoiceError) FromB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotDraftedStatusError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotDraftedStatusError
func (t *IssueB2bTaxInvoiceError) MergeB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the IssueB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t IssueB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotRequestedStatusError returns the union data inside the IssueB2bTaxInvoiceError as a B2bTaxInvoiceNotRequestedStatusError
func (t IssueB2bTaxInvoiceError) AsB2bTaxInvoiceNotRequestedStatusError() (B2bTaxInvoiceNotRequestedStatusError, error) {
	var body B2bTaxInvoiceNotRequestedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotRequestedStatusError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided B2bTaxInvoiceNotRequestedStatusError
func (t *IssueB2bTaxInvoiceError) FromB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotRequestedStatusError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotRequestedStatusError
func (t *IssueB2bTaxInvoiceError) MergeB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the IssueB2bTaxInvoiceError as a ForbiddenError
func (t IssueB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided ForbiddenError
func (t *IssueB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided ForbiddenError
func (t *IssueB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the IssueB2bTaxInvoiceError as a InvalidRequestError
func (t IssueB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided InvalidRequestError
func (t *IssueB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *IssueB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the IssueB2bTaxInvoiceError as a UnauthorizedError
func (t IssueB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the IssueB2bTaxInvoiceError as the provided UnauthorizedError
func (t *IssueB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the IssueB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *IssueB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IssueB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
		return t.AsB2bTaxInvoiceNotDraftedStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
		return t.AsB2bTaxInvoiceNotRequestedStatusError()
	case "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY":
		return t.AsB2bTaxInvoiceNoSupplierDocumentKeyError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IssueB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2BCannotChangeTaxTypeError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2BCannotChangeTaxTypeError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2BCannotChangeTaxTypeError() (B2BCannotChangeTaxTypeError, error) {
	var body B2BCannotChangeTaxTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BCannotChangeTaxTypeError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2BCannotChangeTaxTypeError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BCannotChangeTaxTypeError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2BCannotChangeTaxTypeError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2BTaxInvoiceStatusNotSendingCompletedError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2BTaxInvoiceStatusNotSendingCompletedError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2BTaxInvoiceStatusNotSendingCompletedError() (B2BTaxInvoiceStatusNotSendingCompletedError, error) {
	var body B2BTaxInvoiceStatusNotSendingCompletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BTaxInvoiceStatusNotSendingCompletedError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BTaxInvoiceStatusNotSendingCompletedError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bExternalServiceError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bExternalServiceError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bExternalServiceError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIdAlreadyExistsError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bIdAlreadyExistsError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bIdAlreadyExistsError() (B2bIdAlreadyExistsError, error) {
	var body B2bIdAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIdAlreadyExistsError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bIdAlreadyExistsError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIdAlreadyExistsError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bIdAlreadyExistsError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIssuanceTypeMismatchError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bIssuanceTypeMismatchError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bIssuanceTypeMismatchError() (B2bIssuanceTypeMismatchError, error) {
	var body B2bIssuanceTypeMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIssuanceTypeMismatchError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bIssuanceTypeMismatchError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIssuanceTypeMismatchError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bIssuanceTypeMismatchError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bModificationNotProvidedError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bModificationNotProvidedError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bModificationNotProvidedError() (B2bModificationNotProvidedError, error) {
	var body B2bModificationNotProvidedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bModificationNotProvidedError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bModificationNotProvidedError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bModificationNotProvidedError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bModificationNotProvidedError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bNotEnabledError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bNotEnabledError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bNotEnabledError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bOriginalTaxInvoiceNotFoundError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bOriginalTaxInvoiceNotFoundError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bOriginalTaxInvoiceNotFoundError() (B2bOriginalTaxInvoiceNotFoundError, error) {
	var body B2bOriginalTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bOriginalTaxInvoiceNotFoundError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bOriginalTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bOriginalTaxInvoiceNotFoundError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bOriginalTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bRecipientNotFoundError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bRecipientNotFoundError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bRecipientNotFoundError() (B2bRecipientNotFoundError, error) {
	var body B2bRecipientNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bRecipientNotFoundError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bRecipientNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bRecipientNotFoundError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bRecipientNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bSupplierNotFoundError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bSupplierNotFoundError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bSupplierNotFoundError() (B2bSupplierNotFoundError, error) {
	var body B2bSupplierNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bSupplierNotFoundError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bSupplierNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bSupplierNotFoundError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bSupplierNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bTaxInvoiceNotFoundError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bTaxInvoiceNotFoundError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError() (B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t IssueB2bTaxInvoiceImmediatelyError) AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError() (B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a ForbiddenError
func (t IssueB2bTaxInvoiceImmediatelyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided ForbiddenError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided ForbiddenError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a InvalidRequestError
func (t IssueB2bTaxInvoiceImmediatelyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided InvalidRequestError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided InvalidRequestError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the IssueB2bTaxInvoiceImmediatelyError as a UnauthorizedError
func (t IssueB2bTaxInvoiceImmediatelyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the IssueB2bTaxInvoiceImmediatelyError as the provided UnauthorizedError
func (t *IssueB2bTaxInvoiceImmediatelyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the IssueB2bTaxInvoiceImmediatelyError, using the provided UnauthorizedError
func (t *IssueB2bTaxInvoiceImmediatelyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueB2bTaxInvoiceImmediatelyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IssueB2bTaxInvoiceImmediatelyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_CANNOT_CHANGE_TAX_TYPE":
		return t.AsB2BCannotChangeTaxTypeError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_ID_ALREADY_EXISTS":
		return t.AsB2bIdAlreadyExistsError()
	case "B2B_ISSUANCE_TYPE_MISMATCH":
		return t.AsB2bIssuanceTypeMismatchError()
	case "B2B_MODIFICATION_NOT_PROVIDED":
		return t.AsB2bModificationNotProvidedError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bOriginalTaxInvoiceNotFoundError()
	case "B2B_RECIPIENT_NOT_FOUND":
		return t.AsB2bRecipientNotFoundError()
	case "B2B_SUPPLIER_NOT_FOUND":
		return t.AsB2bSupplierNotFoundError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError()
	case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
		return t.AsB2BTaxInvoiceStatusNotSendingCompletedError()
	case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IssueB2bTaxInvoiceImmediatelyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueB2bTaxInvoiceImmediatelyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChannelNotFoundError returns the union data inside the IssueBillingKeyError as a ChannelNotFoundError
func (t IssueBillingKeyError) AsChannelNotFoundError() (ChannelNotFoundError, error) {
	var body ChannelNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelNotFoundError overwrites any union data inside the IssueBillingKeyError as the provided ChannelNotFoundError
func (t *IssueBillingKeyError) FromChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelNotFoundError performs a merge with any union data inside the IssueBillingKeyError, using the provided ChannelNotFoundError
func (t *IssueBillingKeyError) MergeChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelSpecificError returns the union data inside the IssueBillingKeyError as a ChannelSpecificError
func (t IssueBillingKeyError) AsChannelSpecificError() (ChannelSpecificError, error) {
	var body ChannelSpecificError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelSpecificError overwrites any union data inside the IssueBillingKeyError as the provided ChannelSpecificError
func (t *IssueBillingKeyError) FromChannelSpecificError(v ChannelSpecificError) error {
	v.Type = "CHANNEL_SPECIFIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelSpecificError performs a merge with any union data inside the IssueBillingKeyError, using the provided ChannelSpecificError
func (t *IssueBillingKeyError) MergeChannelSpecificError(v ChannelSpecificError) error {
	v.Type = "CHANNEL_SPECIFIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the IssueBillingKeyError as a ForbiddenError
func (t IssueBillingKeyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the IssueBillingKeyError as the provided ForbiddenError
func (t *IssueBillingKeyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the IssueBillingKeyError, using the provided ForbiddenError
func (t *IssueBillingKeyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the IssueBillingKeyError as a InvalidRequestError
func (t IssueBillingKeyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the IssueBillingKeyError as the provided InvalidRequestError
func (t *IssueBillingKeyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the IssueBillingKeyError, using the provided InvalidRequestError
func (t *IssueBillingKeyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the IssueBillingKeyError as a PgProviderError
func (t IssueBillingKeyError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the IssueBillingKeyError as the provided PgProviderError
func (t *IssueBillingKeyError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the IssueBillingKeyError, using the provided PgProviderError
func (t *IssueBillingKeyError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the IssueBillingKeyError as a UnauthorizedError
func (t IssueBillingKeyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the IssueBillingKeyError as the provided UnauthorizedError
func (t *IssueBillingKeyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the IssueBillingKeyError, using the provided UnauthorizedError
func (t *IssueBillingKeyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueBillingKeyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IssueBillingKeyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHANNEL_NOT_FOUND":
		return t.AsChannelNotFoundError()
	case "CHANNEL_SPECIFIC":
		return t.AsChannelSpecificError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IssueBillingKeyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueBillingKeyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashReceiptAlreadyIssuedError returns the union data inside the IssueCashReceiptError as a CashReceiptAlreadyIssuedError
func (t IssueCashReceiptError) AsCashReceiptAlreadyIssuedError() (CashReceiptAlreadyIssuedError, error) {
	var body CashReceiptAlreadyIssuedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashReceiptAlreadyIssuedError overwrites any union data inside the IssueCashReceiptError as the provided CashReceiptAlreadyIssuedError
func (t *IssueCashReceiptError) FromCashReceiptAlreadyIssuedError(v CashReceiptAlreadyIssuedError) error {
	v.Type = "CASH_RECEIPT_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashReceiptAlreadyIssuedError performs a merge with any union data inside the IssueCashReceiptError, using the provided CashReceiptAlreadyIssuedError
func (t *IssueCashReceiptError) MergeCashReceiptAlreadyIssuedError(v CashReceiptAlreadyIssuedError) error {
	v.Type = "CASH_RECEIPT_ALREADY_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelNotFoundError returns the union data inside the IssueCashReceiptError as a ChannelNotFoundError
func (t IssueCashReceiptError) AsChannelNotFoundError() (ChannelNotFoundError, error) {
	var body ChannelNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelNotFoundError overwrites any union data inside the IssueCashReceiptError as the provided ChannelNotFoundError
func (t *IssueCashReceiptError) FromChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelNotFoundError performs a merge with any union data inside the IssueCashReceiptError, using the provided ChannelNotFoundError
func (t *IssueCashReceiptError) MergeChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the IssueCashReceiptError as a ForbiddenError
func (t IssueCashReceiptError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the IssueCashReceiptError as the provided ForbiddenError
func (t *IssueCashReceiptError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the IssueCashReceiptError, using the provided ForbiddenError
func (t *IssueCashReceiptError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the IssueCashReceiptError as a InvalidRequestError
func (t IssueCashReceiptError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the IssueCashReceiptError as the provided InvalidRequestError
func (t *IssueCashReceiptError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the IssueCashReceiptError, using the provided InvalidRequestError
func (t *IssueCashReceiptError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the IssueCashReceiptError as a PgProviderError
func (t IssueCashReceiptError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the IssueCashReceiptError as the provided PgProviderError
func (t *IssueCashReceiptError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the IssueCashReceiptError, using the provided PgProviderError
func (t *IssueCashReceiptError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the IssueCashReceiptError as a UnauthorizedError
func (t IssueCashReceiptError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the IssueCashReceiptError as the provided UnauthorizedError
func (t *IssueCashReceiptError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the IssueCashReceiptError, using the provided UnauthorizedError
func (t *IssueCashReceiptError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueCashReceiptError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IssueCashReceiptError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CASH_RECEIPT_ALREADY_ISSUED":
		return t.AsCashReceiptAlreadyIssuedError()
	case "CHANNEL_NOT_FOUND":
		return t.AsChannelNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IssueCashReceiptError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueCashReceiptError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the LoginViaApiSecretError as a InvalidRequestError
func (t LoginViaApiSecretError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the LoginViaApiSecretError as the provided InvalidRequestError
func (t *LoginViaApiSecretError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the LoginViaApiSecretError, using the provided InvalidRequestError
func (t *LoginViaApiSecretError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the LoginViaApiSecretError as a UnauthorizedError
func (t LoginViaApiSecretError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the LoginViaApiSecretError as the provided UnauthorizedError
func (t *LoginViaApiSecretError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the LoginViaApiSecretError, using the provided UnauthorizedError
func (t *LoginViaApiSecretError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LoginViaApiSecretError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t LoginViaApiSecretError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t LoginViaApiSecretError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LoginViaApiSecretError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ModifyEscrowLogisticsError as a ForbiddenError
func (t ModifyEscrowLogisticsError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ModifyEscrowLogisticsError as the provided ForbiddenError
func (t *ModifyEscrowLogisticsError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided ForbiddenError
func (t *ModifyEscrowLogisticsError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ModifyEscrowLogisticsError as a InvalidRequestError
func (t ModifyEscrowLogisticsError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ModifyEscrowLogisticsError as the provided InvalidRequestError
func (t *ModifyEscrowLogisticsError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided InvalidRequestError
func (t *ModifyEscrowLogisticsError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the ModifyEscrowLogisticsError as a PaymentNotFoundError
func (t ModifyEscrowLogisticsError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the ModifyEscrowLogisticsError as the provided PaymentNotFoundError
func (t *ModifyEscrowLogisticsError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided PaymentNotFoundError
func (t *ModifyEscrowLogisticsError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the ModifyEscrowLogisticsError as a PaymentNotPaidError
func (t ModifyEscrowLogisticsError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the ModifyEscrowLogisticsError as the provided PaymentNotPaidError
func (t *ModifyEscrowLogisticsError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided PaymentNotPaidError
func (t *ModifyEscrowLogisticsError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ModifyEscrowLogisticsError as a PgProviderError
func (t ModifyEscrowLogisticsError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ModifyEscrowLogisticsError as the provided PgProviderError
func (t *ModifyEscrowLogisticsError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided PgProviderError
func (t *ModifyEscrowLogisticsError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ModifyEscrowLogisticsError as a UnauthorizedError
func (t ModifyEscrowLogisticsError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ModifyEscrowLogisticsError as the provided UnauthorizedError
func (t *ModifyEscrowLogisticsError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ModifyEscrowLogisticsError, using the provided UnauthorizedError
func (t *ModifyEscrowLogisticsError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModifyEscrowLogisticsError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ModifyEscrowLogisticsError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ModifyEscrowLogisticsError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModifyEscrowLogisticsError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlreadyPaidError returns the union data inside the PayInstantlyError as a AlreadyPaidError
func (t PayInstantlyError) AsAlreadyPaidError() (AlreadyPaidError, error) {
	var body AlreadyPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlreadyPaidError overwrites any union data inside the PayInstantlyError as the provided AlreadyPaidError
func (t *PayInstantlyError) FromAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlreadyPaidError performs a merge with any union data inside the PayInstantlyError, using the provided AlreadyPaidError
func (t *PayInstantlyError) MergeAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelNotFoundError returns the union data inside the PayInstantlyError as a ChannelNotFoundError
func (t PayInstantlyError) AsChannelNotFoundError() (ChannelNotFoundError, error) {
	var body ChannelNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelNotFoundError overwrites any union data inside the PayInstantlyError as the provided ChannelNotFoundError
func (t *PayInstantlyError) FromChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelNotFoundError performs a merge with any union data inside the PayInstantlyError, using the provided ChannelNotFoundError
func (t *PayInstantlyError) MergeChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscountAmountExceedsTotalAmountError returns the union data inside the PayInstantlyError as a DiscountAmountExceedsTotalAmountError
func (t PayInstantlyError) AsDiscountAmountExceedsTotalAmountError() (DiscountAmountExceedsTotalAmountError, error) {
	var body DiscountAmountExceedsTotalAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountAmountExceedsTotalAmountError overwrites any union data inside the PayInstantlyError as the provided DiscountAmountExceedsTotalAmountError
func (t *PayInstantlyError) FromDiscountAmountExceedsTotalAmountError(v DiscountAmountExceedsTotalAmountError) error {
	v.Type = "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountAmountExceedsTotalAmountError performs a merge with any union data inside the PayInstantlyError, using the provided DiscountAmountExceedsTotalAmountError
func (t *PayInstantlyError) MergeDiscountAmountExceedsTotalAmountError(v DiscountAmountExceedsTotalAmountError) error {
	v.Type = "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the PayInstantlyError as a ForbiddenError
func (t PayInstantlyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the PayInstantlyError as the provided ForbiddenError
func (t *PayInstantlyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the PayInstantlyError, using the provided ForbiddenError
func (t *PayInstantlyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the PayInstantlyError as a InvalidRequestError
func (t PayInstantlyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the PayInstantlyError as the provided InvalidRequestError
func (t *PayInstantlyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the PayInstantlyError, using the provided InvalidRequestError
func (t *PayInstantlyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMaxTransactionCountReachedError returns the union data inside the PayInstantlyError as a MaxTransactionCountReachedError
func (t PayInstantlyError) AsMaxTransactionCountReachedError() (MaxTransactionCountReachedError, error) {
	var body MaxTransactionCountReachedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMaxTransactionCountReachedError overwrites any union data inside the PayInstantlyError as the provided MaxTransactionCountReachedError
func (t *PayInstantlyError) FromMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMaxTransactionCountReachedError performs a merge with any union data inside the PayInstantlyError, using the provided MaxTransactionCountReachedError
func (t *PayInstantlyError) MergeMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyExistsError returns the union data inside the PayInstantlyError as a PaymentScheduleAlreadyExistsError
func (t PayInstantlyError) AsPaymentScheduleAlreadyExistsError() (PaymentScheduleAlreadyExistsError, error) {
	var body PaymentScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyExistsError overwrites any union data inside the PayInstantlyError as the provided PaymentScheduleAlreadyExistsError
func (t *PayInstantlyError) FromPaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyExistsError performs a merge with any union data inside the PayInstantlyError, using the provided PaymentScheduleAlreadyExistsError
func (t *PayInstantlyError) MergePaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the PayInstantlyError as a PgProviderError
func (t PayInstantlyError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the PayInstantlyError as the provided PgProviderError
func (t *PayInstantlyError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the PayInstantlyError, using the provided PgProviderError
func (t *PayInstantlyError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionPayMethodDoesNotMatchError returns the union data inside the PayInstantlyError as a PromotionPayMethodDoesNotMatchError
func (t PayInstantlyError) AsPromotionPayMethodDoesNotMatchError() (PromotionPayMethodDoesNotMatchError, error) {
	var body PromotionPayMethodDoesNotMatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionPayMethodDoesNotMatchError overwrites any union data inside the PayInstantlyError as the provided PromotionPayMethodDoesNotMatchError
func (t *PayInstantlyError) FromPromotionPayMethodDoesNotMatchError(v PromotionPayMethodDoesNotMatchError) error {
	v.Type = "PROMOTION_PAY_METHOD_DOES_NOT_MATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionPayMethodDoesNotMatchError performs a merge with any union data inside the PayInstantlyError, using the provided PromotionPayMethodDoesNotMatchError
func (t *PayInstantlyError) MergePromotionPayMethodDoesNotMatchError(v PromotionPayMethodDoesNotMatchError) error {
	v.Type = "PROMOTION_PAY_METHOD_DOES_NOT_MATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSumOfPartsExceedsTotalAmountError returns the union data inside the PayInstantlyError as a SumOfPartsExceedsTotalAmountError
func (t PayInstantlyError) AsSumOfPartsExceedsTotalAmountError() (SumOfPartsExceedsTotalAmountError, error) {
	var body SumOfPartsExceedsTotalAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSumOfPartsExceedsTotalAmountError overwrites any union data inside the PayInstantlyError as the provided SumOfPartsExceedsTotalAmountError
func (t *PayInstantlyError) FromSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSumOfPartsExceedsTotalAmountError performs a merge with any union data inside the PayInstantlyError, using the provided SumOfPartsExceedsTotalAmountError
func (t *PayInstantlyError) MergeSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the PayInstantlyError as a UnauthorizedError
func (t PayInstantlyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the PayInstantlyError as the provided UnauthorizedError
func (t *PayInstantlyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the PayInstantlyError, using the provided UnauthorizedError
func (t *PayInstantlyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PayInstantlyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PayInstantlyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ALREADY_PAID":
		return t.AsAlreadyPaidError()
	case "CHANNEL_NOT_FOUND":
		return t.AsChannelNotFoundError()
	case "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT":
		return t.AsDiscountAmountExceedsTotalAmountError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "MAX_TRANSACTION_COUNT_REACHED":
		return t.AsMaxTransactionCountReachedError()
	case "PAYMENT_SCHEDULE_ALREADY_EXISTS":
		return t.AsPaymentScheduleAlreadyExistsError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "PROMOTION_PAY_METHOD_DOES_NOT_MATCH":
		return t.AsPromotionPayMethodDoesNotMatchError()
	case "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT":
		return t.AsSumOfPartsExceedsTotalAmountError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PayInstantlyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayInstantlyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlreadyPaidError returns the union data inside the PayWithBillingKeyError as a AlreadyPaidError
func (t PayWithBillingKeyError) AsAlreadyPaidError() (AlreadyPaidError, error) {
	var body AlreadyPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlreadyPaidError overwrites any union data inside the PayWithBillingKeyError as the provided AlreadyPaidError
func (t *PayWithBillingKeyError) FromAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlreadyPaidError performs a merge with any union data inside the PayWithBillingKeyError, using the provided AlreadyPaidError
func (t *PayWithBillingKeyError) MergeAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyAlreadyDeletedError returns the union data inside the PayWithBillingKeyError as a BillingKeyAlreadyDeletedError
func (t PayWithBillingKeyError) AsBillingKeyAlreadyDeletedError() (BillingKeyAlreadyDeletedError, error) {
	var body BillingKeyAlreadyDeletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyDeletedError overwrites any union data inside the PayWithBillingKeyError as the provided BillingKeyAlreadyDeletedError
func (t *PayWithBillingKeyError) FromBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyDeletedError performs a merge with any union data inside the PayWithBillingKeyError, using the provided BillingKeyAlreadyDeletedError
func (t *PayWithBillingKeyError) MergeBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the PayWithBillingKeyError as a BillingKeyNotFoundError
func (t PayWithBillingKeyError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the PayWithBillingKeyError as the provided BillingKeyNotFoundError
func (t *PayWithBillingKeyError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the PayWithBillingKeyError, using the provided BillingKeyNotFoundError
func (t *PayWithBillingKeyError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChannelNotFoundError returns the union data inside the PayWithBillingKeyError as a ChannelNotFoundError
func (t PayWithBillingKeyError) AsChannelNotFoundError() (ChannelNotFoundError, error) {
	var body ChannelNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelNotFoundError overwrites any union data inside the PayWithBillingKeyError as the provided ChannelNotFoundError
func (t *PayWithBillingKeyError) FromChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelNotFoundError performs a merge with any union data inside the PayWithBillingKeyError, using the provided ChannelNotFoundError
func (t *PayWithBillingKeyError) MergeChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscountAmountExceedsTotalAmountError returns the union data inside the PayWithBillingKeyError as a DiscountAmountExceedsTotalAmountError
func (t PayWithBillingKeyError) AsDiscountAmountExceedsTotalAmountError() (DiscountAmountExceedsTotalAmountError, error) {
	var body DiscountAmountExceedsTotalAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountAmountExceedsTotalAmountError overwrites any union data inside the PayWithBillingKeyError as the provided DiscountAmountExceedsTotalAmountError
func (t *PayWithBillingKeyError) FromDiscountAmountExceedsTotalAmountError(v DiscountAmountExceedsTotalAmountError) error {
	v.Type = "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountAmountExceedsTotalAmountError performs a merge with any union data inside the PayWithBillingKeyError, using the provided DiscountAmountExceedsTotalAmountError
func (t *PayWithBillingKeyError) MergeDiscountAmountExceedsTotalAmountError(v DiscountAmountExceedsTotalAmountError) error {
	v.Type = "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the PayWithBillingKeyError as a ForbiddenError
func (t PayWithBillingKeyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the PayWithBillingKeyError as the provided ForbiddenError
func (t *PayWithBillingKeyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the PayWithBillingKeyError, using the provided ForbiddenError
func (t *PayWithBillingKeyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the PayWithBillingKeyError as a InvalidRequestError
func (t PayWithBillingKeyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the PayWithBillingKeyError as the provided InvalidRequestError
func (t *PayWithBillingKeyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the PayWithBillingKeyError, using the provided InvalidRequestError
func (t *PayWithBillingKeyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMaxTransactionCountReachedError returns the union data inside the PayWithBillingKeyError as a MaxTransactionCountReachedError
func (t PayWithBillingKeyError) AsMaxTransactionCountReachedError() (MaxTransactionCountReachedError, error) {
	var body MaxTransactionCountReachedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMaxTransactionCountReachedError overwrites any union data inside the PayWithBillingKeyError as the provided MaxTransactionCountReachedError
func (t *PayWithBillingKeyError) FromMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMaxTransactionCountReachedError performs a merge with any union data inside the PayWithBillingKeyError, using the provided MaxTransactionCountReachedError
func (t *PayWithBillingKeyError) MergeMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyExistsError returns the union data inside the PayWithBillingKeyError as a PaymentScheduleAlreadyExistsError
func (t PayWithBillingKeyError) AsPaymentScheduleAlreadyExistsError() (PaymentScheduleAlreadyExistsError, error) {
	var body PaymentScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyExistsError overwrites any union data inside the PayWithBillingKeyError as the provided PaymentScheduleAlreadyExistsError
func (t *PayWithBillingKeyError) FromPaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyExistsError performs a merge with any union data inside the PayWithBillingKeyError, using the provided PaymentScheduleAlreadyExistsError
func (t *PayWithBillingKeyError) MergePaymentScheduleAlreadyExistsError(v PaymentScheduleAlreadyExistsError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the PayWithBillingKeyError as a PgProviderError
func (t PayWithBillingKeyError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the PayWithBillingKeyError as the provided PgProviderError
func (t *PayWithBillingKeyError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the PayWithBillingKeyError, using the provided PgProviderError
func (t *PayWithBillingKeyError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionPayMethodDoesNotMatchError returns the union data inside the PayWithBillingKeyError as a PromotionPayMethodDoesNotMatchError
func (t PayWithBillingKeyError) AsPromotionPayMethodDoesNotMatchError() (PromotionPayMethodDoesNotMatchError, error) {
	var body PromotionPayMethodDoesNotMatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionPayMethodDoesNotMatchError overwrites any union data inside the PayWithBillingKeyError as the provided PromotionPayMethodDoesNotMatchError
func (t *PayWithBillingKeyError) FromPromotionPayMethodDoesNotMatchError(v PromotionPayMethodDoesNotMatchError) error {
	v.Type = "PROMOTION_PAY_METHOD_DOES_NOT_MATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionPayMethodDoesNotMatchError performs a merge with any union data inside the PayWithBillingKeyError, using the provided PromotionPayMethodDoesNotMatchError
func (t *PayWithBillingKeyError) MergePromotionPayMethodDoesNotMatchError(v PromotionPayMethodDoesNotMatchError) error {
	v.Type = "PROMOTION_PAY_METHOD_DOES_NOT_MATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSumOfPartsExceedsTotalAmountError returns the union data inside the PayWithBillingKeyError as a SumOfPartsExceedsTotalAmountError
func (t PayWithBillingKeyError) AsSumOfPartsExceedsTotalAmountError() (SumOfPartsExceedsTotalAmountError, error) {
	var body SumOfPartsExceedsTotalAmountError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSumOfPartsExceedsTotalAmountError overwrites any union data inside the PayWithBillingKeyError as the provided SumOfPartsExceedsTotalAmountError
func (t *PayWithBillingKeyError) FromSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSumOfPartsExceedsTotalAmountError performs a merge with any union data inside the PayWithBillingKeyError, using the provided SumOfPartsExceedsTotalAmountError
func (t *PayWithBillingKeyError) MergeSumOfPartsExceedsTotalAmountError(v SumOfPartsExceedsTotalAmountError) error {
	v.Type = "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the PayWithBillingKeyError as a UnauthorizedError
func (t PayWithBillingKeyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the PayWithBillingKeyError as the provided UnauthorizedError
func (t *PayWithBillingKeyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the PayWithBillingKeyError, using the provided UnauthorizedError
func (t *PayWithBillingKeyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PayWithBillingKeyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PayWithBillingKeyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ALREADY_PAID":
		return t.AsAlreadyPaidError()
	case "BILLING_KEY_ALREADY_DELETED":
		return t.AsBillingKeyAlreadyDeletedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "CHANNEL_NOT_FOUND":
		return t.AsChannelNotFoundError()
	case "DISCOUNT_AMOUNT_EXCEEDS_TOTAL_AMOUNT":
		return t.AsDiscountAmountExceedsTotalAmountError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "MAX_TRANSACTION_COUNT_REACHED":
		return t.AsMaxTransactionCountReachedError()
	case "PAYMENT_SCHEDULE_ALREADY_EXISTS":
		return t.AsPaymentScheduleAlreadyExistsError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "PROMOTION_PAY_METHOD_DOES_NOT_MATCH":
		return t.AsPromotionPayMethodDoesNotMatchError()
	case "SUM_OF_PARTS_EXCEEDS_TOTAL_AMOUNT":
		return t.AsSumOfPartsExceedsTotalAmountError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PayWithBillingKeyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PayWithBillingKeyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelledPayment returns the union data inside the Payment as a CancelledPayment
func (t Payment) AsCancelledPayment() (CancelledPayment, error) {
	var body CancelledPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledPayment overwrites any union data inside the Payment as the provided CancelledPayment
func (t *Payment) FromCancelledPayment(v CancelledPayment) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledPayment performs a merge with any union data inside the Payment, using the provided CancelledPayment
func (t *Payment) MergeCancelledPayment(v CancelledPayment) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFailedPayment returns the union data inside the Payment as a FailedPayment
func (t Payment) AsFailedPayment() (FailedPayment, error) {
	var body FailedPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedPayment overwrites any union data inside the Payment as the provided FailedPayment
func (t *Payment) FromFailedPayment(v FailedPayment) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedPayment performs a merge with any union data inside the Payment, using the provided FailedPayment
func (t *Payment) MergeFailedPayment(v FailedPayment) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaidPayment returns the union data inside the Payment as a PaidPayment
func (t Payment) AsPaidPayment() (PaidPayment, error) {
	var body PaidPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaidPayment overwrites any union data inside the Payment as the provided PaidPayment
func (t *Payment) FromPaidPayment(v PaidPayment) error {
	v.Status = "PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaidPayment performs a merge with any union data inside the Payment, using the provided PaidPayment
func (t *Payment) MergePaidPayment(v PaidPayment) error {
	v.Status = "PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartialCancelledPayment returns the union data inside the Payment as a PartialCancelledPayment
func (t Payment) AsPartialCancelledPayment() (PartialCancelledPayment, error) {
	var body PartialCancelledPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartialCancelledPayment overwrites any union data inside the Payment as the provided PartialCancelledPayment
func (t *Payment) FromPartialCancelledPayment(v PartialCancelledPayment) error {
	v.Status = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartialCancelledPayment performs a merge with any union data inside the Payment, using the provided PartialCancelledPayment
func (t *Payment) MergePartialCancelledPayment(v PartialCancelledPayment) error {
	v.Status = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPayPendingPayment returns the union data inside the Payment as a PayPendingPayment
func (t Payment) AsPayPendingPayment() (PayPendingPayment, error) {
	var body PayPendingPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayPendingPayment overwrites any union data inside the Payment as the provided PayPendingPayment
func (t *Payment) FromPayPendingPayment(v PayPendingPayment) error {
	v.Status = "PAY_PENDING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayPendingPayment performs a merge with any union data inside the Payment, using the provided PayPendingPayment
func (t *Payment) MergePayPendingPayment(v PayPendingPayment) error {
	v.Status = "PAY_PENDING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReadyPayment returns the union data inside the Payment as a ReadyPayment
func (t Payment) AsReadyPayment() (ReadyPayment, error) {
	var body ReadyPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadyPayment overwrites any union data inside the Payment as the provided ReadyPayment
func (t *Payment) FromReadyPayment(v ReadyPayment) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadyPayment performs a merge with any union data inside the Payment, using the provided ReadyPayment
func (t *Payment) MergeReadyPayment(v ReadyPayment) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualAccountIssuedPayment returns the union data inside the Payment as a VirtualAccountIssuedPayment
func (t Payment) AsVirtualAccountIssuedPayment() (VirtualAccountIssuedPayment, error) {
	var body VirtualAccountIssuedPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualAccountIssuedPayment overwrites any union data inside the Payment as the provided VirtualAccountIssuedPayment
func (t *Payment) FromVirtualAccountIssuedPayment(v VirtualAccountIssuedPayment) error {
	v.Status = "VIRTUAL_ACCOUNT_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualAccountIssuedPayment performs a merge with any union data inside the Payment, using the provided VirtualAccountIssuedPayment
func (t *Payment) MergeVirtualAccountIssuedPayment(v VirtualAccountIssuedPayment) error {
	v.Status = "VIRTUAL_ACCOUNT_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Payment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Payment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLED":
		return t.AsCancelledPayment()
	case "FAILED":
		return t.AsFailedPayment()
	case "PAID":
		return t.AsPaidPayment()
	case "PARTIAL_CANCELLED":
		return t.AsPartialCancelledPayment()
	case "PAY_PENDING":
		return t.AsPayPendingPayment()
	case "READY":
		return t.AsReadyPayment()
	case "VIRTUAL_ACCOUNT_ISSUED":
		return t.AsVirtualAccountIssuedPayment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Payment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Payment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFailedPaymentCancellation returns the union data inside the PaymentCancellation as a FailedPaymentCancellation
func (t PaymentCancellation) AsFailedPaymentCancellation() (FailedPaymentCancellation, error) {
	var body FailedPaymentCancellation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedPaymentCancellation overwrites any union data inside the PaymentCancellation as the provided FailedPaymentCancellation
func (t *PaymentCancellation) FromFailedPaymentCancellation(v FailedPaymentCancellation) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedPaymentCancellation performs a merge with any union data inside the PaymentCancellation, using the provided FailedPaymentCancellation
func (t *PaymentCancellation) MergeFailedPaymentCancellation(v FailedPaymentCancellation) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestedPaymentCancellation returns the union data inside the PaymentCancellation as a RequestedPaymentCancellation
func (t PaymentCancellation) AsRequestedPaymentCancellation() (RequestedPaymentCancellation, error) {
	var body RequestedPaymentCancellation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestedPaymentCancellation overwrites any union data inside the PaymentCancellation as the provided RequestedPaymentCancellation
func (t *PaymentCancellation) FromRequestedPaymentCancellation(v RequestedPaymentCancellation) error {
	v.Status = "REQUESTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestedPaymentCancellation performs a merge with any union data inside the PaymentCancellation, using the provided RequestedPaymentCancellation
func (t *PaymentCancellation) MergeRequestedPaymentCancellation(v RequestedPaymentCancellation) error {
	v.Status = "REQUESTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSucceededPaymentCancellation returns the union data inside the PaymentCancellation as a SucceededPaymentCancellation
func (t PaymentCancellation) AsSucceededPaymentCancellation() (SucceededPaymentCancellation, error) {
	var body SucceededPaymentCancellation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSucceededPaymentCancellation overwrites any union data inside the PaymentCancellation as the provided SucceededPaymentCancellation
func (t *PaymentCancellation) FromSucceededPaymentCancellation(v SucceededPaymentCancellation) error {
	v.Status = "SUCCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSucceededPaymentCancellation performs a merge with any union data inside the PaymentCancellation, using the provided SucceededPaymentCancellation
func (t *PaymentCancellation) MergeSucceededPaymentCancellation(v SucceededPaymentCancellation) error {
	v.Status = "SUCCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentCancellation) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentCancellation) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FAILED":
		return t.AsFailedPaymentCancellation()
	case "REQUESTED":
		return t.AsRequestedPaymentCancellation()
	case "SUCCEEDED":
		return t.AsSucceededPaymentCancellation()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentCancellation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentCancellation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelledPaymentCashReceipt returns the union data inside the PaymentCashReceipt as a CancelledPaymentCashReceipt
func (t PaymentCashReceipt) AsCancelledPaymentCashReceipt() (CancelledPaymentCashReceipt, error) {
	var body CancelledPaymentCashReceipt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledPaymentCashReceipt overwrites any union data inside the PaymentCashReceipt as the provided CancelledPaymentCashReceipt
func (t *PaymentCashReceipt) FromCancelledPaymentCashReceipt(v CancelledPaymentCashReceipt) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledPaymentCashReceipt performs a merge with any union data inside the PaymentCashReceipt, using the provided CancelledPaymentCashReceipt
func (t *PaymentCashReceipt) MergeCancelledPaymentCashReceipt(v CancelledPaymentCashReceipt) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssuedPaymentCashReceipt returns the union data inside the PaymentCashReceipt as a IssuedPaymentCashReceipt
func (t PaymentCashReceipt) AsIssuedPaymentCashReceipt() (IssuedPaymentCashReceipt, error) {
	var body IssuedPaymentCashReceipt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssuedPaymentCashReceipt overwrites any union data inside the PaymentCashReceipt as the provided IssuedPaymentCashReceipt
func (t *PaymentCashReceipt) FromIssuedPaymentCashReceipt(v IssuedPaymentCashReceipt) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssuedPaymentCashReceipt performs a merge with any union data inside the PaymentCashReceipt, using the provided IssuedPaymentCashReceipt
func (t *PaymentCashReceipt) MergeIssuedPaymentCashReceipt(v IssuedPaymentCashReceipt) error {
	v.Status = "ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentCashReceipt) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentCashReceipt) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLED":
		return t.AsCancelledPaymentCashReceipt()
	case "ISSUED":
		return t.AsIssuedPaymentCashReceipt()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentCashReceipt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentCashReceipt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBeforeRegisteredPaymentEscrow returns the union data inside the PaymentEscrow as a BeforeRegisteredPaymentEscrow
func (t PaymentEscrow) AsBeforeRegisteredPaymentEscrow() (BeforeRegisteredPaymentEscrow, error) {
	var body BeforeRegisteredPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBeforeRegisteredPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided BeforeRegisteredPaymentEscrow
func (t *PaymentEscrow) FromBeforeRegisteredPaymentEscrow(v BeforeRegisteredPaymentEscrow) error {
	v.Status = "BEFORE_REGISTERED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBeforeRegisteredPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided BeforeRegisteredPaymentEscrow
func (t *PaymentEscrow) MergeBeforeRegisteredPaymentEscrow(v BeforeRegisteredPaymentEscrow) error {
	v.Status = "BEFORE_REGISTERED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCancelledPaymentEscrow returns the union data inside the PaymentEscrow as a CancelledPaymentEscrow
func (t PaymentEscrow) AsCancelledPaymentEscrow() (CancelledPaymentEscrow, error) {
	var body CancelledPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided CancelledPaymentEscrow
func (t *PaymentEscrow) FromCancelledPaymentEscrow(v CancelledPaymentEscrow) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided CancelledPaymentEscrow
func (t *PaymentEscrow) MergeCancelledPaymentEscrow(v CancelledPaymentEscrow) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfirmedPaymentEscrow returns the union data inside the PaymentEscrow as a ConfirmedPaymentEscrow
func (t PaymentEscrow) AsConfirmedPaymentEscrow() (ConfirmedPaymentEscrow, error) {
	var body ConfirmedPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfirmedPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided ConfirmedPaymentEscrow
func (t *PaymentEscrow) FromConfirmedPaymentEscrow(v ConfirmedPaymentEscrow) error {
	v.Status = "CONFIRMED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfirmedPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided ConfirmedPaymentEscrow
func (t *PaymentEscrow) MergeConfirmedPaymentEscrow(v ConfirmedPaymentEscrow) error {
	v.Status = "CONFIRMED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeliveredPaymentEscrow returns the union data inside the PaymentEscrow as a DeliveredPaymentEscrow
func (t PaymentEscrow) AsDeliveredPaymentEscrow() (DeliveredPaymentEscrow, error) {
	var body DeliveredPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeliveredPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided DeliveredPaymentEscrow
func (t *PaymentEscrow) FromDeliveredPaymentEscrow(v DeliveredPaymentEscrow) error {
	v.Status = "DELIVERED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeliveredPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided DeliveredPaymentEscrow
func (t *PaymentEscrow) MergeDeliveredPaymentEscrow(v DeliveredPaymentEscrow) error {
	v.Status = "DELIVERED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegisteredPaymentEscrow returns the union data inside the PaymentEscrow as a RegisteredPaymentEscrow
func (t PaymentEscrow) AsRegisteredPaymentEscrow() (RegisteredPaymentEscrow, error) {
	var body RegisteredPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegisteredPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided RegisteredPaymentEscrow
func (t *PaymentEscrow) FromRegisteredPaymentEscrow(v RegisteredPaymentEscrow) error {
	v.Status = "REGISTERED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegisteredPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided RegisteredPaymentEscrow
func (t *PaymentEscrow) MergeRegisteredPaymentEscrow(v RegisteredPaymentEscrow) error {
	v.Status = "REGISTERED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRejectConfirmedPaymentEscrow returns the union data inside the PaymentEscrow as a RejectConfirmedPaymentEscrow
func (t PaymentEscrow) AsRejectConfirmedPaymentEscrow() (RejectConfirmedPaymentEscrow, error) {
	var body RejectConfirmedPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRejectConfirmedPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided RejectConfirmedPaymentEscrow
func (t *PaymentEscrow) FromRejectConfirmedPaymentEscrow(v RejectConfirmedPaymentEscrow) error {
	v.Status = "REJECT_CONFIRMED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRejectConfirmedPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided RejectConfirmedPaymentEscrow
func (t *PaymentEscrow) MergeRejectConfirmedPaymentEscrow(v RejectConfirmedPaymentEscrow) error {
	v.Status = "REJECT_CONFIRMED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRejectedPaymentEscrow returns the union data inside the PaymentEscrow as a RejectedPaymentEscrow
func (t PaymentEscrow) AsRejectedPaymentEscrow() (RejectedPaymentEscrow, error) {
	var body RejectedPaymentEscrow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRejectedPaymentEscrow overwrites any union data inside the PaymentEscrow as the provided RejectedPaymentEscrow
func (t *PaymentEscrow) FromRejectedPaymentEscrow(v RejectedPaymentEscrow) error {
	v.Status = "REJECTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRejectedPaymentEscrow performs a merge with any union data inside the PaymentEscrow, using the provided RejectedPaymentEscrow
func (t *PaymentEscrow) MergeRejectedPaymentEscrow(v RejectedPaymentEscrow) error {
	v.Status = "REJECTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentEscrow) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentEscrow) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BEFORE_REGISTERED":
		return t.AsBeforeRegisteredPaymentEscrow()
	case "CANCELLED":
		return t.AsCancelledPaymentEscrow()
	case "CONFIRMED":
		return t.AsConfirmedPaymentEscrow()
	case "DELIVERED":
		return t.AsDeliveredPaymentEscrow()
	case "REGISTERED":
		return t.AsRegisteredPaymentEscrow()
	case "REJECTED":
		return t.AsRejectedPaymentEscrow()
	case "REJECT_CONFIRMED":
		return t.AsRejectConfirmedPaymentEscrow()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentEscrow) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentEscrow) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelledPaymentEvent returns the union data inside the PaymentEvent as a CancelledPaymentEvent
func (t PaymentEvent) AsCancelledPaymentEvent() (CancelledPaymentEvent, error) {
	var body CancelledPaymentEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledPaymentEvent overwrites any union data inside the PaymentEvent as the provided CancelledPaymentEvent
func (t *PaymentEvent) FromCancelledPaymentEvent(v CancelledPaymentEvent) error {
	v.Type = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledPaymentEvent performs a merge with any union data inside the PaymentEvent, using the provided CancelledPaymentEvent
func (t *PaymentEvent) MergeCancelledPaymentEvent(v CancelledPaymentEvent) error {
	v.Type = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaidPaymentEvent returns the union data inside the PaymentEvent as a PaidPaymentEvent
func (t PaymentEvent) AsPaidPaymentEvent() (PaidPaymentEvent, error) {
	var body PaidPaymentEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaidPaymentEvent overwrites any union data inside the PaymentEvent as the provided PaidPaymentEvent
func (t *PaymentEvent) FromPaidPaymentEvent(v PaidPaymentEvent) error {
	v.Type = "PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaidPaymentEvent performs a merge with any union data inside the PaymentEvent, using the provided PaidPaymentEvent
func (t *PaymentEvent) MergePaidPaymentEvent(v PaidPaymentEvent) error {
	v.Type = "PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartialCancelledPaymentEvent returns the union data inside the PaymentEvent as a PartialCancelledPaymentEvent
func (t PaymentEvent) AsPartialCancelledPaymentEvent() (PartialCancelledPaymentEvent, error) {
	var body PartialCancelledPaymentEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartialCancelledPaymentEvent overwrites any union data inside the PaymentEvent as the provided PartialCancelledPaymentEvent
func (t *PaymentEvent) FromPartialCancelledPaymentEvent(v PartialCancelledPaymentEvent) error {
	v.Type = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartialCancelledPaymentEvent performs a merge with any union data inside the PaymentEvent, using the provided PartialCancelledPaymentEvent
func (t *PaymentEvent) MergePartialCancelledPaymentEvent(v PartialCancelledPaymentEvent) error {
	v.Type = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentEvent) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentEvent) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLED":
		return t.AsCancelledPaymentEvent()
	case "PAID":
		return t.AsPaidPaymentEvent()
	case "PARTIAL_CANCELLED":
		return t.AsPartialCancelledPaymentEvent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentEvent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentEvent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodCard returns the union data inside the PaymentMethod as a PaymentMethodCard
func (t PaymentMethod) AsPaymentMethodCard() (PaymentMethodCard, error) {
	var body PaymentMethodCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodCard overwrites any union data inside the PaymentMethod as the provided PaymentMethodCard
func (t *PaymentMethod) FromPaymentMethodCard(v PaymentMethodCard) error {
	v.Type = "PaymentMethodCard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodCard performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodCard
func (t *PaymentMethod) MergePaymentMethodCard(v PaymentMethodCard) error {
	v.Type = "PaymentMethodCard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodConvenienceStore returns the union data inside the PaymentMethod as a PaymentMethodConvenienceStore
func (t PaymentMethod) AsPaymentMethodConvenienceStore() (PaymentMethodConvenienceStore, error) {
	var body PaymentMethodConvenienceStore
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodConvenienceStore overwrites any union data inside the PaymentMethod as the provided PaymentMethodConvenienceStore
func (t *PaymentMethod) FromPaymentMethodConvenienceStore(v PaymentMethodConvenienceStore) error {
	v.Type = "PaymentMethodConvenienceStore"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodConvenienceStore performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodConvenienceStore
func (t *PaymentMethod) MergePaymentMethodConvenienceStore(v PaymentMethodConvenienceStore) error {
	v.Type = "PaymentMethodConvenienceStore"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodEasyPay returns the union data inside the PaymentMethod as a PaymentMethodEasyPay
func (t PaymentMethod) AsPaymentMethodEasyPay() (PaymentMethodEasyPay, error) {
	var body PaymentMethodEasyPay
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodEasyPay overwrites any union data inside the PaymentMethod as the provided PaymentMethodEasyPay
func (t *PaymentMethod) FromPaymentMethodEasyPay(v PaymentMethodEasyPay) error {
	v.Type = "PaymentMethodEasyPay"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodEasyPay performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodEasyPay
func (t *PaymentMethod) MergePaymentMethodEasyPay(v PaymentMethodEasyPay) error {
	v.Type = "PaymentMethodEasyPay"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodGiftCertificate returns the union data inside the PaymentMethod as a PaymentMethodGiftCertificate
func (t PaymentMethod) AsPaymentMethodGiftCertificate() (PaymentMethodGiftCertificate, error) {
	var body PaymentMethodGiftCertificate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodGiftCertificate overwrites any union data inside the PaymentMethod as the provided PaymentMethodGiftCertificate
func (t *PaymentMethod) FromPaymentMethodGiftCertificate(v PaymentMethodGiftCertificate) error {
	v.Type = "PaymentMethodGiftCertificate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodGiftCertificate performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodGiftCertificate
func (t *PaymentMethod) MergePaymentMethodGiftCertificate(v PaymentMethodGiftCertificate) error {
	v.Type = "PaymentMethodGiftCertificate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodMobile returns the union data inside the PaymentMethod as a PaymentMethodMobile
func (t PaymentMethod) AsPaymentMethodMobile() (PaymentMethodMobile, error) {
	var body PaymentMethodMobile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodMobile overwrites any union data inside the PaymentMethod as the provided PaymentMethodMobile
func (t *PaymentMethod) FromPaymentMethodMobile(v PaymentMethodMobile) error {
	v.Type = "PaymentMethodMobile"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodMobile performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodMobile
func (t *PaymentMethod) MergePaymentMethodMobile(v PaymentMethodMobile) error {
	v.Type = "PaymentMethodMobile"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodTransfer returns the union data inside the PaymentMethod as a PaymentMethodTransfer
func (t PaymentMethod) AsPaymentMethodTransfer() (PaymentMethodTransfer, error) {
	var body PaymentMethodTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodTransfer overwrites any union data inside the PaymentMethod as the provided PaymentMethodTransfer
func (t *PaymentMethod) FromPaymentMethodTransfer(v PaymentMethodTransfer) error {
	v.Type = "PaymentMethodTransfer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodTransfer performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodTransfer
func (t *PaymentMethod) MergePaymentMethodTransfer(v PaymentMethodTransfer) error {
	v.Type = "PaymentMethodTransfer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodVirtualAccount returns the union data inside the PaymentMethod as a PaymentMethodVirtualAccount
func (t PaymentMethod) AsPaymentMethodVirtualAccount() (PaymentMethodVirtualAccount, error) {
	var body PaymentMethodVirtualAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodVirtualAccount overwrites any union data inside the PaymentMethod as the provided PaymentMethodVirtualAccount
func (t *PaymentMethod) FromPaymentMethodVirtualAccount(v PaymentMethodVirtualAccount) error {
	v.Type = "PaymentMethodVirtualAccount"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodVirtualAccount performs a merge with any union data inside the PaymentMethod, using the provided PaymentMethodVirtualAccount
func (t *PaymentMethod) MergePaymentMethodVirtualAccount(v PaymentMethodVirtualAccount) error {
	v.Type = "PaymentMethodVirtualAccount"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PaymentMethodCard":
		return t.AsPaymentMethodCard()
	case "PaymentMethodConvenienceStore":
		return t.AsPaymentMethodConvenienceStore()
	case "PaymentMethodEasyPay":
		return t.AsPaymentMethodEasyPay()
	case "PaymentMethodGiftCertificate":
		return t.AsPaymentMethodGiftCertificate()
	case "PaymentMethodMobile":
		return t.AsPaymentMethodMobile()
	case "PaymentMethodTransfer":
		return t.AsPaymentMethodTransfer()
	case "PaymentMethodVirtualAccount":
		return t.AsPaymentMethodVirtualAccount()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPaymentMethodCard returns the union data inside the PaymentMethodEasyPayMethod as a PaymentMethodCard
func (t PaymentMethodEasyPayMethod) AsPaymentMethodCard() (PaymentMethodCard, error) {
	var body PaymentMethodCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodCard overwrites any union data inside the PaymentMethodEasyPayMethod as the provided PaymentMethodCard
func (t *PaymentMethodEasyPayMethod) FromPaymentMethodCard(v PaymentMethodCard) error {
	v.Type = "PaymentMethodCard"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodCard performs a merge with any union data inside the PaymentMethodEasyPayMethod, using the provided PaymentMethodCard
func (t *PaymentMethodEasyPayMethod) MergePaymentMethodCard(v PaymentMethodCard) error {
	v.Type = "PaymentMethodCard"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodEasyPayMethodCharge returns the union data inside the PaymentMethodEasyPayMethod as a PaymentMethodEasyPayMethodCharge
func (t PaymentMethodEasyPayMethod) AsPaymentMethodEasyPayMethodCharge() (PaymentMethodEasyPayMethodCharge, error) {
	var body PaymentMethodEasyPayMethodCharge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodEasyPayMethodCharge overwrites any union data inside the PaymentMethodEasyPayMethod as the provided PaymentMethodEasyPayMethodCharge
func (t *PaymentMethodEasyPayMethod) FromPaymentMethodEasyPayMethodCharge(v PaymentMethodEasyPayMethodCharge) error {
	v.Type = "PaymentMethodEasyPayMethodCharge"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodEasyPayMethodCharge performs a merge with any union data inside the PaymentMethodEasyPayMethod, using the provided PaymentMethodEasyPayMethodCharge
func (t *PaymentMethodEasyPayMethod) MergePaymentMethodEasyPayMethodCharge(v PaymentMethodEasyPayMethodCharge) error {
	v.Type = "PaymentMethodEasyPayMethodCharge"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentMethodTransfer returns the union data inside the PaymentMethodEasyPayMethod as a PaymentMethodTransfer
func (t PaymentMethodEasyPayMethod) AsPaymentMethodTransfer() (PaymentMethodTransfer, error) {
	var body PaymentMethodTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentMethodTransfer overwrites any union data inside the PaymentMethodEasyPayMethod as the provided PaymentMethodTransfer
func (t *PaymentMethodEasyPayMethod) FromPaymentMethodTransfer(v PaymentMethodTransfer) error {
	v.Type = "PaymentMethodTransfer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentMethodTransfer performs a merge with any union data inside the PaymentMethodEasyPayMethod, using the provided PaymentMethodTransfer
func (t *PaymentMethodEasyPayMethod) MergePaymentMethodTransfer(v PaymentMethodTransfer) error {
	v.Type = "PaymentMethodTransfer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentMethodEasyPayMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentMethodEasyPayMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PaymentMethodCard":
		return t.AsPaymentMethodCard()
	case "PaymentMethodEasyPayMethodCharge":
		return t.AsPaymentMethodEasyPayMethodCharge()
	case "PaymentMethodTransfer":
		return t.AsPaymentMethodTransfer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentMethodEasyPayMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentMethodEasyPayMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFailedPaymentSchedule returns the union data inside the PaymentSchedule as a FailedPaymentSchedule
func (t PaymentSchedule) AsFailedPaymentSchedule() (FailedPaymentSchedule, error) {
	var body FailedPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided FailedPaymentSchedule
func (t *PaymentSchedule) FromFailedPaymentSchedule(v FailedPaymentSchedule) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided FailedPaymentSchedule
func (t *PaymentSchedule) MergeFailedPaymentSchedule(v FailedPaymentSchedule) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPendingPaymentSchedule returns the union data inside the PaymentSchedule as a PendingPaymentSchedule
func (t PaymentSchedule) AsPendingPaymentSchedule() (PendingPaymentSchedule, error) {
	var body PendingPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPendingPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided PendingPaymentSchedule
func (t *PaymentSchedule) FromPendingPaymentSchedule(v PendingPaymentSchedule) error {
	v.Status = "PENDING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePendingPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided PendingPaymentSchedule
func (t *PaymentSchedule) MergePendingPaymentSchedule(v PendingPaymentSchedule) error {
	v.Status = "PENDING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRevokedPaymentSchedule returns the union data inside the PaymentSchedule as a RevokedPaymentSchedule
func (t PaymentSchedule) AsRevokedPaymentSchedule() (RevokedPaymentSchedule, error) {
	var body RevokedPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRevokedPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided RevokedPaymentSchedule
func (t *PaymentSchedule) FromRevokedPaymentSchedule(v RevokedPaymentSchedule) error {
	v.Status = "REVOKED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRevokedPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided RevokedPaymentSchedule
func (t *PaymentSchedule) MergeRevokedPaymentSchedule(v RevokedPaymentSchedule) error {
	v.Status = "REVOKED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScheduledPaymentSchedule returns the union data inside the PaymentSchedule as a ScheduledPaymentSchedule
func (t PaymentSchedule) AsScheduledPaymentSchedule() (ScheduledPaymentSchedule, error) {
	var body ScheduledPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScheduledPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided ScheduledPaymentSchedule
func (t *PaymentSchedule) FromScheduledPaymentSchedule(v ScheduledPaymentSchedule) error {
	v.Status = "SCHEDULED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScheduledPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided ScheduledPaymentSchedule
func (t *PaymentSchedule) MergeScheduledPaymentSchedule(v ScheduledPaymentSchedule) error {
	v.Status = "SCHEDULED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStartedPaymentSchedule returns the union data inside the PaymentSchedule as a StartedPaymentSchedule
func (t PaymentSchedule) AsStartedPaymentSchedule() (StartedPaymentSchedule, error) {
	var body StartedPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStartedPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided StartedPaymentSchedule
func (t *PaymentSchedule) FromStartedPaymentSchedule(v StartedPaymentSchedule) error {
	v.Status = "STARTED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStartedPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided StartedPaymentSchedule
func (t *PaymentSchedule) MergeStartedPaymentSchedule(v StartedPaymentSchedule) error {
	v.Status = "STARTED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSucceededPaymentSchedule returns the union data inside the PaymentSchedule as a SucceededPaymentSchedule
func (t PaymentSchedule) AsSucceededPaymentSchedule() (SucceededPaymentSchedule, error) {
	var body SucceededPaymentSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSucceededPaymentSchedule overwrites any union data inside the PaymentSchedule as the provided SucceededPaymentSchedule
func (t *PaymentSchedule) FromSucceededPaymentSchedule(v SucceededPaymentSchedule) error {
	v.Status = "SUCCEEDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSucceededPaymentSchedule performs a merge with any union data inside the PaymentSchedule, using the provided SucceededPaymentSchedule
func (t *PaymentSchedule) MergeSucceededPaymentSchedule(v SucceededPaymentSchedule) error {
	v.Status = "SUCCEEDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentSchedule) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentSchedule) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FAILED":
		return t.AsFailedPaymentSchedule()
	case "PENDING":
		return t.AsPendingPaymentSchedule()
	case "REVOKED":
		return t.AsRevokedPaymentSchedule()
	case "SCHEDULED":
		return t.AsScheduledPaymentSchedule()
	case "STARTED":
		return t.AsStartedPaymentSchedule()
	case "SUCCEEDED":
		return t.AsSucceededPaymentSchedule()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentSchedule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentSchedule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCancelledPaymentTransaction returns the union data inside the PaymentTransaction as a CancelledPaymentTransaction
func (t PaymentTransaction) AsCancelledPaymentTransaction() (CancelledPaymentTransaction, error) {
	var body CancelledPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCancelledPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided CancelledPaymentTransaction
func (t *PaymentTransaction) FromCancelledPaymentTransaction(v CancelledPaymentTransaction) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCancelledPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided CancelledPaymentTransaction
func (t *PaymentTransaction) MergeCancelledPaymentTransaction(v CancelledPaymentTransaction) error {
	v.Status = "CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFailedPaymentTransaction returns the union data inside the PaymentTransaction as a FailedPaymentTransaction
func (t PaymentTransaction) AsFailedPaymentTransaction() (FailedPaymentTransaction, error) {
	var body FailedPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided FailedPaymentTransaction
func (t *PaymentTransaction) FromFailedPaymentTransaction(v FailedPaymentTransaction) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided FailedPaymentTransaction
func (t *PaymentTransaction) MergeFailedPaymentTransaction(v FailedPaymentTransaction) error {
	v.Status = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaidPaymentTransaction returns the union data inside the PaymentTransaction as a PaidPaymentTransaction
func (t PaymentTransaction) AsPaidPaymentTransaction() (PaidPaymentTransaction, error) {
	var body PaidPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaidPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided PaidPaymentTransaction
func (t *PaymentTransaction) FromPaidPaymentTransaction(v PaidPaymentTransaction) error {
	v.Status = "PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaidPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided PaidPaymentTransaction
func (t *PaymentTransaction) MergePaidPaymentTransaction(v PaidPaymentTransaction) error {
	v.Status = "PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartialCancelledPaymentTransaction returns the union data inside the PaymentTransaction as a PartialCancelledPaymentTransaction
func (t PaymentTransaction) AsPartialCancelledPaymentTransaction() (PartialCancelledPaymentTransaction, error) {
	var body PartialCancelledPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartialCancelledPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided PartialCancelledPaymentTransaction
func (t *PaymentTransaction) FromPartialCancelledPaymentTransaction(v PartialCancelledPaymentTransaction) error {
	v.Status = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartialCancelledPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided PartialCancelledPaymentTransaction
func (t *PaymentTransaction) MergePartialCancelledPaymentTransaction(v PartialCancelledPaymentTransaction) error {
	v.Status = "PARTIAL_CANCELLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPayPendingPaymentTransaction returns the union data inside the PaymentTransaction as a PayPendingPaymentTransaction
func (t PaymentTransaction) AsPayPendingPaymentTransaction() (PayPendingPaymentTransaction, error) {
	var body PayPendingPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPayPendingPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided PayPendingPaymentTransaction
func (t *PaymentTransaction) FromPayPendingPaymentTransaction(v PayPendingPaymentTransaction) error {
	v.Status = "PAY_PENDING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePayPendingPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided PayPendingPaymentTransaction
func (t *PaymentTransaction) MergePayPendingPaymentTransaction(v PayPendingPaymentTransaction) error {
	v.Status = "PAY_PENDING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReadyPaymentTransaction returns the union data inside the PaymentTransaction as a ReadyPaymentTransaction
func (t PaymentTransaction) AsReadyPaymentTransaction() (ReadyPaymentTransaction, error) {
	var body ReadyPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadyPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided ReadyPaymentTransaction
func (t *PaymentTransaction) FromReadyPaymentTransaction(v ReadyPaymentTransaction) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadyPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided ReadyPaymentTransaction
func (t *PaymentTransaction) MergeReadyPaymentTransaction(v ReadyPaymentTransaction) error {
	v.Status = "READY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualAccountIssuedPaymentTransaction returns the union data inside the PaymentTransaction as a VirtualAccountIssuedPaymentTransaction
func (t PaymentTransaction) AsVirtualAccountIssuedPaymentTransaction() (VirtualAccountIssuedPaymentTransaction, error) {
	var body VirtualAccountIssuedPaymentTransaction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualAccountIssuedPaymentTransaction overwrites any union data inside the PaymentTransaction as the provided VirtualAccountIssuedPaymentTransaction
func (t *PaymentTransaction) FromVirtualAccountIssuedPaymentTransaction(v VirtualAccountIssuedPaymentTransaction) error {
	v.Status = "VIRTUAL_ACCOUNT_ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualAccountIssuedPaymentTransaction performs a merge with any union data inside the PaymentTransaction, using the provided VirtualAccountIssuedPaymentTransaction
func (t *PaymentTransaction) MergeVirtualAccountIssuedPaymentTransaction(v VirtualAccountIssuedPaymentTransaction) error {
	v.Status = "VIRTUAL_ACCOUNT_ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PaymentTransaction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PaymentTransaction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CANCELLED":
		return t.AsCancelledPaymentTransaction()
	case "FAILED":
		return t.AsFailedPaymentTransaction()
	case "PAID":
		return t.AsPaidPaymentTransaction()
	case "PARTIAL_CANCELLED":
		return t.AsPartialCancelledPaymentTransaction()
	case "PAY_PENDING":
		return t.AsPayPendingPaymentTransaction()
	case "READY":
		return t.AsReadyPaymentTransaction()
	case "VIRTUAL_ACCOUNT_ISSUED":
		return t.AsVirtualAccountIssuedPaymentTransaction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PaymentTransaction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PaymentTransaction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFailedPgBillingKeyIssueResponse returns the union data inside the PgBillingKeyIssueResponse as a FailedPgBillingKeyIssueResponse
func (t PgBillingKeyIssueResponse) AsFailedPgBillingKeyIssueResponse() (FailedPgBillingKeyIssueResponse, error) {
	var body FailedPgBillingKeyIssueResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFailedPgBillingKeyIssueResponse overwrites any union data inside the PgBillingKeyIssueResponse as the provided FailedPgBillingKeyIssueResponse
func (t *PgBillingKeyIssueResponse) FromFailedPgBillingKeyIssueResponse(v FailedPgBillingKeyIssueResponse) error {
	v.Type = "FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFailedPgBillingKeyIssueResponse performs a merge with any union data inside the PgBillingKeyIssueResponse, using the provided FailedPgBillingKeyIssueResponse
func (t *PgBillingKeyIssueResponse) MergeFailedPgBillingKeyIssueResponse(v FailedPgBillingKeyIssueResponse) error {
	v.Type = "FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssuedPgBillingKeyIssueResponse returns the union data inside the PgBillingKeyIssueResponse as a IssuedPgBillingKeyIssueResponse
func (t PgBillingKeyIssueResponse) AsIssuedPgBillingKeyIssueResponse() (IssuedPgBillingKeyIssueResponse, error) {
	var body IssuedPgBillingKeyIssueResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssuedPgBillingKeyIssueResponse overwrites any union data inside the PgBillingKeyIssueResponse as the provided IssuedPgBillingKeyIssueResponse
func (t *PgBillingKeyIssueResponse) FromIssuedPgBillingKeyIssueResponse(v IssuedPgBillingKeyIssueResponse) error {
	v.Type = "ISSUED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssuedPgBillingKeyIssueResponse performs a merge with any union data inside the PgBillingKeyIssueResponse, using the provided IssuedPgBillingKeyIssueResponse
func (t *PgBillingKeyIssueResponse) MergeIssuedPgBillingKeyIssueResponse(v IssuedPgBillingKeyIssueResponse) error {
	v.Type = "ISSUED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PgBillingKeyIssueResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PgBillingKeyIssueResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FAILED":
		return t.AsFailedPgBillingKeyIssueResponse()
	case "ISSUED":
		return t.AsIssuedPgBillingKeyIssueResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PgBillingKeyIssueResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PgBillingKeyIssueResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformDepositAccountTransfer returns the union data inside the PlatformAccountTransfer as a PlatformDepositAccountTransfer
func (t PlatformAccountTransfer) AsPlatformDepositAccountTransfer() (PlatformDepositAccountTransfer, error) {
	var body PlatformDepositAccountTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDepositAccountTransfer overwrites any union data inside the PlatformAccountTransfer as the provided PlatformDepositAccountTransfer
func (t *PlatformAccountTransfer) FromPlatformDepositAccountTransfer(v PlatformDepositAccountTransfer) error {
	v.Type = "DEPOSIT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDepositAccountTransfer performs a merge with any union data inside the PlatformAccountTransfer, using the provided PlatformDepositAccountTransfer
func (t *PlatformAccountTransfer) MergePlatformDepositAccountTransfer(v PlatformDepositAccountTransfer) error {
	v.Type = "DEPOSIT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformWithdrawalAccountTransfer returns the union data inside the PlatformAccountTransfer as a PlatformWithdrawalAccountTransfer
func (t PlatformAccountTransfer) AsPlatformWithdrawalAccountTransfer() (PlatformWithdrawalAccountTransfer, error) {
	var body PlatformWithdrawalAccountTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformWithdrawalAccountTransfer overwrites any union data inside the PlatformAccountTransfer as the provided PlatformWithdrawalAccountTransfer
func (t *PlatformAccountTransfer) FromPlatformWithdrawalAccountTransfer(v PlatformWithdrawalAccountTransfer) error {
	v.Type = "WITHDRAWAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformWithdrawalAccountTransfer performs a merge with any union data inside the PlatformAccountTransfer, using the provided PlatformWithdrawalAccountTransfer
func (t *PlatformAccountTransfer) MergePlatformWithdrawalAccountTransfer(v PlatformWithdrawalAccountTransfer) error {
	v.Type = "WITHDRAWAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformAccountTransfer) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformAccountTransfer) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DEPOSIT":
		return t.AsPlatformDepositAccountTransfer()
	case "WITHDRAWAL":
		return t.AsPlatformWithdrawalAccountTransfer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformAccountTransfer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformAccountTransfer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformFixedAmountFee returns the union data inside the PlatformFee as a PlatformFixedAmountFee
func (t PlatformFee) AsPlatformFixedAmountFee() (PlatformFixedAmountFee, error) {
	var body PlatformFixedAmountFee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformFixedAmountFee overwrites any union data inside the PlatformFee as the provided PlatformFixedAmountFee
func (t *PlatformFee) FromPlatformFixedAmountFee(v PlatformFixedAmountFee) error {
	v.Type = "FIXED_AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformFixedAmountFee performs a merge with any union data inside the PlatformFee, using the provided PlatformFixedAmountFee
func (t *PlatformFee) MergePlatformFixedAmountFee(v PlatformFixedAmountFee) error {
	v.Type = "FIXED_AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformFixedRateFee returns the union data inside the PlatformFee as a PlatformFixedRateFee
func (t PlatformFee) AsPlatformFixedRateFee() (PlatformFixedRateFee, error) {
	var body PlatformFixedRateFee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformFixedRateFee overwrites any union data inside the PlatformFee as the provided PlatformFixedRateFee
func (t *PlatformFee) FromPlatformFixedRateFee(v PlatformFixedRateFee) error {
	v.Type = "FIXED_RATE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformFixedRateFee performs a merge with any union data inside the PlatformFee, using the provided PlatformFixedRateFee
func (t *PlatformFee) MergePlatformFixedRateFee(v PlatformFixedRateFee) error {
	v.Type = "FIXED_RATE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformFee) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformFee) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FIXED_AMOUNT":
		return t.AsPlatformFixedAmountFee()
	case "FIXED_RATE":
		return t.AsPlatformFixedRateFee()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformFee) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformFee) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformPartnerManualSettlement returns the union data inside the PlatformPartnerSettlement as a PlatformPartnerManualSettlement
func (t PlatformPartnerSettlement) AsPlatformPartnerManualSettlement() (PlatformPartnerManualSettlement, error) {
	var body PlatformPartnerManualSettlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerManualSettlement overwrites any union data inside the PlatformPartnerSettlement as the provided PlatformPartnerManualSettlement
func (t *PlatformPartnerSettlement) FromPlatformPartnerManualSettlement(v PlatformPartnerManualSettlement) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerManualSettlement performs a merge with any union data inside the PlatformPartnerSettlement, using the provided PlatformPartnerManualSettlement
func (t *PlatformPartnerSettlement) MergePlatformPartnerManualSettlement(v PlatformPartnerManualSettlement) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerOrderCancelSettlement returns the union data inside the PlatformPartnerSettlement as a PlatformPartnerOrderCancelSettlement
func (t PlatformPartnerSettlement) AsPlatformPartnerOrderCancelSettlement() (PlatformPartnerOrderCancelSettlement, error) {
	var body PlatformPartnerOrderCancelSettlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerOrderCancelSettlement overwrites any union data inside the PlatformPartnerSettlement as the provided PlatformPartnerOrderCancelSettlement
func (t *PlatformPartnerSettlement) FromPlatformPartnerOrderCancelSettlement(v PlatformPartnerOrderCancelSettlement) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerOrderCancelSettlement performs a merge with any union data inside the PlatformPartnerSettlement, using the provided PlatformPartnerOrderCancelSettlement
func (t *PlatformPartnerSettlement) MergePlatformPartnerOrderCancelSettlement(v PlatformPartnerOrderCancelSettlement) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerOrderSettlement returns the union data inside the PlatformPartnerSettlement as a PlatformPartnerOrderSettlement
func (t PlatformPartnerSettlement) AsPlatformPartnerOrderSettlement() (PlatformPartnerOrderSettlement, error) {
	var body PlatformPartnerOrderSettlement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerOrderSettlement overwrites any union data inside the PlatformPartnerSettlement as the provided PlatformPartnerOrderSettlement
func (t *PlatformPartnerSettlement) FromPlatformPartnerOrderSettlement(v PlatformPartnerOrderSettlement) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerOrderSettlement performs a merge with any union data inside the PlatformPartnerSettlement, using the provided PlatformPartnerOrderSettlement
func (t *PlatformPartnerSettlement) MergePlatformPartnerOrderSettlement(v PlatformPartnerOrderSettlement) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformPartnerSettlement) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformPartnerSettlement) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MANUAL":
		return t.AsPlatformPartnerManualSettlement()
	case "ORDER":
		return t.AsPlatformPartnerOrderSettlement()
	case "ORDER_CANCEL":
		return t.AsPlatformPartnerOrderCancelSettlement()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformPartnerSettlement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformPartnerSettlement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformPartnerTypeBusiness returns the union data inside the PlatformPartnerType as a PlatformPartnerTypeBusiness
func (t PlatformPartnerType) AsPlatformPartnerTypeBusiness() (PlatformPartnerTypeBusiness, error) {
	var body PlatformPartnerTypeBusiness
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTypeBusiness overwrites any union data inside the PlatformPartnerType as the provided PlatformPartnerTypeBusiness
func (t *PlatformPartnerType) FromPlatformPartnerTypeBusiness(v PlatformPartnerTypeBusiness) error {
	v.Type = "BUSINESS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTypeBusiness performs a merge with any union data inside the PlatformPartnerType, using the provided PlatformPartnerTypeBusiness
func (t *PlatformPartnerType) MergePlatformPartnerTypeBusiness(v PlatformPartnerTypeBusiness) error {
	v.Type = "BUSINESS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTypeNonWhtPayer returns the union data inside the PlatformPartnerType as a PlatformPartnerTypeNonWhtPayer
func (t PlatformPartnerType) AsPlatformPartnerTypeNonWhtPayer() (PlatformPartnerTypeNonWhtPayer, error) {
	var body PlatformPartnerTypeNonWhtPayer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTypeNonWhtPayer overwrites any union data inside the PlatformPartnerType as the provided PlatformPartnerTypeNonWhtPayer
func (t *PlatformPartnerType) FromPlatformPartnerTypeNonWhtPayer(v PlatformPartnerTypeNonWhtPayer) error {
	v.Type = "NON_WHT_PAYER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTypeNonWhtPayer performs a merge with any union data inside the PlatformPartnerType, using the provided PlatformPartnerTypeNonWhtPayer
func (t *PlatformPartnerType) MergePlatformPartnerTypeNonWhtPayer(v PlatformPartnerTypeNonWhtPayer) error {
	v.Type = "NON_WHT_PAYER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerTypeWhtPayer returns the union data inside the PlatformPartnerType as a PlatformPartnerTypeWhtPayer
func (t PlatformPartnerType) AsPlatformPartnerTypeWhtPayer() (PlatformPartnerTypeWhtPayer, error) {
	var body PlatformPartnerTypeWhtPayer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerTypeWhtPayer overwrites any union data inside the PlatformPartnerType as the provided PlatformPartnerTypeWhtPayer
func (t *PlatformPartnerType) FromPlatformPartnerTypeWhtPayer(v PlatformPartnerTypeWhtPayer) error {
	v.Type = "WHT_PAYER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerTypeWhtPayer performs a merge with any union data inside the PlatformPartnerType, using the provided PlatformPartnerTypeWhtPayer
func (t *PlatformPartnerType) MergePlatformPartnerTypeWhtPayer(v PlatformPartnerTypeWhtPayer) error {
	v.Type = "WHT_PAYER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformPartnerType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformPartnerType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUSINESS":
		return t.AsPlatformPartnerTypeBusiness()
	case "NON_WHT_PAYER":
		return t.AsPlatformPartnerTypeNonWhtPayer()
	case "WHT_PAYER":
		return t.AsPlatformPartnerTypeWhtPayer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformPartnerType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformPartnerType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformExternalPayment returns the union data inside the PlatformPayment as a PlatformExternalPayment
func (t PlatformPayment) AsPlatformExternalPayment() (PlatformExternalPayment, error) {
	var body PlatformExternalPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformExternalPayment overwrites any union data inside the PlatformPayment as the provided PlatformExternalPayment
func (t *PlatformPayment) FromPlatformExternalPayment(v PlatformExternalPayment) error {
	v.Type = "EXTERNAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformExternalPayment performs a merge with any union data inside the PlatformPayment, using the provided PlatformExternalPayment
func (t *PlatformPayment) MergePlatformExternalPayment(v PlatformExternalPayment) error {
	v.Type = "EXTERNAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPortOnePayment returns the union data inside the PlatformPayment as a PlatformPortOnePayment
func (t PlatformPayment) AsPlatformPortOnePayment() (PlatformPortOnePayment, error) {
	var body PlatformPortOnePayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPortOnePayment overwrites any union data inside the PlatformPayment as the provided PlatformPortOnePayment
func (t *PlatformPayment) FromPlatformPortOnePayment(v PlatformPortOnePayment) error {
	v.Type = "PORT_ONE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPortOnePayment performs a merge with any union data inside the PlatformPayment, using the provided PlatformPortOnePayment
func (t *PlatformPayment) MergePlatformPortOnePayment(v PlatformPortOnePayment) error {
	v.Type = "PORT_ONE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformPayment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformPayment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "EXTERNAL":
		return t.AsPlatformExternalPayment()
	case "PORT_ONE":
		return t.AsPlatformPortOnePayment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformPayment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformPayment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformPaymentMethodCard returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodCard
func (t PlatformPaymentMethod) AsPlatformPaymentMethodCard() (PlatformPaymentMethodCard, error) {
	var body PlatformPaymentMethodCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodCard overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodCard
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodCard(v PlatformPaymentMethodCard) error {
	v.Type = "CARD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodCard performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodCard
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodCard(v PlatformPaymentMethodCard) error {
	v.Type = "CARD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentMethodEasyPay returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodEasyPay
func (t PlatformPaymentMethod) AsPlatformPaymentMethodEasyPay() (PlatformPaymentMethodEasyPay, error) {
	var body PlatformPaymentMethodEasyPay
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodEasyPay overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodEasyPay
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodEasyPay(v PlatformPaymentMethodEasyPay) error {
	v.Type = "EASY_PAY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodEasyPay performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodEasyPay
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodEasyPay(v PlatformPaymentMethodEasyPay) error {
	v.Type = "EASY_PAY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentMethodGiftCertificate returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodGiftCertificate
func (t PlatformPaymentMethod) AsPlatformPaymentMethodGiftCertificate() (PlatformPaymentMethodGiftCertificate, error) {
	var body PlatformPaymentMethodGiftCertificate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodGiftCertificate overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodGiftCertificate
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodGiftCertificate(v PlatformPaymentMethodGiftCertificate) error {
	v.Type = "GIFT_CERTIFICATE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodGiftCertificate performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodGiftCertificate
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodGiftCertificate(v PlatformPaymentMethodGiftCertificate) error {
	v.Type = "GIFT_CERTIFICATE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentMethodMobile returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodMobile
func (t PlatformPaymentMethod) AsPlatformPaymentMethodMobile() (PlatformPaymentMethodMobile, error) {
	var body PlatformPaymentMethodMobile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodMobile overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodMobile
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodMobile(v PlatformPaymentMethodMobile) error {
	v.Type = "MOBILE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodMobile performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodMobile
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodMobile(v PlatformPaymentMethodMobile) error {
	v.Type = "MOBILE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentMethodTransfer returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodTransfer
func (t PlatformPaymentMethod) AsPlatformPaymentMethodTransfer() (PlatformPaymentMethodTransfer, error) {
	var body PlatformPaymentMethodTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodTransfer overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodTransfer
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodTransfer(v PlatformPaymentMethodTransfer) error {
	v.Type = "TRANSFER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodTransfer performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodTransfer
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodTransfer(v PlatformPaymentMethodTransfer) error {
	v.Type = "TRANSFER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPaymentMethodVirtualAccount returns the union data inside the PlatformPaymentMethod as a PlatformPaymentMethodVirtualAccount
func (t PlatformPaymentMethod) AsPlatformPaymentMethodVirtualAccount() (PlatformPaymentMethodVirtualAccount, error) {
	var body PlatformPaymentMethodVirtualAccount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPaymentMethodVirtualAccount overwrites any union data inside the PlatformPaymentMethod as the provided PlatformPaymentMethodVirtualAccount
func (t *PlatformPaymentMethod) FromPlatformPaymentMethodVirtualAccount(v PlatformPaymentMethodVirtualAccount) error {
	v.Type = "VIRTUAL_ACCOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPaymentMethodVirtualAccount performs a merge with any union data inside the PlatformPaymentMethod, using the provided PlatformPaymentMethodVirtualAccount
func (t *PlatformPaymentMethod) MergePlatformPaymentMethodVirtualAccount(v PlatformPaymentMethodVirtualAccount) error {
	v.Type = "VIRTUAL_ACCOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformPaymentMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformPaymentMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CARD":
		return t.AsPlatformPaymentMethodCard()
	case "EASY_PAY":
		return t.AsPlatformPaymentMethodEasyPay()
	case "GIFT_CERTIFICATE":
		return t.AsPlatformPaymentMethodGiftCertificate()
	case "MOBILE":
		return t.AsPlatformPaymentMethodMobile()
	case "TRANSFER":
		return t.AsPlatformPaymentMethodTransfer()
	case "VIRTUAL_ACCOUNT":
		return t.AsPlatformPaymentMethodVirtualAccount()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformPaymentMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformPaymentMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformSettlementCycleMethodDaily returns the union data inside the PlatformSettlementCycleMethod as a PlatformSettlementCycleMethodDaily
func (t PlatformSettlementCycleMethod) AsPlatformSettlementCycleMethodDaily() (PlatformSettlementCycleMethodDaily, error) {
	var body PlatformSettlementCycleMethodDaily
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementCycleMethodDaily overwrites any union data inside the PlatformSettlementCycleMethod as the provided PlatformSettlementCycleMethodDaily
func (t *PlatformSettlementCycleMethod) FromPlatformSettlementCycleMethodDaily(v PlatformSettlementCycleMethodDaily) error {
	v.Type = "DAILY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementCycleMethodDaily performs a merge with any union data inside the PlatformSettlementCycleMethod, using the provided PlatformSettlementCycleMethodDaily
func (t *PlatformSettlementCycleMethod) MergePlatformSettlementCycleMethodDaily(v PlatformSettlementCycleMethodDaily) error {
	v.Type = "DAILY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementCycleMethodManualDates returns the union data inside the PlatformSettlementCycleMethod as a PlatformSettlementCycleMethodManualDates
func (t PlatformSettlementCycleMethod) AsPlatformSettlementCycleMethodManualDates() (PlatformSettlementCycleMethodManualDates, error) {
	var body PlatformSettlementCycleMethodManualDates
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementCycleMethodManualDates overwrites any union data inside the PlatformSettlementCycleMethod as the provided PlatformSettlementCycleMethodManualDates
func (t *PlatformSettlementCycleMethod) FromPlatformSettlementCycleMethodManualDates(v PlatformSettlementCycleMethodManualDates) error {
	v.Type = "MANUAL_DATES"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementCycleMethodManualDates performs a merge with any union data inside the PlatformSettlementCycleMethod, using the provided PlatformSettlementCycleMethodManualDates
func (t *PlatformSettlementCycleMethod) MergePlatformSettlementCycleMethodManualDates(v PlatformSettlementCycleMethodManualDates) error {
	v.Type = "MANUAL_DATES"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementCycleMethodMonthly returns the union data inside the PlatformSettlementCycleMethod as a PlatformSettlementCycleMethodMonthly
func (t PlatformSettlementCycleMethod) AsPlatformSettlementCycleMethodMonthly() (PlatformSettlementCycleMethodMonthly, error) {
	var body PlatformSettlementCycleMethodMonthly
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementCycleMethodMonthly overwrites any union data inside the PlatformSettlementCycleMethod as the provided PlatformSettlementCycleMethodMonthly
func (t *PlatformSettlementCycleMethod) FromPlatformSettlementCycleMethodMonthly(v PlatformSettlementCycleMethodMonthly) error {
	v.Type = "MONTHLY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementCycleMethodMonthly performs a merge with any union data inside the PlatformSettlementCycleMethod, using the provided PlatformSettlementCycleMethodMonthly
func (t *PlatformSettlementCycleMethod) MergePlatformSettlementCycleMethodMonthly(v PlatformSettlementCycleMethodMonthly) error {
	v.Type = "MONTHLY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformSettlementCycleMethodWeekly returns the union data inside the PlatformSettlementCycleMethod as a PlatformSettlementCycleMethodWeekly
func (t PlatformSettlementCycleMethod) AsPlatformSettlementCycleMethodWeekly() (PlatformSettlementCycleMethodWeekly, error) {
	var body PlatformSettlementCycleMethodWeekly
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformSettlementCycleMethodWeekly overwrites any union data inside the PlatformSettlementCycleMethod as the provided PlatformSettlementCycleMethodWeekly
func (t *PlatformSettlementCycleMethod) FromPlatformSettlementCycleMethodWeekly(v PlatformSettlementCycleMethodWeekly) error {
	v.Type = "WEEKLY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformSettlementCycleMethodWeekly performs a merge with any union data inside the PlatformSettlementCycleMethod, using the provided PlatformSettlementCycleMethodWeekly
func (t *PlatformSettlementCycleMethod) MergePlatformSettlementCycleMethodWeekly(v PlatformSettlementCycleMethodWeekly) error {
	v.Type = "WEEKLY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformSettlementCycleMethod) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformSettlementCycleMethod) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DAILY":
		return t.AsPlatformSettlementCycleMethodDaily()
	case "MANUAL_DATES":
		return t.AsPlatformSettlementCycleMethodManualDates()
	case "MONTHLY":
		return t.AsPlatformSettlementCycleMethodMonthly()
	case "WEEKLY":
		return t.AsPlatformSettlementCycleMethodWeekly()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformSettlementCycleMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformSettlementCycleMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformManualTransfer returns the union data inside the PlatformTransfer as a PlatformManualTransfer
func (t PlatformTransfer) AsPlatformManualTransfer() (PlatformManualTransfer, error) {
	var body PlatformManualTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformManualTransfer overwrites any union data inside the PlatformTransfer as the provided PlatformManualTransfer
func (t *PlatformTransfer) FromPlatformManualTransfer(v PlatformManualTransfer) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformManualTransfer performs a merge with any union data inside the PlatformTransfer, using the provided PlatformManualTransfer
func (t *PlatformTransfer) MergePlatformManualTransfer(v PlatformManualTransfer) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderCancelTransfer returns the union data inside the PlatformTransfer as a PlatformOrderCancelTransfer
func (t PlatformTransfer) AsPlatformOrderCancelTransfer() (PlatformOrderCancelTransfer, error) {
	var body PlatformOrderCancelTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderCancelTransfer overwrites any union data inside the PlatformTransfer as the provided PlatformOrderCancelTransfer
func (t *PlatformTransfer) FromPlatformOrderCancelTransfer(v PlatformOrderCancelTransfer) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderCancelTransfer performs a merge with any union data inside the PlatformTransfer, using the provided PlatformOrderCancelTransfer
func (t *PlatformTransfer) MergePlatformOrderCancelTransfer(v PlatformOrderCancelTransfer) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderTransfer returns the union data inside the PlatformTransfer as a PlatformOrderTransfer
func (t PlatformTransfer) AsPlatformOrderTransfer() (PlatformOrderTransfer, error) {
	var body PlatformOrderTransfer
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderTransfer overwrites any union data inside the PlatformTransfer as the provided PlatformOrderTransfer
func (t *PlatformTransfer) FromPlatformOrderTransfer(v PlatformOrderTransfer) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderTransfer performs a merge with any union data inside the PlatformTransfer, using the provided PlatformOrderTransfer
func (t *PlatformTransfer) MergePlatformOrderTransfer(v PlatformOrderTransfer) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformTransfer) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformTransfer) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MANUAL":
		return t.AsPlatformManualTransfer()
	case "ORDER":
		return t.AsPlatformOrderTransfer()
	case "ORDER_CANCEL":
		return t.AsPlatformOrderCancelTransfer()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformTransfer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformTransfer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformManualTransferSummary returns the union data inside the PlatformTransferSummary as a PlatformManualTransferSummary
func (t PlatformTransferSummary) AsPlatformManualTransferSummary() (PlatformManualTransferSummary, error) {
	var body PlatformManualTransferSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformManualTransferSummary overwrites any union data inside the PlatformTransferSummary as the provided PlatformManualTransferSummary
func (t *PlatformTransferSummary) FromPlatformManualTransferSummary(v PlatformManualTransferSummary) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformManualTransferSummary performs a merge with any union data inside the PlatformTransferSummary, using the provided PlatformManualTransferSummary
func (t *PlatformTransferSummary) MergePlatformManualTransferSummary(v PlatformManualTransferSummary) error {
	v.Type = "MANUAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderCancelTransferSummary returns the union data inside the PlatformTransferSummary as a PlatformOrderCancelTransferSummary
func (t PlatformTransferSummary) AsPlatformOrderCancelTransferSummary() (PlatformOrderCancelTransferSummary, error) {
	var body PlatformOrderCancelTransferSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderCancelTransferSummary overwrites any union data inside the PlatformTransferSummary as the provided PlatformOrderCancelTransferSummary
func (t *PlatformTransferSummary) FromPlatformOrderCancelTransferSummary(v PlatformOrderCancelTransferSummary) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderCancelTransferSummary performs a merge with any union data inside the PlatformTransferSummary, using the provided PlatformOrderCancelTransferSummary
func (t *PlatformTransferSummary) MergePlatformOrderCancelTransferSummary(v PlatformOrderCancelTransferSummary) error {
	v.Type = "ORDER_CANCEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformOrderTransferSummary returns the union data inside the PlatformTransferSummary as a PlatformOrderTransferSummary
func (t PlatformTransferSummary) AsPlatformOrderTransferSummary() (PlatformOrderTransferSummary, error) {
	var body PlatformOrderTransferSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformOrderTransferSummary overwrites any union data inside the PlatformTransferSummary as the provided PlatformOrderTransferSummary
func (t *PlatformTransferSummary) FromPlatformOrderTransferSummary(v PlatformOrderTransferSummary) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformOrderTransferSummary performs a merge with any union data inside the PlatformTransferSummary, using the provided PlatformOrderTransferSummary
func (t *PlatformTransferSummary) MergePlatformOrderTransferSummary(v PlatformOrderTransferSummary) error {
	v.Type = "ORDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformTransferSummary) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformTransferSummary) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MANUAL":
		return t.AsPlatformManualTransferSummary()
	case "ORDER":
		return t.AsPlatformOrderTransferSummary()
	case "ORDER_CANCEL":
		return t.AsPlatformOrderCancelTransferSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformTransferSummary) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformTransferSummary) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlatformTransferSummaryExternalPayment returns the union data inside the PlatformTransferSummaryPayment as a PlatformTransferSummaryExternalPayment
func (t PlatformTransferSummaryPayment) AsPlatformTransferSummaryExternalPayment() (PlatformTransferSummaryExternalPayment, error) {
	var body PlatformTransferSummaryExternalPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferSummaryExternalPayment overwrites any union data inside the PlatformTransferSummaryPayment as the provided PlatformTransferSummaryExternalPayment
func (t *PlatformTransferSummaryPayment) FromPlatformTransferSummaryExternalPayment(v PlatformTransferSummaryExternalPayment) error {
	v.Type = "EXTERNAL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferSummaryExternalPayment performs a merge with any union data inside the PlatformTransferSummaryPayment, using the provided PlatformTransferSummaryExternalPayment
func (t *PlatformTransferSummaryPayment) MergePlatformTransferSummaryExternalPayment(v PlatformTransferSummaryExternalPayment) error {
	v.Type = "EXTERNAL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformTransferSummaryPortOnePayment returns the union data inside the PlatformTransferSummaryPayment as a PlatformTransferSummaryPortOnePayment
func (t PlatformTransferSummaryPayment) AsPlatformTransferSummaryPortOnePayment() (PlatformTransferSummaryPortOnePayment, error) {
	var body PlatformTransferSummaryPortOnePayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformTransferSummaryPortOnePayment overwrites any union data inside the PlatformTransferSummaryPayment as the provided PlatformTransferSummaryPortOnePayment
func (t *PlatformTransferSummaryPayment) FromPlatformTransferSummaryPortOnePayment(v PlatformTransferSummaryPortOnePayment) error {
	v.Type = "PORT_ONE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformTransferSummaryPortOnePayment performs a merge with any union data inside the PlatformTransferSummaryPayment, using the provided PlatformTransferSummaryPortOnePayment
func (t *PlatformTransferSummaryPayment) MergePlatformTransferSummaryPortOnePayment(v PlatformTransferSummaryPortOnePayment) error {
	v.Type = "PORT_ONE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlatformTransferSummaryPayment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlatformTransferSummaryPayment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "EXTERNAL":
		return t.AsPlatformTransferSummaryExternalPayment()
	case "PORT_ONE":
		return t.AsPlatformTransferSummaryPortOnePayment()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlatformTransferSummaryPayment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlatformTransferSummaryPayment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAlreadyPaidError returns the union data inside the PreRegisterPaymentError as a AlreadyPaidError
func (t PreRegisterPaymentError) AsAlreadyPaidError() (AlreadyPaidError, error) {
	var body AlreadyPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlreadyPaidError overwrites any union data inside the PreRegisterPaymentError as the provided AlreadyPaidError
func (t *PreRegisterPaymentError) FromAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlreadyPaidError performs a merge with any union data inside the PreRegisterPaymentError, using the provided AlreadyPaidError
func (t *PreRegisterPaymentError) MergeAlreadyPaidError(v AlreadyPaidError) error {
	v.Type = "ALREADY_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the PreRegisterPaymentError as a ForbiddenError
func (t PreRegisterPaymentError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the PreRegisterPaymentError as the provided ForbiddenError
func (t *PreRegisterPaymentError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the PreRegisterPaymentError, using the provided ForbiddenError
func (t *PreRegisterPaymentError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the PreRegisterPaymentError as a InvalidRequestError
func (t PreRegisterPaymentError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the PreRegisterPaymentError as the provided InvalidRequestError
func (t *PreRegisterPaymentError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the PreRegisterPaymentError, using the provided InvalidRequestError
func (t *PreRegisterPaymentError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the PreRegisterPaymentError as a UnauthorizedError
func (t PreRegisterPaymentError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the PreRegisterPaymentError as the provided UnauthorizedError
func (t *PreRegisterPaymentError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the PreRegisterPaymentError, using the provided UnauthorizedError
func (t *PreRegisterPaymentError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreRegisterPaymentError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PreRegisterPaymentError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ALREADY_PAID":
		return t.AsAlreadyPaidError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PreRegisterPaymentError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreRegisterPaymentError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCardPromotion returns the union data inside the Promotion as a CardPromotion
func (t Promotion) AsCardPromotion() (CardPromotion, error) {
	var body CardPromotion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPromotion overwrites any union data inside the Promotion as the provided CardPromotion
func (t *Promotion) FromCardPromotion(v CardPromotion) error {
	v.Type = "CARD"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPromotion performs a merge with any union data inside the Promotion, using the provided CardPromotion
func (t *Promotion) MergeCardPromotion(v CardPromotion) error {
	v.Type = "CARD"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Promotion) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Promotion) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CARD":
		return t.AsCardPromotion()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Promotion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Promotion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromotionAmountDiscountScheme returns the union data inside the PromotionDiscountScheme as a PromotionAmountDiscountScheme
func (t PromotionDiscountScheme) AsPromotionAmountDiscountScheme() (PromotionAmountDiscountScheme, error) {
	var body PromotionAmountDiscountScheme
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionAmountDiscountScheme overwrites any union data inside the PromotionDiscountScheme as the provided PromotionAmountDiscountScheme
func (t *PromotionDiscountScheme) FromPromotionAmountDiscountScheme(v PromotionAmountDiscountScheme) error {
	v.Type = "AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionAmountDiscountScheme performs a merge with any union data inside the PromotionDiscountScheme, using the provided PromotionAmountDiscountScheme
func (t *PromotionDiscountScheme) MergePromotionAmountDiscountScheme(v PromotionAmountDiscountScheme) error {
	v.Type = "AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionPercentDiscountScheme returns the union data inside the PromotionDiscountScheme as a PromotionPercentDiscountScheme
func (t PromotionDiscountScheme) AsPromotionPercentDiscountScheme() (PromotionPercentDiscountScheme, error) {
	var body PromotionPercentDiscountScheme
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionPercentDiscountScheme overwrites any union data inside the PromotionDiscountScheme as the provided PromotionPercentDiscountScheme
func (t *PromotionDiscountScheme) FromPromotionPercentDiscountScheme(v PromotionPercentDiscountScheme) error {
	v.Type = "PERCENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionPercentDiscountScheme performs a merge with any union data inside the PromotionDiscountScheme, using the provided PromotionPercentDiscountScheme
func (t *PromotionDiscountScheme) MergePromotionPercentDiscountScheme(v PromotionPercentDiscountScheme) error {
	v.Type = "PERCENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromotionDiscountScheme) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromotionDiscountScheme) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AMOUNT":
		return t.AsPromotionAmountDiscountScheme()
	case "PERCENT":
		return t.AsPromotionPercentDiscountScheme()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromotionDiscountScheme) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromotionDiscountScheme) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromotionRecoverOptionNoRecover returns the union data inside the PromotionRecoverOption as a PromotionRecoverOptionNoRecover
func (t PromotionRecoverOption) AsPromotionRecoverOptionNoRecover() (PromotionRecoverOptionNoRecover, error) {
	var body PromotionRecoverOptionNoRecover
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionRecoverOptionNoRecover overwrites any union data inside the PromotionRecoverOption as the provided PromotionRecoverOptionNoRecover
func (t *PromotionRecoverOption) FromPromotionRecoverOptionNoRecover(v PromotionRecoverOptionNoRecover) error {
	v.Type = "NO_RECOVER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionRecoverOptionNoRecover performs a merge with any union data inside the PromotionRecoverOption, using the provided PromotionRecoverOptionNoRecover
func (t *PromotionRecoverOption) MergePromotionRecoverOptionNoRecover(v PromotionRecoverOptionNoRecover) error {
	v.Type = "NO_RECOVER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionRecoverOptionRecover returns the union data inside the PromotionRecoverOption as a PromotionRecoverOptionRecover
func (t PromotionRecoverOption) AsPromotionRecoverOptionRecover() (PromotionRecoverOptionRecover, error) {
	var body PromotionRecoverOptionRecover
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionRecoverOptionRecover overwrites any union data inside the PromotionRecoverOption as the provided PromotionRecoverOptionRecover
func (t *PromotionRecoverOption) FromPromotionRecoverOptionRecover(v PromotionRecoverOptionRecover) error {
	v.Type = "RECOVER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionRecoverOptionRecover performs a merge with any union data inside the PromotionRecoverOption, using the provided PromotionRecoverOptionRecover
func (t *PromotionRecoverOption) MergePromotionRecoverOptionRecover(v PromotionRecoverOptionRecover) error {
	v.Type = "RECOVER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromotionRecoverOption) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromotionRecoverOption) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "NO_RECOVER":
		return t.AsPromotionRecoverOptionNoRecover()
	case "RECOVER":
		return t.AsPromotionRecoverOptionRecover()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromotionRecoverOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromotionRecoverOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPromotionSpareBudgetAmount returns the union data inside the PromotionSpareBudget as a PromotionSpareBudgetAmount
func (t PromotionSpareBudget) AsPromotionSpareBudgetAmount() (PromotionSpareBudgetAmount, error) {
	var body PromotionSpareBudgetAmount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionSpareBudgetAmount overwrites any union data inside the PromotionSpareBudget as the provided PromotionSpareBudgetAmount
func (t *PromotionSpareBudget) FromPromotionSpareBudgetAmount(v PromotionSpareBudgetAmount) error {
	v.Type = "AMOUNT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionSpareBudgetAmount performs a merge with any union data inside the PromotionSpareBudget, using the provided PromotionSpareBudgetAmount
func (t *PromotionSpareBudget) MergePromotionSpareBudgetAmount(v PromotionSpareBudgetAmount) error {
	v.Type = "AMOUNT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPromotionSpareBudgetPercent returns the union data inside the PromotionSpareBudget as a PromotionSpareBudgetPercent
func (t PromotionSpareBudget) AsPromotionSpareBudgetPercent() (PromotionSpareBudgetPercent, error) {
	var body PromotionSpareBudgetPercent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPromotionSpareBudgetPercent overwrites any union data inside the PromotionSpareBudget as the provided PromotionSpareBudgetPercent
func (t *PromotionSpareBudget) FromPromotionSpareBudgetPercent(v PromotionSpareBudgetPercent) error {
	v.Type = "PERCENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePromotionSpareBudgetPercent performs a merge with any union data inside the PromotionSpareBudget, using the provided PromotionSpareBudgetPercent
func (t *PromotionSpareBudget) MergePromotionSpareBudgetPercent(v PromotionSpareBudgetPercent) error {
	v.Type = "PERCENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PromotionSpareBudget) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PromotionSpareBudget) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AMOUNT":
		return t.AsPromotionSpareBudgetAmount()
	case "PERCENT":
		return t.AsPromotionSpareBudgetPercent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PromotionSpareBudget) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PromotionSpareBudget) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RecoverPlatformAdditionalFeePolicyError as a ForbiddenError
func (t RecoverPlatformAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RecoverPlatformAdditionalFeePolicyError as the provided ForbiddenError
func (t *RecoverPlatformAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RecoverPlatformAdditionalFeePolicyError, using the provided ForbiddenError
func (t *RecoverPlatformAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RecoverPlatformAdditionalFeePolicyError as a InvalidRequestError
func (t RecoverPlatformAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RecoverPlatformAdditionalFeePolicyError as the provided InvalidRequestError
func (t *RecoverPlatformAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RecoverPlatformAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *RecoverPlatformAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the RecoverPlatformAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t RecoverPlatformAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the RecoverPlatformAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *RecoverPlatformAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the RecoverPlatformAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *RecoverPlatformAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RecoverPlatformAdditionalFeePolicyError as a PlatformNotEnabledError
func (t RecoverPlatformAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RecoverPlatformAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *RecoverPlatformAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RecoverPlatformAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *RecoverPlatformAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RecoverPlatformAdditionalFeePolicyError as a UnauthorizedError
func (t RecoverPlatformAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RecoverPlatformAdditionalFeePolicyError as the provided UnauthorizedError
func (t *RecoverPlatformAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RecoverPlatformAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *RecoverPlatformAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecoverPlatformAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RecoverPlatformAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RecoverPlatformAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecoverPlatformAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RecoverPlatformContractError as a ForbiddenError
func (t RecoverPlatformContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RecoverPlatformContractError as the provided ForbiddenError
func (t *RecoverPlatformContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RecoverPlatformContractError, using the provided ForbiddenError
func (t *RecoverPlatformContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RecoverPlatformContractError as a InvalidRequestError
func (t RecoverPlatformContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RecoverPlatformContractError as the provided InvalidRequestError
func (t *RecoverPlatformContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RecoverPlatformContractError, using the provided InvalidRequestError
func (t *RecoverPlatformContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the RecoverPlatformContractError as a PlatformContractNotFoundError
func (t RecoverPlatformContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the RecoverPlatformContractError as the provided PlatformContractNotFoundError
func (t *RecoverPlatformContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the RecoverPlatformContractError, using the provided PlatformContractNotFoundError
func (t *RecoverPlatformContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RecoverPlatformContractError as a PlatformNotEnabledError
func (t RecoverPlatformContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RecoverPlatformContractError as the provided PlatformNotEnabledError
func (t *RecoverPlatformContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RecoverPlatformContractError, using the provided PlatformNotEnabledError
func (t *RecoverPlatformContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RecoverPlatformContractError as a UnauthorizedError
func (t RecoverPlatformContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RecoverPlatformContractError as the provided UnauthorizedError
func (t *RecoverPlatformContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RecoverPlatformContractError, using the provided UnauthorizedError
func (t *RecoverPlatformContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecoverPlatformContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RecoverPlatformContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RecoverPlatformContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecoverPlatformContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RecoverPlatformDiscountSharePolicyError as a ForbiddenError
func (t RecoverPlatformDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RecoverPlatformDiscountSharePolicyError as the provided ForbiddenError
func (t *RecoverPlatformDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RecoverPlatformDiscountSharePolicyError, using the provided ForbiddenError
func (t *RecoverPlatformDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RecoverPlatformDiscountSharePolicyError as a InvalidRequestError
func (t RecoverPlatformDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RecoverPlatformDiscountSharePolicyError as the provided InvalidRequestError
func (t *RecoverPlatformDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RecoverPlatformDiscountSharePolicyError, using the provided InvalidRequestError
func (t *RecoverPlatformDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the RecoverPlatformDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t RecoverPlatformDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the RecoverPlatformDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *RecoverPlatformDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the RecoverPlatformDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *RecoverPlatformDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RecoverPlatformDiscountSharePolicyError as a PlatformNotEnabledError
func (t RecoverPlatformDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RecoverPlatformDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *RecoverPlatformDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RecoverPlatformDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *RecoverPlatformDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RecoverPlatformDiscountSharePolicyError as a UnauthorizedError
func (t RecoverPlatformDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RecoverPlatformDiscountSharePolicyError as the provided UnauthorizedError
func (t *RecoverPlatformDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RecoverPlatformDiscountSharePolicyError, using the provided UnauthorizedError
func (t *RecoverPlatformDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecoverPlatformDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RecoverPlatformDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RecoverPlatformDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecoverPlatformDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RecoverPlatformPartnerError as a ForbiddenError
func (t RecoverPlatformPartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RecoverPlatformPartnerError as the provided ForbiddenError
func (t *RecoverPlatformPartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RecoverPlatformPartnerError, using the provided ForbiddenError
func (t *RecoverPlatformPartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RecoverPlatformPartnerError as a InvalidRequestError
func (t RecoverPlatformPartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RecoverPlatformPartnerError as the provided InvalidRequestError
func (t *RecoverPlatformPartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RecoverPlatformPartnerError, using the provided InvalidRequestError
func (t *RecoverPlatformPartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RecoverPlatformPartnerError as a PlatformNotEnabledError
func (t RecoverPlatformPartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RecoverPlatformPartnerError as the provided PlatformNotEnabledError
func (t *RecoverPlatformPartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RecoverPlatformPartnerError, using the provided PlatformNotEnabledError
func (t *RecoverPlatformPartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the RecoverPlatformPartnerError as a PlatformPartnerNotFoundError
func (t RecoverPlatformPartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the RecoverPlatformPartnerError as the provided PlatformPartnerNotFoundError
func (t *RecoverPlatformPartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the RecoverPlatformPartnerError, using the provided PlatformPartnerNotFoundError
func (t *RecoverPlatformPartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RecoverPlatformPartnerError as a UnauthorizedError
func (t RecoverPlatformPartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RecoverPlatformPartnerError as the provided UnauthorizedError
func (t *RecoverPlatformPartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RecoverPlatformPartnerError, using the provided UnauthorizedError
func (t *RecoverPlatformPartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RecoverPlatformPartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RecoverPlatformPartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RecoverPlatformPartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RecoverPlatformPartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInvalidRequestError returns the union data inside the RefreshTokenError as a InvalidRequestError
func (t RefreshTokenError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RefreshTokenError as the provided InvalidRequestError
func (t *RefreshTokenError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RefreshTokenError, using the provided InvalidRequestError
func (t *RefreshTokenError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RefreshTokenError as a UnauthorizedError
func (t RefreshTokenError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RefreshTokenError as the provided UnauthorizedError
func (t *RefreshTokenError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RefreshTokenError, using the provided UnauthorizedError
func (t *RefreshTokenError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RefreshTokenError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RefreshTokenError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RefreshTokenError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RefreshTokenError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a B2bExternalServiceError
func (t RefuseB2bTaxInvoiceRequestError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided B2bExternalServiceError
func (t *RefuseB2bTaxInvoiceRequestError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided B2bExternalServiceError
func (t *RefuseB2bTaxInvoiceRequestError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a B2bNotEnabledError
func (t RefuseB2bTaxInvoiceRequestError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided B2bNotEnabledError
func (t *RefuseB2bTaxInvoiceRequestError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided B2bNotEnabledError
func (t *RefuseB2bTaxInvoiceRequestError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNoSupplierDocumentKeyError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a B2bTaxInvoiceNoSupplierDocumentKeyError
func (t RefuseB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNoSupplierDocumentKeyError() (B2bTaxInvoiceNoSupplierDocumentKeyError, error) {
	var body B2bTaxInvoiceNoSupplierDocumentKeyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNoSupplierDocumentKeyError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNoSupplierDocumentKeyError
func (t *RefuseB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNoSupplierDocumentKeyError(v B2bTaxInvoiceNoSupplierDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNoSupplierDocumentKeyError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNoSupplierDocumentKeyError
func (t *RefuseB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNoSupplierDocumentKeyError(v B2bTaxInvoiceNoSupplierDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a B2bTaxInvoiceNotFoundError
func (t RefuseB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNotFoundError
func (t *RefuseB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNotFoundError
func (t *RefuseB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotRequestedStatusError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a B2bTaxInvoiceNotRequestedStatusError
func (t RefuseB2bTaxInvoiceRequestError) AsB2bTaxInvoiceNotRequestedStatusError() (B2bTaxInvoiceNotRequestedStatusError, error) {
	var body B2bTaxInvoiceNotRequestedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotRequestedStatusError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided B2bTaxInvoiceNotRequestedStatusError
func (t *RefuseB2bTaxInvoiceRequestError) FromB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotRequestedStatusError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided B2bTaxInvoiceNotRequestedStatusError
func (t *RefuseB2bTaxInvoiceRequestError) MergeB2bTaxInvoiceNotRequestedStatusError(v B2bTaxInvoiceNotRequestedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a ForbiddenError
func (t RefuseB2bTaxInvoiceRequestError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided ForbiddenError
func (t *RefuseB2bTaxInvoiceRequestError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided ForbiddenError
func (t *RefuseB2bTaxInvoiceRequestError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a InvalidRequestError
func (t RefuseB2bTaxInvoiceRequestError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided InvalidRequestError
func (t *RefuseB2bTaxInvoiceRequestError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided InvalidRequestError
func (t *RefuseB2bTaxInvoiceRequestError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RefuseB2bTaxInvoiceRequestError as a UnauthorizedError
func (t RefuseB2bTaxInvoiceRequestError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RefuseB2bTaxInvoiceRequestError as the provided UnauthorizedError
func (t *RefuseB2bTaxInvoiceRequestError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RefuseB2bTaxInvoiceRequestError, using the provided UnauthorizedError
func (t *RefuseB2bTaxInvoiceRequestError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RefuseB2bTaxInvoiceRequestError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RefuseB2bTaxInvoiceRequestError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_REQUESTED_STATUS":
		return t.AsB2bTaxInvoiceNotRequestedStatusError()
	case "B2B_TAX_INVOICE_NO_SUPPLIER_DOCUMENT_KEY":
		return t.AsB2bTaxInvoiceNoSupplierDocumentKeyError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RefuseB2bTaxInvoiceRequestError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RefuseB2bTaxInvoiceRequestError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RegisterStoreReceiptError as a ForbiddenError
func (t RegisterStoreReceiptError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RegisterStoreReceiptError as the provided ForbiddenError
func (t *RegisterStoreReceiptError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided ForbiddenError
func (t *RegisterStoreReceiptError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RegisterStoreReceiptError as a InvalidRequestError
func (t RegisterStoreReceiptError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RegisterStoreReceiptError as the provided InvalidRequestError
func (t *RegisterStoreReceiptError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided InvalidRequestError
func (t *RegisterStoreReceiptError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the RegisterStoreReceiptError as a PaymentNotFoundError
func (t RegisterStoreReceiptError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the RegisterStoreReceiptError as the provided PaymentNotFoundError
func (t *RegisterStoreReceiptError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided PaymentNotFoundError
func (t *RegisterStoreReceiptError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotPaidError returns the union data inside the RegisterStoreReceiptError as a PaymentNotPaidError
func (t RegisterStoreReceiptError) AsPaymentNotPaidError() (PaymentNotPaidError, error) {
	var body PaymentNotPaidError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotPaidError overwrites any union data inside the RegisterStoreReceiptError as the provided PaymentNotPaidError
func (t *RegisterStoreReceiptError) FromPaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotPaidError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided PaymentNotPaidError
func (t *RegisterStoreReceiptError) MergePaymentNotPaidError(v PaymentNotPaidError) error {
	v.Type = "PAYMENT_NOT_PAID"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the RegisterStoreReceiptError as a PgProviderError
func (t RegisterStoreReceiptError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the RegisterStoreReceiptError as the provided PgProviderError
func (t *RegisterStoreReceiptError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided PgProviderError
func (t *RegisterStoreReceiptError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RegisterStoreReceiptError as a UnauthorizedError
func (t RegisterStoreReceiptError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RegisterStoreReceiptError as the provided UnauthorizedError
func (t *RegisterStoreReceiptError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RegisterStoreReceiptError, using the provided UnauthorizedError
func (t *RegisterStoreReceiptError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegisterStoreReceiptError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RegisterStoreReceiptError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "PAYMENT_NOT_PAID":
		return t.AsPaymentNotPaidError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RegisterStoreReceiptError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegisterStoreReceiptError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2BCannotChangeTaxTypeError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2BCannotChangeTaxTypeError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2BCannotChangeTaxTypeError() (B2BCannotChangeTaxTypeError, error) {
	var body B2BCannotChangeTaxTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BCannotChangeTaxTypeError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2BCannotChangeTaxTypeError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BCannotChangeTaxTypeError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2BCannotChangeTaxTypeError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2BTaxInvoiceStatusNotSendingCompletedError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2BTaxInvoiceStatusNotSendingCompletedError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2BTaxInvoiceStatusNotSendingCompletedError() (B2BTaxInvoiceStatusNotSendingCompletedError, error) {
	var body B2BTaxInvoiceStatusNotSendingCompletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BTaxInvoiceStatusNotSendingCompletedError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BTaxInvoiceStatusNotSendingCompletedError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bExternalServiceError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bExternalServiceError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bExternalServiceError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIdAlreadyExistsError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bIdAlreadyExistsError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bIdAlreadyExistsError() (B2bIdAlreadyExistsError, error) {
	var body B2bIdAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIdAlreadyExistsError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bIdAlreadyExistsError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIdAlreadyExistsError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bIdAlreadyExistsError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIssuanceTypeMismatchError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bIssuanceTypeMismatchError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bIssuanceTypeMismatchError() (B2bIssuanceTypeMismatchError, error) {
	var body B2bIssuanceTypeMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIssuanceTypeMismatchError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bIssuanceTypeMismatchError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIssuanceTypeMismatchError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bIssuanceTypeMismatchError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bModificationNotProvidedError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bModificationNotProvidedError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bModificationNotProvidedError() (B2bModificationNotProvidedError, error) {
	var body B2bModificationNotProvidedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bModificationNotProvidedError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bModificationNotProvidedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bModificationNotProvidedError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bModificationNotProvidedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bNotEnabledError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bNotEnabledError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bNotEnabledError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bOriginalTaxInvoiceNotFoundError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bOriginalTaxInvoiceNotFoundError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bOriginalTaxInvoiceNotFoundError() (B2bOriginalTaxInvoiceNotFoundError, error) {
	var body B2bOriginalTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bOriginalTaxInvoiceNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bOriginalTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bOriginalTaxInvoiceNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bOriginalTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bRecipientNotFoundError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bRecipientNotFoundError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bRecipientNotFoundError() (B2bRecipientNotFoundError, error) {
	var body B2bRecipientNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bRecipientNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bRecipientNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bRecipientNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bRecipientNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bSupplierNotFoundError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bSupplierNotFoundError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bSupplierNotFoundError() (B2bSupplierNotFoundError, error) {
	var body B2bSupplierNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bSupplierNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bSupplierNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bSupplierNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bSupplierNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bTaxInvoiceNotFoundError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError() (B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError() (B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a ForbiddenError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided ForbiddenError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided ForbiddenError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a InvalidRequestError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided InvalidRequestError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided InvalidRequestError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RequestB2bTaxInvoiceReverseIssuanceError as a UnauthorizedError
func (t RequestB2bTaxInvoiceReverseIssuanceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RequestB2bTaxInvoiceReverseIssuanceError as the provided UnauthorizedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RequestB2bTaxInvoiceReverseIssuanceError, using the provided UnauthorizedError
func (t *RequestB2bTaxInvoiceReverseIssuanceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestB2bTaxInvoiceReverseIssuanceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RequestB2bTaxInvoiceReverseIssuanceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_CANNOT_CHANGE_TAX_TYPE":
		return t.AsB2BCannotChangeTaxTypeError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_ID_ALREADY_EXISTS":
		return t.AsB2bIdAlreadyExistsError()
	case "B2B_ISSUANCE_TYPE_MISMATCH":
		return t.AsB2bIssuanceTypeMismatchError()
	case "B2B_MODIFICATION_NOT_PROVIDED":
		return t.AsB2bModificationNotProvidedError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bOriginalTaxInvoiceNotFoundError()
	case "B2B_RECIPIENT_NOT_FOUND":
		return t.AsB2bRecipientNotFoundError()
	case "B2B_SUPPLIER_NOT_FOUND":
		return t.AsB2bSupplierNotFoundError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError()
	case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
		return t.AsB2BTaxInvoiceStatusNotSendingCompletedError()
	case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RequestB2bTaxInvoiceReverseIssuanceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestB2bTaxInvoiceReverseIssuanceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RescheduleAdditionalFeePolicyError as a ForbiddenError
func (t RescheduleAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RescheduleAdditionalFeePolicyError as the provided ForbiddenError
func (t *RescheduleAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RescheduleAdditionalFeePolicyError, using the provided ForbiddenError
func (t *RescheduleAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RescheduleAdditionalFeePolicyError as a InvalidRequestError
func (t RescheduleAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RescheduleAdditionalFeePolicyError as the provided InvalidRequestError
func (t *RescheduleAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RescheduleAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *RescheduleAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the RescheduleAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t RescheduleAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the RescheduleAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *RescheduleAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the RescheduleAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *RescheduleAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RescheduleAdditionalFeePolicyError as a PlatformNotEnabledError
func (t RescheduleAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RescheduleAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *RescheduleAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RescheduleAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *RescheduleAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RescheduleAdditionalFeePolicyError as a UnauthorizedError
func (t RescheduleAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RescheduleAdditionalFeePolicyError as the provided UnauthorizedError
func (t *RescheduleAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RescheduleAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *RescheduleAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RescheduleAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RescheduleAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RescheduleAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RescheduleAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RescheduleContractError as a ForbiddenError
func (t RescheduleContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RescheduleContractError as the provided ForbiddenError
func (t *RescheduleContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RescheduleContractError, using the provided ForbiddenError
func (t *RescheduleContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RescheduleContractError as a InvalidRequestError
func (t RescheduleContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RescheduleContractError as the provided InvalidRequestError
func (t *RescheduleContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RescheduleContractError, using the provided InvalidRequestError
func (t *RescheduleContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the RescheduleContractError as a PlatformContractNotFoundError
func (t RescheduleContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the RescheduleContractError as the provided PlatformContractNotFoundError
func (t *RescheduleContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the RescheduleContractError, using the provided PlatformContractNotFoundError
func (t *RescheduleContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RescheduleContractError as a PlatformNotEnabledError
func (t RescheduleContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RescheduleContractError as the provided PlatformNotEnabledError
func (t *RescheduleContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RescheduleContractError, using the provided PlatformNotEnabledError
func (t *RescheduleContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RescheduleContractError as a UnauthorizedError
func (t RescheduleContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RescheduleContractError as the provided UnauthorizedError
func (t *RescheduleContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RescheduleContractError, using the provided UnauthorizedError
func (t *RescheduleContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RescheduleContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RescheduleContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RescheduleContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RescheduleContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the RescheduleDiscountSharePolicyError as a ForbiddenError
func (t RescheduleDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RescheduleDiscountSharePolicyError as the provided ForbiddenError
func (t *RescheduleDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RescheduleDiscountSharePolicyError, using the provided ForbiddenError
func (t *RescheduleDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RescheduleDiscountSharePolicyError as a InvalidRequestError
func (t RescheduleDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RescheduleDiscountSharePolicyError as the provided InvalidRequestError
func (t *RescheduleDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RescheduleDiscountSharePolicyError, using the provided InvalidRequestError
func (t *RescheduleDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the RescheduleDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t RescheduleDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the RescheduleDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *RescheduleDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the RescheduleDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *RescheduleDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the RescheduleDiscountSharePolicyError as a PlatformNotEnabledError
func (t RescheduleDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the RescheduleDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *RescheduleDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the RescheduleDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *RescheduleDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RescheduleDiscountSharePolicyError as a UnauthorizedError
func (t RescheduleDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RescheduleDiscountSharePolicyError as the provided UnauthorizedError
func (t *RescheduleDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RescheduleDiscountSharePolicyError, using the provided UnauthorizedError
func (t *RescheduleDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RescheduleDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RescheduleDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RescheduleDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RescheduleDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ReschedulePartnerError as a ForbiddenError
func (t ReschedulePartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ReschedulePartnerError as the provided ForbiddenError
func (t *ReschedulePartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ReschedulePartnerError, using the provided ForbiddenError
func (t *ReschedulePartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ReschedulePartnerError as a InvalidRequestError
func (t ReschedulePartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ReschedulePartnerError as the provided InvalidRequestError
func (t *ReschedulePartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ReschedulePartnerError, using the provided InvalidRequestError
func (t *ReschedulePartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the ReschedulePartnerError as a PlatformContractNotFoundError
func (t ReschedulePartnerError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the ReschedulePartnerError as the provided PlatformContractNotFoundError
func (t *ReschedulePartnerError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the ReschedulePartnerError, using the provided PlatformContractNotFoundError
func (t *ReschedulePartnerError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError returns the union data inside the ReschedulePartnerError as a PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t ReschedulePartnerError) AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError() (PlatformMemberCompanyConnectedPartnerCannotBeScheduledError, error) {
	var body PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerCannotBeScheduledError overwrites any union data inside the ReschedulePartnerError as the provided PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t *ReschedulePartnerError) FromPlatformMemberCompanyConnectedPartnerCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnerCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerCannotBeScheduledError performs a merge with any union data inside the ReschedulePartnerError, using the provided PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t *ReschedulePartnerError) MergePlatformMemberCompanyConnectedPartnerCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnerCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ReschedulePartnerError as a PlatformNotEnabledError
func (t ReschedulePartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ReschedulePartnerError as the provided PlatformNotEnabledError
func (t *ReschedulePartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ReschedulePartnerError, using the provided PlatformNotEnabledError
func (t *ReschedulePartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the ReschedulePartnerError as a PlatformPartnerNotFoundError
func (t ReschedulePartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the ReschedulePartnerError as the provided PlatformPartnerNotFoundError
func (t *ReschedulePartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the ReschedulePartnerError, using the provided PlatformPartnerNotFoundError
func (t *ReschedulePartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ReschedulePartnerError as a UnauthorizedError
func (t ReschedulePartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ReschedulePartnerError as the provided UnauthorizedError
func (t *ReschedulePartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ReschedulePartnerError, using the provided UnauthorizedError
func (t *ReschedulePartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReschedulePartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ReschedulePartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED":
		return t.AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ReschedulePartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReschedulePartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ResendIdentityVerificationError as a ForbiddenError
func (t ResendIdentityVerificationError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ResendIdentityVerificationError as the provided ForbiddenError
func (t *ResendIdentityVerificationError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided ForbiddenError
func (t *ResendIdentityVerificationError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationAlreadyVerifiedError returns the union data inside the ResendIdentityVerificationError as a IdentityVerificationAlreadyVerifiedError
func (t ResendIdentityVerificationError) AsIdentityVerificationAlreadyVerifiedError() (IdentityVerificationAlreadyVerifiedError, error) {
	var body IdentityVerificationAlreadyVerifiedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationAlreadyVerifiedError overwrites any union data inside the ResendIdentityVerificationError as the provided IdentityVerificationAlreadyVerifiedError
func (t *ResendIdentityVerificationError) FromIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationAlreadyVerifiedError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided IdentityVerificationAlreadyVerifiedError
func (t *ResendIdentityVerificationError) MergeIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotFoundError returns the union data inside the ResendIdentityVerificationError as a IdentityVerificationNotFoundError
func (t ResendIdentityVerificationError) AsIdentityVerificationNotFoundError() (IdentityVerificationNotFoundError, error) {
	var body IdentityVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotFoundError overwrites any union data inside the ResendIdentityVerificationError as the provided IdentityVerificationNotFoundError
func (t *ResendIdentityVerificationError) FromIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotFoundError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided IdentityVerificationNotFoundError
func (t *ResendIdentityVerificationError) MergeIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotSentError returns the union data inside the ResendIdentityVerificationError as a IdentityVerificationNotSentError
func (t ResendIdentityVerificationError) AsIdentityVerificationNotSentError() (IdentityVerificationNotSentError, error) {
	var body IdentityVerificationNotSentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotSentError overwrites any union data inside the ResendIdentityVerificationError as the provided IdentityVerificationNotSentError
func (t *ResendIdentityVerificationError) FromIdentityVerificationNotSentError(v IdentityVerificationNotSentError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_SENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotSentError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided IdentityVerificationNotSentError
func (t *ResendIdentityVerificationError) MergeIdentityVerificationNotSentError(v IdentityVerificationNotSentError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_SENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ResendIdentityVerificationError as a InvalidRequestError
func (t ResendIdentityVerificationError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ResendIdentityVerificationError as the provided InvalidRequestError
func (t *ResendIdentityVerificationError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided InvalidRequestError
func (t *ResendIdentityVerificationError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the ResendIdentityVerificationError as a PgProviderError
func (t ResendIdentityVerificationError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the ResendIdentityVerificationError as the provided PgProviderError
func (t *ResendIdentityVerificationError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided PgProviderError
func (t *ResendIdentityVerificationError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ResendIdentityVerificationError as a UnauthorizedError
func (t ResendIdentityVerificationError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ResendIdentityVerificationError as the provided UnauthorizedError
func (t *ResendIdentityVerificationError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ResendIdentityVerificationError, using the provided UnauthorizedError
func (t *ResendIdentityVerificationError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResendIdentityVerificationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ResendIdentityVerificationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "IDENTITY_VERIFICATION_ALREADY_VERIFIED":
		return t.AsIdentityVerificationAlreadyVerifiedError()
	case "IDENTITY_VERIFICATION_NOT_FOUND":
		return t.AsIdentityVerificationNotFoundError()
	case "IDENTITY_VERIFICATION_NOT_SENT":
		return t.AsIdentityVerificationNotSentError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ResendIdentityVerificationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResendIdentityVerificationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ResendWebhookError as a ForbiddenError
func (t ResendWebhookError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ResendWebhookError as the provided ForbiddenError
func (t *ResendWebhookError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ResendWebhookError, using the provided ForbiddenError
func (t *ResendWebhookError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ResendWebhookError as a InvalidRequestError
func (t ResendWebhookError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ResendWebhookError as the provided InvalidRequestError
func (t *ResendWebhookError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ResendWebhookError, using the provided InvalidRequestError
func (t *ResendWebhookError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMaxWebhookRetryCountReachedError returns the union data inside the ResendWebhookError as a MaxWebhookRetryCountReachedError
func (t ResendWebhookError) AsMaxWebhookRetryCountReachedError() (MaxWebhookRetryCountReachedError, error) {
	var body MaxWebhookRetryCountReachedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMaxWebhookRetryCountReachedError overwrites any union data inside the ResendWebhookError as the provided MaxWebhookRetryCountReachedError
func (t *ResendWebhookError) FromMaxWebhookRetryCountReachedError(v MaxWebhookRetryCountReachedError) error {
	v.Type = "MAX_WEBHOOK_RETRY_COUNT_REACHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMaxWebhookRetryCountReachedError performs a merge with any union data inside the ResendWebhookError, using the provided MaxWebhookRetryCountReachedError
func (t *ResendWebhookError) MergeMaxWebhookRetryCountReachedError(v MaxWebhookRetryCountReachedError) error {
	v.Type = "MAX_WEBHOOK_RETRY_COUNT_REACHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentNotFoundError returns the union data inside the ResendWebhookError as a PaymentNotFoundError
func (t ResendWebhookError) AsPaymentNotFoundError() (PaymentNotFoundError, error) {
	var body PaymentNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentNotFoundError overwrites any union data inside the ResendWebhookError as the provided PaymentNotFoundError
func (t *ResendWebhookError) FromPaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentNotFoundError performs a merge with any union data inside the ResendWebhookError, using the provided PaymentNotFoundError
func (t *ResendWebhookError) MergePaymentNotFoundError(v PaymentNotFoundError) error {
	v.Type = "PAYMENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ResendWebhookError as a UnauthorizedError
func (t ResendWebhookError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ResendWebhookError as the provided UnauthorizedError
func (t *ResendWebhookError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ResendWebhookError, using the provided UnauthorizedError
func (t *ResendWebhookError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookNotFoundError returns the union data inside the ResendWebhookError as a WebhookNotFoundError
func (t ResendWebhookError) AsWebhookNotFoundError() (WebhookNotFoundError, error) {
	var body WebhookNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookNotFoundError overwrites any union data inside the ResendWebhookError as the provided WebhookNotFoundError
func (t *ResendWebhookError) FromWebhookNotFoundError(v WebhookNotFoundError) error {
	v.Type = "WEBHOOK_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookNotFoundError performs a merge with any union data inside the ResendWebhookError, using the provided WebhookNotFoundError
func (t *ResendWebhookError) MergeWebhookNotFoundError(v WebhookNotFoundError) error {
	v.Type = "WEBHOOK_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResendWebhookError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ResendWebhookError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "MAX_WEBHOOK_RETRY_COUNT_REACHED":
		return t.AsMaxWebhookRetryCountReachedError()
	case "PAYMENT_NOT_FOUND":
		return t.AsPaymentNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	case "WEBHOOK_NOT_FOUND":
		return t.AsWebhookNotFoundError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ResendWebhookError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResendWebhookError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBillingKeyAlreadyDeletedError returns the union data inside the RevokePaymentSchedulesError as a BillingKeyAlreadyDeletedError
func (t RevokePaymentSchedulesError) AsBillingKeyAlreadyDeletedError() (BillingKeyAlreadyDeletedError, error) {
	var body BillingKeyAlreadyDeletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyAlreadyDeletedError overwrites any union data inside the RevokePaymentSchedulesError as the provided BillingKeyAlreadyDeletedError
func (t *RevokePaymentSchedulesError) FromBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyAlreadyDeletedError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided BillingKeyAlreadyDeletedError
func (t *RevokePaymentSchedulesError) MergeBillingKeyAlreadyDeletedError(v BillingKeyAlreadyDeletedError) error {
	v.Type = "BILLING_KEY_ALREADY_DELETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBillingKeyNotFoundError returns the union data inside the RevokePaymentSchedulesError as a BillingKeyNotFoundError
func (t RevokePaymentSchedulesError) AsBillingKeyNotFoundError() (BillingKeyNotFoundError, error) {
	var body BillingKeyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBillingKeyNotFoundError overwrites any union data inside the RevokePaymentSchedulesError as the provided BillingKeyNotFoundError
func (t *RevokePaymentSchedulesError) FromBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBillingKeyNotFoundError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided BillingKeyNotFoundError
func (t *RevokePaymentSchedulesError) MergeBillingKeyNotFoundError(v BillingKeyNotFoundError) error {
	v.Type = "BILLING_KEY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the RevokePaymentSchedulesError as a ForbiddenError
func (t RevokePaymentSchedulesError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RevokePaymentSchedulesError as the provided ForbiddenError
func (t *RevokePaymentSchedulesError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided ForbiddenError
func (t *RevokePaymentSchedulesError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RevokePaymentSchedulesError as a InvalidRequestError
func (t RevokePaymentSchedulesError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RevokePaymentSchedulesError as the provided InvalidRequestError
func (t *RevokePaymentSchedulesError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided InvalidRequestError
func (t *RevokePaymentSchedulesError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyProcessedError returns the union data inside the RevokePaymentSchedulesError as a PaymentScheduleAlreadyProcessedError
func (t RevokePaymentSchedulesError) AsPaymentScheduleAlreadyProcessedError() (PaymentScheduleAlreadyProcessedError, error) {
	var body PaymentScheduleAlreadyProcessedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyProcessedError overwrites any union data inside the RevokePaymentSchedulesError as the provided PaymentScheduleAlreadyProcessedError
func (t *RevokePaymentSchedulesError) FromPaymentScheduleAlreadyProcessedError(v PaymentScheduleAlreadyProcessedError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_PROCESSED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyProcessedError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided PaymentScheduleAlreadyProcessedError
func (t *RevokePaymentSchedulesError) MergePaymentScheduleAlreadyProcessedError(v PaymentScheduleAlreadyProcessedError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_PROCESSED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleAlreadyRevokedError returns the union data inside the RevokePaymentSchedulesError as a PaymentScheduleAlreadyRevokedError
func (t RevokePaymentSchedulesError) AsPaymentScheduleAlreadyRevokedError() (PaymentScheduleAlreadyRevokedError, error) {
	var body PaymentScheduleAlreadyRevokedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleAlreadyRevokedError overwrites any union data inside the RevokePaymentSchedulesError as the provided PaymentScheduleAlreadyRevokedError
func (t *RevokePaymentSchedulesError) FromPaymentScheduleAlreadyRevokedError(v PaymentScheduleAlreadyRevokedError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_REVOKED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleAlreadyRevokedError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided PaymentScheduleAlreadyRevokedError
func (t *RevokePaymentSchedulesError) MergePaymentScheduleAlreadyRevokedError(v PaymentScheduleAlreadyRevokedError) error {
	v.Type = "PAYMENT_SCHEDULE_ALREADY_REVOKED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPaymentScheduleNotFoundError returns the union data inside the RevokePaymentSchedulesError as a PaymentScheduleNotFoundError
func (t RevokePaymentSchedulesError) AsPaymentScheduleNotFoundError() (PaymentScheduleNotFoundError, error) {
	var body PaymentScheduleNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPaymentScheduleNotFoundError overwrites any union data inside the RevokePaymentSchedulesError as the provided PaymentScheduleNotFoundError
func (t *RevokePaymentSchedulesError) FromPaymentScheduleNotFoundError(v PaymentScheduleNotFoundError) error {
	v.Type = "PAYMENT_SCHEDULE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePaymentScheduleNotFoundError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided PaymentScheduleNotFoundError
func (t *RevokePaymentSchedulesError) MergePaymentScheduleNotFoundError(v PaymentScheduleNotFoundError) error {
	v.Type = "PAYMENT_SCHEDULE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RevokePaymentSchedulesError as a UnauthorizedError
func (t RevokePaymentSchedulesError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RevokePaymentSchedulesError as the provided UnauthorizedError
func (t *RevokePaymentSchedulesError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RevokePaymentSchedulesError, using the provided UnauthorizedError
func (t *RevokePaymentSchedulesError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RevokePaymentSchedulesError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RevokePaymentSchedulesError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BILLING_KEY_ALREADY_DELETED":
		return t.AsBillingKeyAlreadyDeletedError()
	case "BILLING_KEY_NOT_FOUND":
		return t.AsBillingKeyNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PAYMENT_SCHEDULE_ALREADY_PROCESSED":
		return t.AsPaymentScheduleAlreadyProcessedError()
	case "PAYMENT_SCHEDULE_ALREADY_REVOKED":
		return t.AsPaymentScheduleAlreadyRevokedError()
	case "PAYMENT_SCHEDULE_NOT_FOUND":
		return t.AsPaymentScheduleNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RevokePaymentSchedulesError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RevokePaymentSchedulesError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ScheduleAdditionalFeePolicyError as a ForbiddenError
func (t ScheduleAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided ForbiddenError
func (t *ScheduleAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided ForbiddenError
func (t *ScheduleAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ScheduleAdditionalFeePolicyError as a InvalidRequestError
func (t ScheduleAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided InvalidRequestError
func (t *ScheduleAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *ScheduleAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the ScheduleAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t ScheduleAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *ScheduleAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *ScheduleAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyScheduleAlreadyExistsError returns the union data inside the ScheduleAdditionalFeePolicyError as a PlatformAdditionalFeePolicyScheduleAlreadyExistsError
func (t ScheduleAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyScheduleAlreadyExistsError() (PlatformAdditionalFeePolicyScheduleAlreadyExistsError, error) {
	var body PlatformAdditionalFeePolicyScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyScheduleAlreadyExistsError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyScheduleAlreadyExistsError
func (t *ScheduleAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyScheduleAlreadyExistsError(v PlatformAdditionalFeePolicyScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyScheduleAlreadyExistsError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyScheduleAlreadyExistsError
func (t *ScheduleAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyScheduleAlreadyExistsError(v PlatformAdditionalFeePolicyScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedAdditionalFeePolicyError returns the union data inside the ScheduleAdditionalFeePolicyError as a PlatformArchivedAdditionalFeePolicyError
func (t ScheduleAdditionalFeePolicyError) AsPlatformArchivedAdditionalFeePolicyError() (PlatformArchivedAdditionalFeePolicyError, error) {
	var body PlatformArchivedAdditionalFeePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedAdditionalFeePolicyError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided PlatformArchivedAdditionalFeePolicyError
func (t *ScheduleAdditionalFeePolicyError) FromPlatformArchivedAdditionalFeePolicyError(v PlatformArchivedAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedAdditionalFeePolicyError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided PlatformArchivedAdditionalFeePolicyError
func (t *ScheduleAdditionalFeePolicyError) MergePlatformArchivedAdditionalFeePolicyError(v PlatformArchivedAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ScheduleAdditionalFeePolicyError as a PlatformNotEnabledError
func (t ScheduleAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *ScheduleAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *ScheduleAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ScheduleAdditionalFeePolicyError as a UnauthorizedError
func (t ScheduleAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ScheduleAdditionalFeePolicyError as the provided UnauthorizedError
func (t *ScheduleAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ScheduleAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *ScheduleAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScheduleAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScheduleAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_SCHEDULE_ALREADY_EXISTS":
		return t.AsPlatformAdditionalFeePolicyScheduleAlreadyExistsError()
	case "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY":
		return t.AsPlatformArchivedAdditionalFeePolicyError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScheduleAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScheduleAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ScheduleContractError as a ForbiddenError
func (t ScheduleContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ScheduleContractError as the provided ForbiddenError
func (t *ScheduleContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ScheduleContractError, using the provided ForbiddenError
func (t *ScheduleContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ScheduleContractError as a InvalidRequestError
func (t ScheduleContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ScheduleContractError as the provided InvalidRequestError
func (t *ScheduleContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ScheduleContractError, using the provided InvalidRequestError
func (t *ScheduleContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedContractError returns the union data inside the ScheduleContractError as a PlatformArchivedContractError
func (t ScheduleContractError) AsPlatformArchivedContractError() (PlatformArchivedContractError, error) {
	var body PlatformArchivedContractError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedContractError overwrites any union data inside the ScheduleContractError as the provided PlatformArchivedContractError
func (t *ScheduleContractError) FromPlatformArchivedContractError(v PlatformArchivedContractError) error {
	v.Type = "PLATFORM_ARCHIVED_CONTRACT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedContractError performs a merge with any union data inside the ScheduleContractError, using the provided PlatformArchivedContractError
func (t *ScheduleContractError) MergePlatformArchivedContractError(v PlatformArchivedContractError) error {
	v.Type = "PLATFORM_ARCHIVED_CONTRACT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the ScheduleContractError as a PlatformContractNotFoundError
func (t ScheduleContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the ScheduleContractError as the provided PlatformContractNotFoundError
func (t *ScheduleContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the ScheduleContractError, using the provided PlatformContractNotFoundError
func (t *ScheduleContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractScheduleAlreadyExistsError returns the union data inside the ScheduleContractError as a PlatformContractScheduleAlreadyExistsError
func (t ScheduleContractError) AsPlatformContractScheduleAlreadyExistsError() (PlatformContractScheduleAlreadyExistsError, error) {
	var body PlatformContractScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractScheduleAlreadyExistsError overwrites any union data inside the ScheduleContractError as the provided PlatformContractScheduleAlreadyExistsError
func (t *ScheduleContractError) FromPlatformContractScheduleAlreadyExistsError(v PlatformContractScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_CONTRACT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractScheduleAlreadyExistsError performs a merge with any union data inside the ScheduleContractError, using the provided PlatformContractScheduleAlreadyExistsError
func (t *ScheduleContractError) MergePlatformContractScheduleAlreadyExistsError(v PlatformContractScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_CONTRACT_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ScheduleContractError as a PlatformNotEnabledError
func (t ScheduleContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ScheduleContractError as the provided PlatformNotEnabledError
func (t *ScheduleContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ScheduleContractError, using the provided PlatformNotEnabledError
func (t *ScheduleContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ScheduleContractError as a UnauthorizedError
func (t ScheduleContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ScheduleContractError as the provided UnauthorizedError
func (t *ScheduleContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ScheduleContractError, using the provided UnauthorizedError
func (t *ScheduleContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScheduleContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScheduleContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ARCHIVED_CONTRACT":
		return t.AsPlatformArchivedContractError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_CONTRACT_SCHEDULE_ALREADY_EXISTS":
		return t.AsPlatformContractScheduleAlreadyExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScheduleContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScheduleContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the ScheduleDiscountSharePolicyError as a ForbiddenError
func (t ScheduleDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided ForbiddenError
func (t *ScheduleDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided ForbiddenError
func (t *ScheduleDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the ScheduleDiscountSharePolicyError as a InvalidRequestError
func (t ScheduleDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided InvalidRequestError
func (t *ScheduleDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided InvalidRequestError
func (t *ScheduleDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedDiscountSharePolicyError returns the union data inside the ScheduleDiscountSharePolicyError as a PlatformArchivedDiscountSharePolicyError
func (t ScheduleDiscountSharePolicyError) AsPlatformArchivedDiscountSharePolicyError() (PlatformArchivedDiscountSharePolicyError, error) {
	var body PlatformArchivedDiscountSharePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedDiscountSharePolicyError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided PlatformArchivedDiscountSharePolicyError
func (t *ScheduleDiscountSharePolicyError) FromPlatformArchivedDiscountSharePolicyError(v PlatformArchivedDiscountSharePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedDiscountSharePolicyError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided PlatformArchivedDiscountSharePolicyError
func (t *ScheduleDiscountSharePolicyError) MergePlatformArchivedDiscountSharePolicyError(v PlatformArchivedDiscountSharePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the ScheduleDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t ScheduleDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *ScheduleDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *ScheduleDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyScheduleAlreadyExistsError returns the union data inside the ScheduleDiscountSharePolicyError as a PlatformDiscountSharePolicyScheduleAlreadyExistsError
func (t ScheduleDiscountSharePolicyError) AsPlatformDiscountSharePolicyScheduleAlreadyExistsError() (PlatformDiscountSharePolicyScheduleAlreadyExistsError, error) {
	var body PlatformDiscountSharePolicyScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyScheduleAlreadyExistsError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided PlatformDiscountSharePolicyScheduleAlreadyExistsError
func (t *ScheduleDiscountSharePolicyError) FromPlatformDiscountSharePolicyScheduleAlreadyExistsError(v PlatformDiscountSharePolicyScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyScheduleAlreadyExistsError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyScheduleAlreadyExistsError
func (t *ScheduleDiscountSharePolicyError) MergePlatformDiscountSharePolicyScheduleAlreadyExistsError(v PlatformDiscountSharePolicyScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the ScheduleDiscountSharePolicyError as a PlatformNotEnabledError
func (t ScheduleDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *ScheduleDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *ScheduleDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the ScheduleDiscountSharePolicyError as a UnauthorizedError
func (t ScheduleDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the ScheduleDiscountSharePolicyError as the provided UnauthorizedError
func (t *ScheduleDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the ScheduleDiscountSharePolicyError, using the provided UnauthorizedError
func (t *ScheduleDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScheduleDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScheduleDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY":
		return t.AsPlatformArchivedDiscountSharePolicyError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_SCHEDULE_ALREADY_EXISTS":
		return t.AsPlatformDiscountSharePolicyScheduleAlreadyExistsError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScheduleDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScheduleDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the SchedulePartnerError as a ForbiddenError
func (t SchedulePartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the SchedulePartnerError as the provided ForbiddenError
func (t *SchedulePartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the SchedulePartnerError, using the provided ForbiddenError
func (t *SchedulePartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the SchedulePartnerError as a InvalidRequestError
func (t SchedulePartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the SchedulePartnerError as the provided InvalidRequestError
func (t *SchedulePartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the SchedulePartnerError, using the provided InvalidRequestError
func (t *SchedulePartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationAlreadyUsedError returns the union data inside the SchedulePartnerError as a PlatformAccountVerificationAlreadyUsedError
func (t SchedulePartnerError) AsPlatformAccountVerificationAlreadyUsedError() (PlatformAccountVerificationAlreadyUsedError, error) {
	var body PlatformAccountVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationAlreadyUsedError overwrites any union data inside the SchedulePartnerError as the provided PlatformAccountVerificationAlreadyUsedError
func (t *SchedulePartnerError) FromPlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationAlreadyUsedError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformAccountVerificationAlreadyUsedError
func (t *SchedulePartnerError) MergePlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationFailedError returns the union data inside the SchedulePartnerError as a PlatformAccountVerificationFailedError
func (t SchedulePartnerError) AsPlatformAccountVerificationFailedError() (PlatformAccountVerificationFailedError, error) {
	var body PlatformAccountVerificationFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationFailedError overwrites any union data inside the SchedulePartnerError as the provided PlatformAccountVerificationFailedError
func (t *SchedulePartnerError) FromPlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationFailedError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformAccountVerificationFailedError
func (t *SchedulePartnerError) MergePlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationNotFoundError returns the union data inside the SchedulePartnerError as a PlatformAccountVerificationNotFoundError
func (t SchedulePartnerError) AsPlatformAccountVerificationNotFoundError() (PlatformAccountVerificationNotFoundError, error) {
	var body PlatformAccountVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationNotFoundError overwrites any union data inside the SchedulePartnerError as the provided PlatformAccountVerificationNotFoundError
func (t *SchedulePartnerError) FromPlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationNotFoundError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformAccountVerificationNotFoundError
func (t *SchedulePartnerError) MergePlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedPartnerError returns the union data inside the SchedulePartnerError as a PlatformArchivedPartnerError
func (t SchedulePartnerError) AsPlatformArchivedPartnerError() (PlatformArchivedPartnerError, error) {
	var body PlatformArchivedPartnerError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedPartnerError overwrites any union data inside the SchedulePartnerError as the provided PlatformArchivedPartnerError
func (t *SchedulePartnerError) FromPlatformArchivedPartnerError(v PlatformArchivedPartnerError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedPartnerError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformArchivedPartnerError
func (t *SchedulePartnerError) MergePlatformArchivedPartnerError(v PlatformArchivedPartnerError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCompanyVerificationAlreadyUsedError returns the union data inside the SchedulePartnerError as a PlatformCompanyVerificationAlreadyUsedError
func (t SchedulePartnerError) AsPlatformCompanyVerificationAlreadyUsedError() (PlatformCompanyVerificationAlreadyUsedError, error) {
	var body PlatformCompanyVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCompanyVerificationAlreadyUsedError overwrites any union data inside the SchedulePartnerError as the provided PlatformCompanyVerificationAlreadyUsedError
func (t *SchedulePartnerError) FromPlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCompanyVerificationAlreadyUsedError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformCompanyVerificationAlreadyUsedError
func (t *SchedulePartnerError) MergePlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the SchedulePartnerError as a PlatformContractNotFoundError
func (t SchedulePartnerError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the SchedulePartnerError as the provided PlatformContractNotFoundError
func (t *SchedulePartnerError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformContractNotFoundError
func (t *SchedulePartnerError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformInsufficientDataToChangePartnerTypeError returns the union data inside the SchedulePartnerError as a PlatformInsufficientDataToChangePartnerTypeError
func (t SchedulePartnerError) AsPlatformInsufficientDataToChangePartnerTypeError() (PlatformInsufficientDataToChangePartnerTypeError, error) {
	var body PlatformInsufficientDataToChangePartnerTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformInsufficientDataToChangePartnerTypeError overwrites any union data inside the SchedulePartnerError as the provided PlatformInsufficientDataToChangePartnerTypeError
func (t *SchedulePartnerError) FromPlatformInsufficientDataToChangePartnerTypeError(v PlatformInsufficientDataToChangePartnerTypeError) error {
	v.Type = "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformInsufficientDataToChangePartnerTypeError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformInsufficientDataToChangePartnerTypeError
func (t *SchedulePartnerError) MergePlatformInsufficientDataToChangePartnerTypeError(v PlatformInsufficientDataToChangePartnerTypeError) error {
	v.Type = "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError returns the union data inside the SchedulePartnerError as a PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t SchedulePartnerError) AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError() (PlatformMemberCompanyConnectedPartnerBrnUnchangeableError, error) {
	var body PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerBrnUnchangeableError overwrites any union data inside the SchedulePartnerError as the provided PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t *SchedulePartnerError) FromPlatformMemberCompanyConnectedPartnerBrnUnchangeableError(v PlatformMemberCompanyConnectedPartnerBrnUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerBrnUnchangeableError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t *SchedulePartnerError) MergePlatformMemberCompanyConnectedPartnerBrnUnchangeableError(v PlatformMemberCompanyConnectedPartnerBrnUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError returns the union data inside the SchedulePartnerError as a PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t SchedulePartnerError) AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError() (PlatformMemberCompanyConnectedPartnerCannotBeScheduledError, error) {
	var body PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerCannotBeScheduledError overwrites any union data inside the SchedulePartnerError as the provided PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t *SchedulePartnerError) FromPlatformMemberCompanyConnectedPartnerCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnerCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerCannotBeScheduledError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformMemberCompanyConnectedPartnerCannotBeScheduledError
func (t *SchedulePartnerError) MergePlatformMemberCompanyConnectedPartnerCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnerCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError returns the union data inside the SchedulePartnerError as a PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t SchedulePartnerError) AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError() (PlatformMemberCompanyConnectedPartnerTypeUnchangeableError, error) {
	var body PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerTypeUnchangeableError overwrites any union data inside the SchedulePartnerError as the provided PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t *SchedulePartnerError) FromPlatformMemberCompanyConnectedPartnerTypeUnchangeableError(v PlatformMemberCompanyConnectedPartnerTypeUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerTypeUnchangeableError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t *SchedulePartnerError) MergePlatformMemberCompanyConnectedPartnerTypeUnchangeableError(v PlatformMemberCompanyConnectedPartnerTypeUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the SchedulePartnerError as a PlatformNotEnabledError
func (t SchedulePartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the SchedulePartnerError as the provided PlatformNotEnabledError
func (t *SchedulePartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformNotEnabledError
func (t *SchedulePartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the SchedulePartnerError as a PlatformPartnerNotFoundError
func (t SchedulePartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the SchedulePartnerError as the provided PlatformPartnerNotFoundError
func (t *SchedulePartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformPartnerNotFoundError
func (t *SchedulePartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerScheduleAlreadyExistsError returns the union data inside the SchedulePartnerError as a PlatformPartnerScheduleAlreadyExistsError
func (t SchedulePartnerError) AsPlatformPartnerScheduleAlreadyExistsError() (PlatformPartnerScheduleAlreadyExistsError, error) {
	var body PlatformPartnerScheduleAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerScheduleAlreadyExistsError overwrites any union data inside the SchedulePartnerError as the provided PlatformPartnerScheduleAlreadyExistsError
func (t *SchedulePartnerError) FromPlatformPartnerScheduleAlreadyExistsError(v PlatformPartnerScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerScheduleAlreadyExistsError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformPartnerScheduleAlreadyExistsError
func (t *SchedulePartnerError) MergePlatformPartnerScheduleAlreadyExistsError(v PlatformPartnerScheduleAlreadyExistsError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULE_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the SchedulePartnerError as a PlatformUserDefinedPropertyNotFoundError
func (t SchedulePartnerError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the SchedulePartnerError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *SchedulePartnerError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the SchedulePartnerError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *SchedulePartnerError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the SchedulePartnerError as a UnauthorizedError
func (t SchedulePartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the SchedulePartnerError as the provided UnauthorizedError
func (t *SchedulePartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the SchedulePartnerError, using the provided UnauthorizedError
func (t *SchedulePartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchedulePartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchedulePartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED":
		return t.AsPlatformAccountVerificationAlreadyUsedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_FAILED":
		return t.AsPlatformAccountVerificationFailedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND":
		return t.AsPlatformAccountVerificationNotFoundError()
	case "PLATFORM_ARCHIVED_PARTNER":
		return t.AsPlatformArchivedPartnerError()
	case "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED":
		return t.AsPlatformCompanyVerificationAlreadyUsedError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE":
		return t.AsPlatformInsufficientDataToChangePartnerTypeError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE":
		return t.AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_CANNOT_BE_SCHEDULED":
		return t.AsPlatformMemberCompanyConnectedPartnerCannotBeScheduledError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE":
		return t.AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_PARTNER_SCHEDULE_ALREADY_EXISTS":
		return t.AsPlatformPartnerScheduleAlreadyExistsError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchedulePartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchedulePartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the SchedulePlatformPartnersError as a ForbiddenError
func (t SchedulePlatformPartnersError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the SchedulePlatformPartnersError as the provided ForbiddenError
func (t *SchedulePlatformPartnersError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided ForbiddenError
func (t *SchedulePlatformPartnersError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the SchedulePlatformPartnersError as a InvalidRequestError
func (t SchedulePlatformPartnersError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the SchedulePlatformPartnersError as the provided InvalidRequestError
func (t *SchedulePlatformPartnersError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided InvalidRequestError
func (t *SchedulePlatformPartnersError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedPartnersCannotBeScheduledError returns the union data inside the SchedulePlatformPartnersError as a PlatformArchivedPartnersCannotBeScheduledError
func (t SchedulePlatformPartnersError) AsPlatformArchivedPartnersCannotBeScheduledError() (PlatformArchivedPartnersCannotBeScheduledError, error) {
	var body PlatformArchivedPartnersCannotBeScheduledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedPartnersCannotBeScheduledError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformArchivedPartnersCannotBeScheduledError
func (t *SchedulePlatformPartnersError) FromPlatformArchivedPartnersCannotBeScheduledError(v PlatformArchivedPartnersCannotBeScheduledError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNERS_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedPartnersCannotBeScheduledError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformArchivedPartnersCannotBeScheduledError
func (t *SchedulePlatformPartnersError) MergePlatformArchivedPartnersCannotBeScheduledError(v PlatformArchivedPartnersCannotBeScheduledError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNERS_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the SchedulePlatformPartnersError as a PlatformContractNotFoundError
func (t SchedulePlatformPartnersError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformContractNotFoundError
func (t *SchedulePlatformPartnersError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformContractNotFoundError
func (t *SchedulePlatformPartnersError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnersCannotBeScheduledError returns the union data inside the SchedulePlatformPartnersError as a PlatformMemberCompanyConnectedPartnersCannotBeScheduledError
func (t SchedulePlatformPartnersError) AsPlatformMemberCompanyConnectedPartnersCannotBeScheduledError() (PlatformMemberCompanyConnectedPartnersCannotBeScheduledError, error) {
	var body PlatformMemberCompanyConnectedPartnersCannotBeScheduledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnersCannotBeScheduledError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformMemberCompanyConnectedPartnersCannotBeScheduledError
func (t *SchedulePlatformPartnersError) FromPlatformMemberCompanyConnectedPartnersCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnersCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNERS_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnersCannotBeScheduledError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformMemberCompanyConnectedPartnersCannotBeScheduledError
func (t *SchedulePlatformPartnersError) MergePlatformMemberCompanyConnectedPartnersCannotBeScheduledError(v PlatformMemberCompanyConnectedPartnersCannotBeScheduledError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNERS_CANNOT_BE_SCHEDULED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the SchedulePlatformPartnersError as a PlatformNotEnabledError
func (t SchedulePlatformPartnersError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformNotEnabledError
func (t *SchedulePlatformPartnersError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformNotEnabledError
func (t *SchedulePlatformPartnersError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerSchedulesAlreadyExistError returns the union data inside the SchedulePlatformPartnersError as a PlatformPartnerSchedulesAlreadyExistError
func (t SchedulePlatformPartnersError) AsPlatformPartnerSchedulesAlreadyExistError() (PlatformPartnerSchedulesAlreadyExistError, error) {
	var body PlatformPartnerSchedulesAlreadyExistError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerSchedulesAlreadyExistError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformPartnerSchedulesAlreadyExistError
func (t *SchedulePlatformPartnersError) FromPlatformPartnerSchedulesAlreadyExistError(v PlatformPartnerSchedulesAlreadyExistError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULES_ALREADY_EXIST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerSchedulesAlreadyExistError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformPartnerSchedulesAlreadyExistError
func (t *SchedulePlatformPartnersError) MergePlatformPartnerSchedulesAlreadyExistError(v PlatformPartnerSchedulesAlreadyExistError) error {
	v.Type = "PLATFORM_PARTNER_SCHEDULES_ALREADY_EXIST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the SchedulePlatformPartnersError as a PlatformUserDefinedPropertyNotFoundError
func (t SchedulePlatformPartnersError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the SchedulePlatformPartnersError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *SchedulePlatformPartnersError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *SchedulePlatformPartnersError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the SchedulePlatformPartnersError as a UnauthorizedError
func (t SchedulePlatformPartnersError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the SchedulePlatformPartnersError as the provided UnauthorizedError
func (t *SchedulePlatformPartnersError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the SchedulePlatformPartnersError, using the provided UnauthorizedError
func (t *SchedulePlatformPartnersError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchedulePlatformPartnersError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SchedulePlatformPartnersError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ARCHIVED_PARTNERS_CANNOT_BE_SCHEDULED":
		return t.AsPlatformArchivedPartnersCannotBeScheduledError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNERS_CANNOT_BE_SCHEDULED":
		return t.AsPlatformMemberCompanyConnectedPartnersCannotBeScheduledError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_SCHEDULES_ALREADY_EXIST":
		return t.AsPlatformPartnerSchedulesAlreadyExistError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SchedulePlatformPartnersError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchedulePlatformPartnersError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChannelNotFoundError returns the union data inside the SendIdentityVerificationError as a ChannelNotFoundError
func (t SendIdentityVerificationError) AsChannelNotFoundError() (ChannelNotFoundError, error) {
	var body ChannelNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChannelNotFoundError overwrites any union data inside the SendIdentityVerificationError as the provided ChannelNotFoundError
func (t *SendIdentityVerificationError) FromChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChannelNotFoundError performs a merge with any union data inside the SendIdentityVerificationError, using the provided ChannelNotFoundError
func (t *SendIdentityVerificationError) MergeChannelNotFoundError(v ChannelNotFoundError) error {
	v.Type = "CHANNEL_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the SendIdentityVerificationError as a ForbiddenError
func (t SendIdentityVerificationError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the SendIdentityVerificationError as the provided ForbiddenError
func (t *SendIdentityVerificationError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the SendIdentityVerificationError, using the provided ForbiddenError
func (t *SendIdentityVerificationError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationAlreadySentError returns the union data inside the SendIdentityVerificationError as a IdentityVerificationAlreadySentError
func (t SendIdentityVerificationError) AsIdentityVerificationAlreadySentError() (IdentityVerificationAlreadySentError, error) {
	var body IdentityVerificationAlreadySentError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationAlreadySentError overwrites any union data inside the SendIdentityVerificationError as the provided IdentityVerificationAlreadySentError
func (t *SendIdentityVerificationError) FromIdentityVerificationAlreadySentError(v IdentityVerificationAlreadySentError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_SENT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationAlreadySentError performs a merge with any union data inside the SendIdentityVerificationError, using the provided IdentityVerificationAlreadySentError
func (t *SendIdentityVerificationError) MergeIdentityVerificationAlreadySentError(v IdentityVerificationAlreadySentError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_SENT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationAlreadyVerifiedError returns the union data inside the SendIdentityVerificationError as a IdentityVerificationAlreadyVerifiedError
func (t SendIdentityVerificationError) AsIdentityVerificationAlreadyVerifiedError() (IdentityVerificationAlreadyVerifiedError, error) {
	var body IdentityVerificationAlreadyVerifiedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationAlreadyVerifiedError overwrites any union data inside the SendIdentityVerificationError as the provided IdentityVerificationAlreadyVerifiedError
func (t *SendIdentityVerificationError) FromIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationAlreadyVerifiedError performs a merge with any union data inside the SendIdentityVerificationError, using the provided IdentityVerificationAlreadyVerifiedError
func (t *SendIdentityVerificationError) MergeIdentityVerificationAlreadyVerifiedError(v IdentityVerificationAlreadyVerifiedError) error {
	v.Type = "IDENTITY_VERIFICATION_ALREADY_VERIFIED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIdentityVerificationNotFoundError returns the union data inside the SendIdentityVerificationError as a IdentityVerificationNotFoundError
func (t SendIdentityVerificationError) AsIdentityVerificationNotFoundError() (IdentityVerificationNotFoundError, error) {
	var body IdentityVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentityVerificationNotFoundError overwrites any union data inside the SendIdentityVerificationError as the provided IdentityVerificationNotFoundError
func (t *SendIdentityVerificationError) FromIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentityVerificationNotFoundError performs a merge with any union data inside the SendIdentityVerificationError, using the provided IdentityVerificationNotFoundError
func (t *SendIdentityVerificationError) MergeIdentityVerificationNotFoundError(v IdentityVerificationNotFoundError) error {
	v.Type = "IDENTITY_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the SendIdentityVerificationError as a InvalidRequestError
func (t SendIdentityVerificationError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the SendIdentityVerificationError as the provided InvalidRequestError
func (t *SendIdentityVerificationError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the SendIdentityVerificationError, using the provided InvalidRequestError
func (t *SendIdentityVerificationError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMaxTransactionCountReachedError returns the union data inside the SendIdentityVerificationError as a MaxTransactionCountReachedError
func (t SendIdentityVerificationError) AsMaxTransactionCountReachedError() (MaxTransactionCountReachedError, error) {
	var body MaxTransactionCountReachedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMaxTransactionCountReachedError overwrites any union data inside the SendIdentityVerificationError as the provided MaxTransactionCountReachedError
func (t *SendIdentityVerificationError) FromMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMaxTransactionCountReachedError performs a merge with any union data inside the SendIdentityVerificationError, using the provided MaxTransactionCountReachedError
func (t *SendIdentityVerificationError) MergeMaxTransactionCountReachedError(v MaxTransactionCountReachedError) error {
	v.Type = "MAX_TRANSACTION_COUNT_REACHED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPgProviderError returns the union data inside the SendIdentityVerificationError as a PgProviderError
func (t SendIdentityVerificationError) AsPgProviderError() (PgProviderError, error) {
	var body PgProviderError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPgProviderError overwrites any union data inside the SendIdentityVerificationError as the provided PgProviderError
func (t *SendIdentityVerificationError) FromPgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePgProviderError performs a merge with any union data inside the SendIdentityVerificationError, using the provided PgProviderError
func (t *SendIdentityVerificationError) MergePgProviderError(v PgProviderError) error {
	v.Type = "PG_PROVIDER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the SendIdentityVerificationError as a UnauthorizedError
func (t SendIdentityVerificationError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the SendIdentityVerificationError as the provided UnauthorizedError
func (t *SendIdentityVerificationError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the SendIdentityVerificationError, using the provided UnauthorizedError
func (t *SendIdentityVerificationError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendIdentityVerificationError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SendIdentityVerificationError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHANNEL_NOT_FOUND":
		return t.AsChannelNotFoundError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "IDENTITY_VERIFICATION_ALREADY_SENT":
		return t.AsIdentityVerificationAlreadySentError()
	case "IDENTITY_VERIFICATION_ALREADY_VERIFIED":
		return t.AsIdentityVerificationAlreadyVerifiedError()
	case "IDENTITY_VERIFICATION_NOT_FOUND":
		return t.AsIdentityVerificationNotFoundError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "MAX_TRANSACTION_COUNT_REACHED":
		return t.AsMaxTransactionCountReachedError()
	case "PG_PROVIDER":
		return t.AsPgProviderError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SendIdentityVerificationError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendIdentityVerificationError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2bExternalServiceError returns the union data inside the SendToNtsB2bTaxInvoiceError as a B2bExternalServiceError
func (t SendToNtsB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *SendToNtsB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *SendToNtsB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the SendToNtsB2bTaxInvoiceError as a B2bNotEnabledError
func (t SendToNtsB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *SendToNtsB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *SendToNtsB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the SendToNtsB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t SendToNtsB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *SendToNtsB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *SendToNtsB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotIssuedStatusError returns the union data inside the SendToNtsB2bTaxInvoiceError as a B2bTaxInvoiceNotIssuedStatusError
func (t SendToNtsB2bTaxInvoiceError) AsB2bTaxInvoiceNotIssuedStatusError() (B2bTaxInvoiceNotIssuedStatusError, error) {
	var body B2bTaxInvoiceNotIssuedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotIssuedStatusError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided B2bTaxInvoiceNotIssuedStatusError
func (t *SendToNtsB2bTaxInvoiceError) FromB2bTaxInvoiceNotIssuedStatusError(v B2bTaxInvoiceNotIssuedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_ISSUED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotIssuedStatusError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotIssuedStatusError
func (t *SendToNtsB2bTaxInvoiceError) MergeB2bTaxInvoiceNotIssuedStatusError(v B2bTaxInvoiceNotIssuedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_ISSUED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the SendToNtsB2bTaxInvoiceError as a ForbiddenError
func (t SendToNtsB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided ForbiddenError
func (t *SendToNtsB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided ForbiddenError
func (t *SendToNtsB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the SendToNtsB2bTaxInvoiceError as a InvalidRequestError
func (t SendToNtsB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided InvalidRequestError
func (t *SendToNtsB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *SendToNtsB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the SendToNtsB2bTaxInvoiceError as a UnauthorizedError
func (t SendToNtsB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the SendToNtsB2bTaxInvoiceError as the provided UnauthorizedError
func (t *SendToNtsB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the SendToNtsB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *SendToNtsB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SendToNtsB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SendToNtsB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_ISSUED_STATUS":
		return t.AsB2bTaxInvoiceNotIssuedStatusError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SendToNtsB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SendToNtsB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2BCannotChangeTaxTypeError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2BCannotChangeTaxTypeError
func (t UpdateB2bTaxInvoiceDraftError) AsB2BCannotChangeTaxTypeError() (B2BCannotChangeTaxTypeError, error) {
	var body B2BCannotChangeTaxTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BCannotChangeTaxTypeError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2BCannotChangeTaxTypeError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BCannotChangeTaxTypeError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2BCannotChangeTaxTypeError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2BTaxInvoiceStatusNotSendingCompletedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2BTaxInvoiceStatusNotSendingCompletedError
func (t UpdateB2bTaxInvoiceDraftError) AsB2BTaxInvoiceStatusNotSendingCompletedError() (B2BTaxInvoiceStatusNotSendingCompletedError, error) {
	var body B2BTaxInvoiceStatusNotSendingCompletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BTaxInvoiceStatusNotSendingCompletedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BTaxInvoiceStatusNotSendingCompletedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bDocumentKeyCannotBeChangedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bDocumentKeyCannotBeChangedError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bDocumentKeyCannotBeChangedError() (B2bDocumentKeyCannotBeChangedError, error) {
	var body B2bDocumentKeyCannotBeChangedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bDocumentKeyCannotBeChangedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bDocumentKeyCannotBeChangedError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bDocumentKeyCannotBeChangedError(v B2bDocumentKeyCannotBeChangedError) error {
	v.Type = "B2B_DOCUMENT_KEY_CANNOT_BE_CHANGED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bDocumentKeyCannotBeChangedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bDocumentKeyCannotBeChangedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bDocumentKeyCannotBeChangedError(v B2bDocumentKeyCannotBeChangedError) error {
	v.Type = "B2B_DOCUMENT_KEY_CANNOT_BE_CHANGED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bExternalServiceError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bExternalServiceError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bExternalServiceError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIdAlreadyExistsError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bIdAlreadyExistsError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bIdAlreadyExistsError() (B2bIdAlreadyExistsError, error) {
	var body B2bIdAlreadyExistsError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIdAlreadyExistsError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bIdAlreadyExistsError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIdAlreadyExistsError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bIdAlreadyExistsError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bIdAlreadyExistsError(v B2bIdAlreadyExistsError) error {
	v.Type = "B2B_ID_ALREADY_EXISTS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIssuanceTypeMismatchError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bIssuanceTypeMismatchError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bIssuanceTypeMismatchError() (B2bIssuanceTypeMismatchError, error) {
	var body B2bIssuanceTypeMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIssuanceTypeMismatchError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bIssuanceTypeMismatchError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIssuanceTypeMismatchError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bIssuanceTypeMismatchError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bModificationNotProvidedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bModificationNotProvidedError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bModificationNotProvidedError() (B2bModificationNotProvidedError, error) {
	var body B2bModificationNotProvidedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bModificationNotProvidedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bModificationNotProvidedError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bModificationNotProvidedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bModificationNotProvidedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bNotEnabledError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bNotEnabledError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bNotEnabledError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bOriginalTaxInvoiceNotFoundError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bOriginalTaxInvoiceNotFoundError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bOriginalTaxInvoiceNotFoundError() (B2bOriginalTaxInvoiceNotFoundError, error) {
	var body B2bOriginalTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bOriginalTaxInvoiceNotFoundError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bOriginalTaxInvoiceNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bOriginalTaxInvoiceNotFoundError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bOriginalTaxInvoiceNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bRecipientNotFoundError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bRecipientNotFoundError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bRecipientNotFoundError() (B2bRecipientNotFoundError, error) {
	var body B2bRecipientNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bRecipientNotFoundError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bRecipientNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bRecipientNotFoundError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bRecipientNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bRecipientNotFoundError(v B2bRecipientNotFoundError) error {
	v.Type = "B2B_RECIPIENT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bSupplierNotFoundError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bSupplierNotFoundError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bSupplierNotFoundError() (B2bSupplierNotFoundError, error) {
	var body B2bSupplierNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bSupplierNotFoundError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bSupplierNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bSupplierNotFoundError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bSupplierNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bSupplierNotFoundError(v B2bSupplierNotFoundError) error {
	v.Type = "B2B_SUPPLIER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotDraftedStatusError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bTaxInvoiceNotDraftedStatusError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bTaxInvoiceNotDraftedStatusError() (B2bTaxInvoiceNotDraftedStatusError, error) {
	var body B2bTaxInvoiceNotDraftedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotDraftedStatusError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bTaxInvoiceNotDraftedStatusError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotDraftedStatusError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bTaxInvoiceNotDraftedStatusError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bTaxInvoiceNotFoundError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bTaxInvoiceNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bTaxInvoiceNotFoundError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError() (B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError(v B2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t UpdateB2bTaxInvoiceDraftError) AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError() (B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError, error) {
	var body B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *UpdateB2bTaxInvoiceDraftError) FromB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError(v B2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError) error {
	v.Type = "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a ForbiddenError
func (t UpdateB2bTaxInvoiceDraftError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided ForbiddenError
func (t *UpdateB2bTaxInvoiceDraftError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided ForbiddenError
func (t *UpdateB2bTaxInvoiceDraftError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a InvalidRequestError
func (t UpdateB2bTaxInvoiceDraftError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided InvalidRequestError
func (t *UpdateB2bTaxInvoiceDraftError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided InvalidRequestError
func (t *UpdateB2bTaxInvoiceDraftError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdateB2bTaxInvoiceDraftError as a UnauthorizedError
func (t UpdateB2bTaxInvoiceDraftError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdateB2bTaxInvoiceDraftError as the provided UnauthorizedError
func (t *UpdateB2bTaxInvoiceDraftError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdateB2bTaxInvoiceDraftError, using the provided UnauthorizedError
func (t *UpdateB2bTaxInvoiceDraftError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateB2bTaxInvoiceDraftError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateB2bTaxInvoiceDraftError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_CANNOT_CHANGE_TAX_TYPE":
		return t.AsB2BCannotChangeTaxTypeError()
	case "B2B_DOCUMENT_KEY_CANNOT_BE_CHANGED":
		return t.AsB2bDocumentKeyCannotBeChangedError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_ID_ALREADY_EXISTS":
		return t.AsB2bIdAlreadyExistsError()
	case "B2B_ISSUANCE_TYPE_MISMATCH":
		return t.AsB2bIssuanceTypeMismatchError()
	case "B2B_MODIFICATION_NOT_PROVIDED":
		return t.AsB2bModificationNotProvidedError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bOriginalTaxInvoiceNotFoundError()
	case "B2B_RECIPIENT_NOT_FOUND":
		return t.AsB2bRecipientNotFoundError()
	case "B2B_SUPPLIER_NOT_FOUND":
		return t.AsB2bSupplierNotFoundError()
	case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
		return t.AsB2bTaxInvoiceNotDraftedStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_RECIPIENT_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceRecipientDocumentKeyAlreadyUsedError()
	case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
		return t.AsB2BTaxInvoiceStatusNotSendingCompletedError()
	case "B2B_TAX_INVOICE_SUPPLIER_DOCUMENT_KEY_ALREADY_USED":
		return t.AsB2bTaxInvoiceSupplierDocumentKeyAlreadyUsedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateB2bTaxInvoiceDraftError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateB2bTaxInvoiceDraftError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a ForbiddenError
func (t UpdatePlatformAdditionalFeePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided ForbiddenError
func (t *UpdatePlatformAdditionalFeePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided ForbiddenError
func (t *UpdatePlatformAdditionalFeePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a InvalidRequestError
func (t UpdatePlatformAdditionalFeePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided InvalidRequestError
func (t *UpdatePlatformAdditionalFeePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided InvalidRequestError
func (t *UpdatePlatformAdditionalFeePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAdditionalFeePolicyNotFoundError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a PlatformAdditionalFeePolicyNotFoundError
func (t UpdatePlatformAdditionalFeePolicyError) AsPlatformAdditionalFeePolicyNotFoundError() (PlatformAdditionalFeePolicyNotFoundError, error) {
	var body PlatformAdditionalFeePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAdditionalFeePolicyNotFoundError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided PlatformAdditionalFeePolicyNotFoundError
func (t *UpdatePlatformAdditionalFeePolicyError) FromPlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAdditionalFeePolicyNotFoundError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided PlatformAdditionalFeePolicyNotFoundError
func (t *UpdatePlatformAdditionalFeePolicyError) MergePlatformAdditionalFeePolicyNotFoundError(v PlatformAdditionalFeePolicyNotFoundError) error {
	v.Type = "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedAdditionalFeePolicyError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a PlatformArchivedAdditionalFeePolicyError
func (t UpdatePlatformAdditionalFeePolicyError) AsPlatformArchivedAdditionalFeePolicyError() (PlatformArchivedAdditionalFeePolicyError, error) {
	var body PlatformArchivedAdditionalFeePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedAdditionalFeePolicyError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided PlatformArchivedAdditionalFeePolicyError
func (t *UpdatePlatformAdditionalFeePolicyError) FromPlatformArchivedAdditionalFeePolicyError(v PlatformArchivedAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedAdditionalFeePolicyError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided PlatformArchivedAdditionalFeePolicyError
func (t *UpdatePlatformAdditionalFeePolicyError) MergePlatformArchivedAdditionalFeePolicyError(v PlatformArchivedAdditionalFeePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a PlatformNotEnabledError
func (t UpdatePlatformAdditionalFeePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided PlatformNotEnabledError
func (t *UpdatePlatformAdditionalFeePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided PlatformNotEnabledError
func (t *UpdatePlatformAdditionalFeePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdatePlatformAdditionalFeePolicyError as a UnauthorizedError
func (t UpdatePlatformAdditionalFeePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdatePlatformAdditionalFeePolicyError as the provided UnauthorizedError
func (t *UpdatePlatformAdditionalFeePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdatePlatformAdditionalFeePolicyError, using the provided UnauthorizedError
func (t *UpdatePlatformAdditionalFeePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePlatformAdditionalFeePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdatePlatformAdditionalFeePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ADDITIONAL_FEE_POLICY_NOT_FOUND":
		return t.AsPlatformAdditionalFeePolicyNotFoundError()
	case "PLATFORM_ARCHIVED_ADDITIONAL_FEE_POLICY":
		return t.AsPlatformArchivedAdditionalFeePolicyError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdatePlatformAdditionalFeePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePlatformAdditionalFeePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the UpdatePlatformContractError as a ForbiddenError
func (t UpdatePlatformContractError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdatePlatformContractError as the provided ForbiddenError
func (t *UpdatePlatformContractError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdatePlatformContractError, using the provided ForbiddenError
func (t *UpdatePlatformContractError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdatePlatformContractError as a InvalidRequestError
func (t UpdatePlatformContractError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdatePlatformContractError as the provided InvalidRequestError
func (t *UpdatePlatformContractError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdatePlatformContractError, using the provided InvalidRequestError
func (t *UpdatePlatformContractError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedContractError returns the union data inside the UpdatePlatformContractError as a PlatformArchivedContractError
func (t UpdatePlatformContractError) AsPlatformArchivedContractError() (PlatformArchivedContractError, error) {
	var body PlatformArchivedContractError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedContractError overwrites any union data inside the UpdatePlatformContractError as the provided PlatformArchivedContractError
func (t *UpdatePlatformContractError) FromPlatformArchivedContractError(v PlatformArchivedContractError) error {
	v.Type = "PLATFORM_ARCHIVED_CONTRACT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedContractError performs a merge with any union data inside the UpdatePlatformContractError, using the provided PlatformArchivedContractError
func (t *UpdatePlatformContractError) MergePlatformArchivedContractError(v PlatformArchivedContractError) error {
	v.Type = "PLATFORM_ARCHIVED_CONTRACT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the UpdatePlatformContractError as a PlatformContractNotFoundError
func (t UpdatePlatformContractError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the UpdatePlatformContractError as the provided PlatformContractNotFoundError
func (t *UpdatePlatformContractError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the UpdatePlatformContractError, using the provided PlatformContractNotFoundError
func (t *UpdatePlatformContractError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the UpdatePlatformContractError as a PlatformNotEnabledError
func (t UpdatePlatformContractError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the UpdatePlatformContractError as the provided PlatformNotEnabledError
func (t *UpdatePlatformContractError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the UpdatePlatformContractError, using the provided PlatformNotEnabledError
func (t *UpdatePlatformContractError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdatePlatformContractError as a UnauthorizedError
func (t UpdatePlatformContractError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdatePlatformContractError as the provided UnauthorizedError
func (t *UpdatePlatformContractError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdatePlatformContractError, using the provided UnauthorizedError
func (t *UpdatePlatformContractError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePlatformContractError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdatePlatformContractError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ARCHIVED_CONTRACT":
		return t.AsPlatformArchivedContractError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdatePlatformContractError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePlatformContractError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a ForbiddenError
func (t UpdatePlatformDiscountSharePolicyError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided ForbiddenError
func (t *UpdatePlatformDiscountSharePolicyError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided ForbiddenError
func (t *UpdatePlatformDiscountSharePolicyError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a InvalidRequestError
func (t UpdatePlatformDiscountSharePolicyError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided InvalidRequestError
func (t *UpdatePlatformDiscountSharePolicyError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided InvalidRequestError
func (t *UpdatePlatformDiscountSharePolicyError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedDiscountSharePolicyError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a PlatformArchivedDiscountSharePolicyError
func (t UpdatePlatformDiscountSharePolicyError) AsPlatformArchivedDiscountSharePolicyError() (PlatformArchivedDiscountSharePolicyError, error) {
	var body PlatformArchivedDiscountSharePolicyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedDiscountSharePolicyError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided PlatformArchivedDiscountSharePolicyError
func (t *UpdatePlatformDiscountSharePolicyError) FromPlatformArchivedDiscountSharePolicyError(v PlatformArchivedDiscountSharePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedDiscountSharePolicyError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided PlatformArchivedDiscountSharePolicyError
func (t *UpdatePlatformDiscountSharePolicyError) MergePlatformArchivedDiscountSharePolicyError(v PlatformArchivedDiscountSharePolicyError) error {
	v.Type = "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformDiscountSharePolicyNotFoundError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a PlatformDiscountSharePolicyNotFoundError
func (t UpdatePlatformDiscountSharePolicyError) AsPlatformDiscountSharePolicyNotFoundError() (PlatformDiscountSharePolicyNotFoundError, error) {
	var body PlatformDiscountSharePolicyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformDiscountSharePolicyNotFoundError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided PlatformDiscountSharePolicyNotFoundError
func (t *UpdatePlatformDiscountSharePolicyError) FromPlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformDiscountSharePolicyNotFoundError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided PlatformDiscountSharePolicyNotFoundError
func (t *UpdatePlatformDiscountSharePolicyError) MergePlatformDiscountSharePolicyNotFoundError(v PlatformDiscountSharePolicyNotFoundError) error {
	v.Type = "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a PlatformNotEnabledError
func (t UpdatePlatformDiscountSharePolicyError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided PlatformNotEnabledError
func (t *UpdatePlatformDiscountSharePolicyError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided PlatformNotEnabledError
func (t *UpdatePlatformDiscountSharePolicyError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdatePlatformDiscountSharePolicyError as a UnauthorizedError
func (t UpdatePlatformDiscountSharePolicyError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdatePlatformDiscountSharePolicyError as the provided UnauthorizedError
func (t *UpdatePlatformDiscountSharePolicyError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdatePlatformDiscountSharePolicyError, using the provided UnauthorizedError
func (t *UpdatePlatformDiscountSharePolicyError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePlatformDiscountSharePolicyError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdatePlatformDiscountSharePolicyError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ARCHIVED_DISCOUNT_SHARE_POLICY":
		return t.AsPlatformArchivedDiscountSharePolicyError()
	case "PLATFORM_DISCOUNT_SHARE_POLICY_NOT_FOUND":
		return t.AsPlatformDiscountSharePolicyNotFoundError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdatePlatformDiscountSharePolicyError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePlatformDiscountSharePolicyError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the UpdatePlatformPartnerError as a ForbiddenError
func (t UpdatePlatformPartnerError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdatePlatformPartnerError as the provided ForbiddenError
func (t *UpdatePlatformPartnerError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided ForbiddenError
func (t *UpdatePlatformPartnerError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdatePlatformPartnerError as a InvalidRequestError
func (t UpdatePlatformPartnerError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdatePlatformPartnerError as the provided InvalidRequestError
func (t *UpdatePlatformPartnerError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided InvalidRequestError
func (t *UpdatePlatformPartnerError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationAlreadyUsedError returns the union data inside the UpdatePlatformPartnerError as a PlatformAccountVerificationAlreadyUsedError
func (t UpdatePlatformPartnerError) AsPlatformAccountVerificationAlreadyUsedError() (PlatformAccountVerificationAlreadyUsedError, error) {
	var body PlatformAccountVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationAlreadyUsedError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformAccountVerificationAlreadyUsedError
func (t *UpdatePlatformPartnerError) FromPlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationAlreadyUsedError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformAccountVerificationAlreadyUsedError
func (t *UpdatePlatformPartnerError) MergePlatformAccountVerificationAlreadyUsedError(v PlatformAccountVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationFailedError returns the union data inside the UpdatePlatformPartnerError as a PlatformAccountVerificationFailedError
func (t UpdatePlatformPartnerError) AsPlatformAccountVerificationFailedError() (PlatformAccountVerificationFailedError, error) {
	var body PlatformAccountVerificationFailedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationFailedError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformAccountVerificationFailedError
func (t *UpdatePlatformPartnerError) FromPlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationFailedError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformAccountVerificationFailedError
func (t *UpdatePlatformPartnerError) MergePlatformAccountVerificationFailedError(v PlatformAccountVerificationFailedError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_FAILED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformAccountVerificationNotFoundError returns the union data inside the UpdatePlatformPartnerError as a PlatformAccountVerificationNotFoundError
func (t UpdatePlatformPartnerError) AsPlatformAccountVerificationNotFoundError() (PlatformAccountVerificationNotFoundError, error) {
	var body PlatformAccountVerificationNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformAccountVerificationNotFoundError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformAccountVerificationNotFoundError
func (t *UpdatePlatformPartnerError) FromPlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformAccountVerificationNotFoundError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformAccountVerificationNotFoundError
func (t *UpdatePlatformPartnerError) MergePlatformAccountVerificationNotFoundError(v PlatformAccountVerificationNotFoundError) error {
	v.Type = "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformArchivedPartnerError returns the union data inside the UpdatePlatformPartnerError as a PlatformArchivedPartnerError
func (t UpdatePlatformPartnerError) AsPlatformArchivedPartnerError() (PlatformArchivedPartnerError, error) {
	var body PlatformArchivedPartnerError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformArchivedPartnerError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformArchivedPartnerError
func (t *UpdatePlatformPartnerError) FromPlatformArchivedPartnerError(v PlatformArchivedPartnerError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformArchivedPartnerError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformArchivedPartnerError
func (t *UpdatePlatformPartnerError) MergePlatformArchivedPartnerError(v PlatformArchivedPartnerError) error {
	v.Type = "PLATFORM_ARCHIVED_PARTNER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformCompanyVerificationAlreadyUsedError returns the union data inside the UpdatePlatformPartnerError as a PlatformCompanyVerificationAlreadyUsedError
func (t UpdatePlatformPartnerError) AsPlatformCompanyVerificationAlreadyUsedError() (PlatformCompanyVerificationAlreadyUsedError, error) {
	var body PlatformCompanyVerificationAlreadyUsedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformCompanyVerificationAlreadyUsedError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformCompanyVerificationAlreadyUsedError
func (t *UpdatePlatformPartnerError) FromPlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformCompanyVerificationAlreadyUsedError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformCompanyVerificationAlreadyUsedError
func (t *UpdatePlatformPartnerError) MergePlatformCompanyVerificationAlreadyUsedError(v PlatformCompanyVerificationAlreadyUsedError) error {
	v.Type = "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformContractNotFoundError returns the union data inside the UpdatePlatformPartnerError as a PlatformContractNotFoundError
func (t UpdatePlatformPartnerError) AsPlatformContractNotFoundError() (PlatformContractNotFoundError, error) {
	var body PlatformContractNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformContractNotFoundError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformContractNotFoundError
func (t *UpdatePlatformPartnerError) FromPlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformContractNotFoundError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformContractNotFoundError
func (t *UpdatePlatformPartnerError) MergePlatformContractNotFoundError(v PlatformContractNotFoundError) error {
	v.Type = "PLATFORM_CONTRACT_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformInsufficientDataToChangePartnerTypeError returns the union data inside the UpdatePlatformPartnerError as a PlatformInsufficientDataToChangePartnerTypeError
func (t UpdatePlatformPartnerError) AsPlatformInsufficientDataToChangePartnerTypeError() (PlatformInsufficientDataToChangePartnerTypeError, error) {
	var body PlatformInsufficientDataToChangePartnerTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformInsufficientDataToChangePartnerTypeError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformInsufficientDataToChangePartnerTypeError
func (t *UpdatePlatformPartnerError) FromPlatformInsufficientDataToChangePartnerTypeError(v PlatformInsufficientDataToChangePartnerTypeError) error {
	v.Type = "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformInsufficientDataToChangePartnerTypeError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformInsufficientDataToChangePartnerTypeError
func (t *UpdatePlatformPartnerError) MergePlatformInsufficientDataToChangePartnerTypeError(v PlatformInsufficientDataToChangePartnerTypeError) error {
	v.Type = "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError returns the union data inside the UpdatePlatformPartnerError as a PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t UpdatePlatformPartnerError) AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError() (PlatformMemberCompanyConnectedPartnerBrnUnchangeableError, error) {
	var body PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerBrnUnchangeableError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t *UpdatePlatformPartnerError) FromPlatformMemberCompanyConnectedPartnerBrnUnchangeableError(v PlatformMemberCompanyConnectedPartnerBrnUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerBrnUnchangeableError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformMemberCompanyConnectedPartnerBrnUnchangeableError
func (t *UpdatePlatformPartnerError) MergePlatformMemberCompanyConnectedPartnerBrnUnchangeableError(v PlatformMemberCompanyConnectedPartnerBrnUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError returns the union data inside the UpdatePlatformPartnerError as a PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t UpdatePlatformPartnerError) AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError() (PlatformMemberCompanyConnectedPartnerTypeUnchangeableError, error) {
	var body PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformMemberCompanyConnectedPartnerTypeUnchangeableError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t *UpdatePlatformPartnerError) FromPlatformMemberCompanyConnectedPartnerTypeUnchangeableError(v PlatformMemberCompanyConnectedPartnerTypeUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformMemberCompanyConnectedPartnerTypeUnchangeableError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformMemberCompanyConnectedPartnerTypeUnchangeableError
func (t *UpdatePlatformPartnerError) MergePlatformMemberCompanyConnectedPartnerTypeUnchangeableError(v PlatformMemberCompanyConnectedPartnerTypeUnchangeableError) error {
	v.Type = "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the UpdatePlatformPartnerError as a PlatformNotEnabledError
func (t UpdatePlatformPartnerError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformNotEnabledError
func (t *UpdatePlatformPartnerError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformNotEnabledError
func (t *UpdatePlatformPartnerError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformPartnerNotFoundError returns the union data inside the UpdatePlatformPartnerError as a PlatformPartnerNotFoundError
func (t UpdatePlatformPartnerError) AsPlatformPartnerNotFoundError() (PlatformPartnerNotFoundError, error) {
	var body PlatformPartnerNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformPartnerNotFoundError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformPartnerNotFoundError
func (t *UpdatePlatformPartnerError) FromPlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformPartnerNotFoundError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformPartnerNotFoundError
func (t *UpdatePlatformPartnerError) MergePlatformPartnerNotFoundError(v PlatformPartnerNotFoundError) error {
	v.Type = "PLATFORM_PARTNER_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformUserDefinedPropertyNotFoundError returns the union data inside the UpdatePlatformPartnerError as a PlatformUserDefinedPropertyNotFoundError
func (t UpdatePlatformPartnerError) AsPlatformUserDefinedPropertyNotFoundError() (PlatformUserDefinedPropertyNotFoundError, error) {
	var body PlatformUserDefinedPropertyNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformUserDefinedPropertyNotFoundError overwrites any union data inside the UpdatePlatformPartnerError as the provided PlatformUserDefinedPropertyNotFoundError
func (t *UpdatePlatformPartnerError) FromPlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformUserDefinedPropertyNotFoundError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided PlatformUserDefinedPropertyNotFoundError
func (t *UpdatePlatformPartnerError) MergePlatformUserDefinedPropertyNotFoundError(v PlatformUserDefinedPropertyNotFoundError) error {
	v.Type = "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdatePlatformPartnerError as a UnauthorizedError
func (t UpdatePlatformPartnerError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdatePlatformPartnerError as the provided UnauthorizedError
func (t *UpdatePlatformPartnerError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdatePlatformPartnerError, using the provided UnauthorizedError
func (t *UpdatePlatformPartnerError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePlatformPartnerError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdatePlatformPartnerError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_ACCOUNT_VERIFICATION_ALREADY_USED":
		return t.AsPlatformAccountVerificationAlreadyUsedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_FAILED":
		return t.AsPlatformAccountVerificationFailedError()
	case "PLATFORM_ACCOUNT_VERIFICATION_NOT_FOUND":
		return t.AsPlatformAccountVerificationNotFoundError()
	case "PLATFORM_ARCHIVED_PARTNER":
		return t.AsPlatformArchivedPartnerError()
	case "PLATFORM_COMPANY_VERIFICATION_ALREADY_USED":
		return t.AsPlatformCompanyVerificationAlreadyUsedError()
	case "PLATFORM_CONTRACT_NOT_FOUND":
		return t.AsPlatformContractNotFoundError()
	case "PLATFORM_INSUFFICIENT_DATA_TO_CHANGE_PARTNER_TYPE":
		return t.AsPlatformInsufficientDataToChangePartnerTypeError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_BRN_UNCHANGEABLE":
		return t.AsPlatformMemberCompanyConnectedPartnerBrnUnchangeableError()
	case "PLATFORM_MEMBER_COMPANY_CONNECTED_PARTNER_TYPE_UNCHANGEABLE":
		return t.AsPlatformMemberCompanyConnectedPartnerTypeUnchangeableError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "PLATFORM_PARTNER_NOT_FOUND":
		return t.AsPlatformPartnerNotFoundError()
	case "PLATFORM_USER_DEFINED_PROPERTY_NOT_FOUND":
		return t.AsPlatformUserDefinedPropertyNotFoundError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdatePlatformPartnerError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePlatformPartnerError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForbiddenError returns the union data inside the UpdatePlatformSettingError as a ForbiddenError
func (t UpdatePlatformSettingError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the UpdatePlatformSettingError as the provided ForbiddenError
func (t *UpdatePlatformSettingError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the UpdatePlatformSettingError, using the provided ForbiddenError
func (t *UpdatePlatformSettingError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the UpdatePlatformSettingError as a InvalidRequestError
func (t UpdatePlatformSettingError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the UpdatePlatformSettingError as the provided InvalidRequestError
func (t *UpdatePlatformSettingError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the UpdatePlatformSettingError, using the provided InvalidRequestError
func (t *UpdatePlatformSettingError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlatformNotEnabledError returns the union data inside the UpdatePlatformSettingError as a PlatformNotEnabledError
func (t UpdatePlatformSettingError) AsPlatformNotEnabledError() (PlatformNotEnabledError, error) {
	var body PlatformNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlatformNotEnabledError overwrites any union data inside the UpdatePlatformSettingError as the provided PlatformNotEnabledError
func (t *UpdatePlatformSettingError) FromPlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlatformNotEnabledError performs a merge with any union data inside the UpdatePlatformSettingError, using the provided PlatformNotEnabledError
func (t *UpdatePlatformSettingError) MergePlatformNotEnabledError(v PlatformNotEnabledError) error {
	v.Type = "PLATFORM_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the UpdatePlatformSettingError as a UnauthorizedError
func (t UpdatePlatformSettingError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the UpdatePlatformSettingError as the provided UnauthorizedError
func (t *UpdatePlatformSettingError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the UpdatePlatformSettingError, using the provided UnauthorizedError
func (t *UpdatePlatformSettingError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePlatformSettingError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdatePlatformSettingError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "PLATFORM_NOT_ENABLED":
		return t.AsPlatformNotEnabledError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdatePlatformSettingError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePlatformSettingError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsB2BCannotChangeTaxTypeError returns the union data inside the RequestB2bTaxInvoiceError as a B2BCannotChangeTaxTypeError
func (t RequestB2bTaxInvoiceError) AsB2BCannotChangeTaxTypeError() (B2BCannotChangeTaxTypeError, error) {
	var body B2BCannotChangeTaxTypeError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BCannotChangeTaxTypeError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2BCannotChangeTaxTypeError
func (t *RequestB2bTaxInvoiceError) FromB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BCannotChangeTaxTypeError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2BCannotChangeTaxTypeError
func (t *RequestB2bTaxInvoiceError) MergeB2BCannotChangeTaxTypeError(v B2BCannotChangeTaxTypeError) error {
	v.Type = "B2B_CANNOT_CHANGE_TAX_TYPE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2BTaxInvoiceStatusNotSendingCompletedError returns the union data inside the RequestB2bTaxInvoiceError as a B2BTaxInvoiceStatusNotSendingCompletedError
func (t RequestB2bTaxInvoiceError) AsB2BTaxInvoiceStatusNotSendingCompletedError() (B2BTaxInvoiceStatusNotSendingCompletedError, error) {
	var body B2BTaxInvoiceStatusNotSendingCompletedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2BTaxInvoiceStatusNotSendingCompletedError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *RequestB2bTaxInvoiceError) FromB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2BTaxInvoiceStatusNotSendingCompletedError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2BTaxInvoiceStatusNotSendingCompletedError
func (t *RequestB2bTaxInvoiceError) MergeB2BTaxInvoiceStatusNotSendingCompletedError(v B2BTaxInvoiceStatusNotSendingCompletedError) error {
	v.Type = "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bExternalServiceError returns the union data inside the RequestB2bTaxInvoiceError as a B2bExternalServiceError
func (t RequestB2bTaxInvoiceError) AsB2bExternalServiceError() (B2bExternalServiceError, error) {
	var body B2bExternalServiceError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bExternalServiceError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bExternalServiceError
func (t *RequestB2bTaxInvoiceError) FromB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bExternalServiceError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bExternalServiceError
func (t *RequestB2bTaxInvoiceError) MergeB2bExternalServiceError(v B2bExternalServiceError) error {
	v.Type = "B2B_EXTERNAL_SERVICE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bIssuanceTypeMismatchError returns the union data inside the RequestB2bTaxInvoiceError as a B2bIssuanceTypeMismatchError
func (t RequestB2bTaxInvoiceError) AsB2bIssuanceTypeMismatchError() (B2bIssuanceTypeMismatchError, error) {
	var body B2bIssuanceTypeMismatchError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bIssuanceTypeMismatchError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bIssuanceTypeMismatchError
func (t *RequestB2bTaxInvoiceError) FromB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bIssuanceTypeMismatchError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bIssuanceTypeMismatchError
func (t *RequestB2bTaxInvoiceError) MergeB2bIssuanceTypeMismatchError(v B2bIssuanceTypeMismatchError) error {
	v.Type = "B2B_ISSUANCE_TYPE_MISMATCH"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bModificationNotProvidedError returns the union data inside the RequestB2bTaxInvoiceError as a B2bModificationNotProvidedError
func (t RequestB2bTaxInvoiceError) AsB2bModificationNotProvidedError() (B2bModificationNotProvidedError, error) {
	var body B2bModificationNotProvidedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bModificationNotProvidedError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bModificationNotProvidedError
func (t *RequestB2bTaxInvoiceError) FromB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bModificationNotProvidedError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bModificationNotProvidedError
func (t *RequestB2bTaxInvoiceError) MergeB2bModificationNotProvidedError(v B2bModificationNotProvidedError) error {
	v.Type = "B2B_MODIFICATION_NOT_PROVIDED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bNotEnabledError returns the union data inside the RequestB2bTaxInvoiceError as a B2bNotEnabledError
func (t RequestB2bTaxInvoiceError) AsB2bNotEnabledError() (B2bNotEnabledError, error) {
	var body B2bNotEnabledError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bNotEnabledError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bNotEnabledError
func (t *RequestB2bTaxInvoiceError) FromB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bNotEnabledError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bNotEnabledError
func (t *RequestB2bTaxInvoiceError) MergeB2bNotEnabledError(v B2bNotEnabledError) error {
	v.Type = "B2B_NOT_ENABLED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bOriginalTaxInvoiceNotFoundError returns the union data inside the RequestB2bTaxInvoiceError as a B2bOriginalTaxInvoiceNotFoundError
func (t RequestB2bTaxInvoiceError) AsB2bOriginalTaxInvoiceNotFoundError() (B2bOriginalTaxInvoiceNotFoundError, error) {
	var body B2bOriginalTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bOriginalTaxInvoiceNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bOriginalTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceError) FromB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bOriginalTaxInvoiceNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bOriginalTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceError) MergeB2bOriginalTaxInvoiceNotFoundError(v B2bOriginalTaxInvoiceNotFoundError) error {
	v.Type = "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNoRecipientDocumentKeyError returns the union data inside the RequestB2bTaxInvoiceError as a B2bTaxInvoiceNoRecipientDocumentKeyError
func (t RequestB2bTaxInvoiceError) AsB2bTaxInvoiceNoRecipientDocumentKeyError() (B2bTaxInvoiceNoRecipientDocumentKeyError, error) {
	var body B2bTaxInvoiceNoRecipientDocumentKeyError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNoRecipientDocumentKeyError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bTaxInvoiceNoRecipientDocumentKeyError
func (t *RequestB2bTaxInvoiceError) FromB2bTaxInvoiceNoRecipientDocumentKeyError(v B2bTaxInvoiceNoRecipientDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNoRecipientDocumentKeyError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bTaxInvoiceNoRecipientDocumentKeyError
func (t *RequestB2bTaxInvoiceError) MergeB2bTaxInvoiceNoRecipientDocumentKeyError(v B2bTaxInvoiceNoRecipientDocumentKeyError) error {
	v.Type = "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotDraftedStatusError returns the union data inside the RequestB2bTaxInvoiceError as a B2bTaxInvoiceNotDraftedStatusError
func (t RequestB2bTaxInvoiceError) AsB2bTaxInvoiceNotDraftedStatusError() (B2bTaxInvoiceNotDraftedStatusError, error) {
	var body B2bTaxInvoiceNotDraftedStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotDraftedStatusError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bTaxInvoiceNotDraftedStatusError
func (t *RequestB2bTaxInvoiceError) FromB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotDraftedStatusError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotDraftedStatusError
func (t *RequestB2bTaxInvoiceError) MergeB2bTaxInvoiceNotDraftedStatusError(v B2bTaxInvoiceNotDraftedStatusError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsB2bTaxInvoiceNotFoundError returns the union data inside the RequestB2bTaxInvoiceError as a B2bTaxInvoiceNotFoundError
func (t RequestB2bTaxInvoiceError) AsB2bTaxInvoiceNotFoundError() (B2bTaxInvoiceNotFoundError, error) {
	var body B2bTaxInvoiceNotFoundError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromB2bTaxInvoiceNotFoundError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided B2bTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceError) FromB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeB2bTaxInvoiceNotFoundError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided B2bTaxInvoiceNotFoundError
func (t *RequestB2bTaxInvoiceError) MergeB2bTaxInvoiceNotFoundError(v B2bTaxInvoiceNotFoundError) error {
	v.Type = "B2B_TAX_INVOICE_NOT_FOUND"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForbiddenError returns the union data inside the RequestB2bTaxInvoiceError as a ForbiddenError
func (t RequestB2bTaxInvoiceError) AsForbiddenError() (ForbiddenError, error) {
	var body ForbiddenError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForbiddenError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided ForbiddenError
func (t *RequestB2bTaxInvoiceError) FromForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForbiddenError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided ForbiddenError
func (t *RequestB2bTaxInvoiceError) MergeForbiddenError(v ForbiddenError) error {
	v.Type = "FORBIDDEN"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidRequestError returns the union data inside the RequestB2bTaxInvoiceError as a InvalidRequestError
func (t RequestB2bTaxInvoiceError) AsInvalidRequestError() (InvalidRequestError, error) {
	var body InvalidRequestError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidRequestError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided InvalidRequestError
func (t *RequestB2bTaxInvoiceError) FromInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidRequestError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided InvalidRequestError
func (t *RequestB2bTaxInvoiceError) MergeInvalidRequestError(v InvalidRequestError) error {
	v.Type = "INVALID_REQUEST"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnauthorizedError returns the union data inside the RequestB2bTaxInvoiceError as a UnauthorizedError
func (t RequestB2bTaxInvoiceError) AsUnauthorizedError() (UnauthorizedError, error) {
	var body UnauthorizedError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnauthorizedError overwrites any union data inside the RequestB2bTaxInvoiceError as the provided UnauthorizedError
func (t *RequestB2bTaxInvoiceError) FromUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnauthorizedError performs a merge with any union data inside the RequestB2bTaxInvoiceError, using the provided UnauthorizedError
func (t *RequestB2bTaxInvoiceError) MergeUnauthorizedError(v UnauthorizedError) error {
	v.Type = "UNAUTHORIZED"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestB2bTaxInvoiceError) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RequestB2bTaxInvoiceError) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "B2B_CANNOT_CHANGE_TAX_TYPE":
		return t.AsB2BCannotChangeTaxTypeError()
	case "B2B_EXTERNAL_SERVICE":
		return t.AsB2bExternalServiceError()
	case "B2B_ISSUANCE_TYPE_MISMATCH":
		return t.AsB2bIssuanceTypeMismatchError()
	case "B2B_MODIFICATION_NOT_PROVIDED":
		return t.AsB2bModificationNotProvidedError()
	case "B2B_NOT_ENABLED":
		return t.AsB2bNotEnabledError()
	case "B2B_ORIGINAL_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bOriginalTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NOT_DRAFTED_STATUS":
		return t.AsB2bTaxInvoiceNotDraftedStatusError()
	case "B2B_TAX_INVOICE_NOT_FOUND":
		return t.AsB2bTaxInvoiceNotFoundError()
	case "B2B_TAX_INVOICE_NO_RECIPIENT_DOCUMENT_KEY":
		return t.AsB2bTaxInvoiceNoRecipientDocumentKeyError()
	case "B2B_TAX_INVOICE_STATUS_NOT_SENDING_COMPLETED":
		return t.AsB2BTaxInvoiceStatusNotSendingCompletedError()
	case "FORBIDDEN":
		return t.AsForbiddenError()
	case "INVALID_REQUEST":
		return t.AsInvalidRequestError()
	case "UNAUTHORIZED":
		return t.AsUnauthorizedError()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RequestB2bTaxInvoiceError) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestB2bTaxInvoiceError) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetB2bBulkTaxInvoice request
	GetB2bBulkTaxInvoice(ctx context.Context, bulkTaxInvoiceId string, params *GetB2bBulkTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bBusinessInfosWithBody request with any body
	GetB2bBusinessInfosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetB2bBusinessInfos(ctx context.Context, body GetB2bBusinessInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateB2bFileUploadUrlWithBody request with any body
	CreateB2bFileUploadUrlWithBody(ctx context.Context, params *CreateB2bFileUploadUrlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateB2bFileUploadUrl(ctx context.Context, params *CreateB2bFileUploadUrlParams, body CreateB2bFileUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoicesWithBody request with any body
	GetB2bTaxInvoicesWithBody(ctx context.Context, params *GetB2bTaxInvoicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetB2bTaxInvoices(ctx context.Context, params *GetB2bTaxInvoicesParams, body GetB2bTaxInvoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadB2bTaxInvoicesSheetWithBody request with any body
	DownloadB2bTaxInvoicesSheetWithBody(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadB2bTaxInvoicesSheet(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, body DownloadB2bTaxInvoicesSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DraftB2bTaxInvoiceWithBody request with any body
	DraftB2bTaxInvoiceWithBody(ctx context.Context, params *DraftB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DraftB2bTaxInvoice(ctx context.Context, params *DraftB2bTaxInvoiceParams, body DraftB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateB2bTaxInvoiceDraftWithBody request with any body
	UpdateB2bTaxInvoiceDraftWithBody(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateB2bTaxInvoiceDraft(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, body UpdateB2bTaxInvoiceDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueB2bTaxInvoiceImmediatelyWithBody request with any body
	IssueB2bTaxInvoiceImmediatelyWithBody(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueB2bTaxInvoiceImmediately(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, body IssueB2bTaxInvoiceImmediatelyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestB2bTaxInvoiceReverseIssuanceWithBody request with any body
	RequestB2bTaxInvoiceReverseIssuanceWithBody(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestB2bTaxInvoiceReverseIssuance(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, body RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteB2bTaxInvoice request
	DeleteB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *DeleteB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoice request
	GetB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachB2bTaxInvoiceFileWithBody request with any body
	AttachB2bTaxInvoiceFileWithBody(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachB2bTaxInvoiceFile(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, body AttachB2bTaxInvoiceFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoiceAttachments request
	GetB2bTaxInvoiceAttachments(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteB2bTaxInvoiceAttachment request
	DeleteB2bTaxInvoiceAttachment(ctx context.Context, taxInvoiceKey string, attachmentId string, params *DeleteB2bTaxInvoiceAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelB2bTaxInvoiceIssuanceWithBody request with any body
	CancelB2bTaxInvoiceIssuanceWithBody(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelB2bTaxInvoiceIssuance(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, body CancelB2bTaxInvoiceIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelB2bTaxInvoiceRequestWithBody request with any body
	CancelB2bTaxInvoiceRequestWithBody(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelB2bTaxInvoiceRequest(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, body CancelB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueB2bTaxInvoiceWithBody request with any body
	IssueB2bTaxInvoiceWithBody(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, body IssueB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoicePdfDownloadUrl request
	GetB2bTaxInvoicePdfDownloadUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePdfDownloadUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoicePopupUrl request
	GetB2bTaxInvoicePopupUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePopupUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetB2bTaxInvoicePrintUrl request
	GetB2bTaxInvoicePrintUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePrintUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefuseB2bTaxInvoiceRequestWithBody request with any body
	RefuseB2bTaxInvoiceRequestWithBody(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefuseB2bTaxInvoiceRequest(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, body RefuseB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestB2bTaxInvoice request
	RequestB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *RequestB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendToNtsB2bTaxInvoice request
	SendToNtsB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *SendToNtsB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBankInfos request
	GetBankInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingKeyInfosWithBody request with any body
	GetBillingKeyInfosWithBody(ctx context.Context, params *GetBillingKeyInfosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetBillingKeyInfos(ctx context.Context, params *GetBillingKeyInfosParams, body GetBillingKeyInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueBillingKeyWithBody request with any body
	IssueBillingKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueBillingKey(ctx context.Context, body IssueBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmBillingKeyWithBody request with any body
	ConfirmBillingKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmBillingKey(ctx context.Context, body ConfirmBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmBillingKeyIssueAndPayWithBody request with any body
	ConfirmBillingKeyIssueAndPayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmBillingKeyIssueAndPay(ctx context.Context, body ConfirmBillingKeyIssueAndPayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBillingKey request
	DeleteBillingKey(ctx context.Context, billingKey string, params *DeleteBillingKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingKeyInfo request
	GetBillingKeyInfo(ctx context.Context, billingKey string, params *GetBillingKeyInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashReceiptsWithBody request with any body
	GetCashReceiptsWithBody(ctx context.Context, params *GetCashReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetCashReceipts(ctx context.Context, params *GetCashReceiptsParams, body GetCashReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCashReceiptWithBody request with any body
	IssueCashReceiptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueCashReceipt(ctx context.Context, body IssueCashReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityVerificationsWithBody request with any body
	GetIdentityVerificationsWithBody(ctx context.Context, params *GetIdentityVerificationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetIdentityVerifications(ctx context.Context, params *GetIdentityVerificationsParams, body GetIdentityVerificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIdentityVerification request
	GetIdentityVerification(ctx context.Context, identityVerificationId string, params *GetIdentityVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmIdentityVerificationWithBody request with any body
	ConfirmIdentityVerificationWithBody(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmIdentityVerification(ctx context.Context, identityVerificationId string, body ConfirmIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResendIdentityVerification request
	ResendIdentityVerification(ctx context.Context, identityVerificationId string, params *ResendIdentityVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendIdentityVerificationWithBody request with any body
	SendIdentityVerificationWithBody(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendIdentityVerification(ctx context.Context, identityVerificationId string, body SendIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKakaopayPaymentOrder request
	GetKakaopayPaymentOrder(ctx context.Context, params *GetKakaopayPaymentOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginViaApiSecretWithBody request with any body
	LoginViaApiSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginViaApiSecret(ctx context.Context, body LoginViaApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllPaymentEventsByCursorWithBody request with any body
	GetAllPaymentEventsByCursorWithBody(ctx context.Context, params *GetAllPaymentEventsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetAllPaymentEventsByCursor(ctx context.Context, params *GetAllPaymentEventsByCursorParams, body GetAllPaymentEventsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokePaymentSchedulesWithBody request with any body
	RevokePaymentSchedulesWithBody(ctx context.Context, params *RevokePaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokePaymentSchedules(ctx context.Context, params *RevokePaymentSchedulesParams, body RevokePaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentSchedulesWithBody request with any body
	GetPaymentSchedulesWithBody(ctx context.Context, params *GetPaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPaymentSchedules(ctx context.Context, params *GetPaymentSchedulesParams, body GetPaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentSchedule request
	GetPaymentSchedule(ctx context.Context, paymentScheduleId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentsWithBody request with any body
	GetPaymentsWithBody(ctx context.Context, params *GetPaymentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPayments(ctx context.Context, params *GetPaymentsParams, body GetPaymentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllPaymentsByCursorWithBody request with any body
	GetAllPaymentsByCursorWithBody(ctx context.Context, params *GetAllPaymentsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetAllPaymentsByCursor(ctx context.Context, params *GetAllPaymentsByCursorParams, body GetAllPaymentsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayment request
	GetPayment(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayWithBillingKeyWithBody request with any body
	PayWithBillingKeyWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PayWithBillingKey(ctx context.Context, paymentId string, body PayWithBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPaymentWithBody request with any body
	CancelPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelPayment(ctx context.Context, paymentId string, body CancelPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CapturePaymentWithBody request with any body
	CapturePaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CapturePayment(ctx context.Context, paymentId string, body CapturePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashReceiptByPaymentId request
	GetCashReceiptByPaymentId(ctx context.Context, paymentId string, params *GetCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelCashReceiptByPaymentId request
	CancelCashReceiptByPaymentId(ctx context.Context, paymentId string, params *CancelCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmPaymentWithBody request with any body
	ConfirmPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmPayment(ctx context.Context, paymentId string, body ConfirmPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfirmEscrowWithBody request with any body
	ConfirmEscrowWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfirmEscrow(ctx context.Context, paymentId string, body ConfirmEscrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyEscrowLogisticsWithBody request with any body
	ModifyEscrowLogisticsWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyEscrowLogistics(ctx context.Context, paymentId string, body ModifyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApplyEscrowLogisticsWithBody request with any body
	ApplyEscrowLogisticsWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplyEscrowLogistics(ctx context.Context, paymentId string, body ApplyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PayInstantlyWithBody request with any body
	PayInstantlyWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PayInstantly(ctx context.Context, paymentId string, body PayInstantlyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreRegisterPaymentWithBody request with any body
	PreRegisterPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreRegisterPayment(ctx context.Context, paymentId string, body PreRegisterPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterStoreReceiptWithBody request with any body
	RegisterStoreReceiptWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterStoreReceipt(ctx context.Context, paymentId string, body RegisterStoreReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResendWebhookWithBody request with any body
	ResendWebhookWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResendWebhook(ctx context.Context, paymentId string, body ResendWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePaymentScheduleWithBody request with any body
	CreatePaymentScheduleWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePaymentSchedule(ctx context.Context, paymentId string, body CreatePaymentScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentTransactions request
	GetPaymentTransactions(ctx context.Context, paymentId string, params *GetPaymentTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseVirtualAccount request
	CloseVirtualAccount(ctx context.Context, paymentId string, params *CloseVirtualAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAccountTransfersWithBody request with any body
	GetPlatformAccountTransfersWithBody(ctx context.Context, params *GetPlatformAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformAccountTransfers(ctx context.Context, params *GetPlatformAccountTransfersParams, body GetPlatformAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAdditionalFeePoliciesWithBody request with any body
	GetPlatformAdditionalFeePoliciesWithBody(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformAdditionalFeePolicies(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, body GetPlatformAdditionalFeePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformAdditionalFeePolicyWithBody request with any body
	CreatePlatformAdditionalFeePolicyWithBody(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformAdditionalFeePolicy(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, body CreatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAdditionalFeePolicy request
	GetPlatformAdditionalFeePolicy(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlatformAdditionalFeePolicyWithBody request with any body
	UpdatePlatformAdditionalFeePolicyWithBody(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlatformAdditionalFeePolicy(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, body UpdatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlatformAdditionalFeePolicy request
	ArchivePlatformAdditionalFeePolicy(ctx context.Context, id string, params *ArchivePlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverPlatformAdditionalFeePolicy request
	RecoverPlatformAdditionalFeePolicy(ctx context.Context, id string, params *RecoverPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPlatformAdditionalFeePolicySchedule request
	CancelPlatformAdditionalFeePolicySchedule(ctx context.Context, id string, params *CancelPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAdditionalFeePolicySchedule request
	GetPlatformAdditionalFeePolicySchedule(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduleAdditionalFeePolicyWithBody request with any body
	ScheduleAdditionalFeePolicyWithBody(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScheduleAdditionalFeePolicy(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, body ScheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RescheduleAdditionalFeePolicyWithBody request with any body
	RescheduleAdditionalFeePolicyWithBody(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RescheduleAdditionalFeePolicy(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, body RescheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAccountHolder request
	GetPlatformAccountHolder(ctx context.Context, bank Bank, accountNumber string, params *GetPlatformAccountHolderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformBulkAccountTransfersWithBody request with any body
	GetPlatformBulkAccountTransfersWithBody(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformBulkAccountTransfers(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, body GetPlatformBulkAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformBulkPayoutsWithBody request with any body
	GetPlatformBulkPayoutsWithBody(ctx context.Context, params *GetPlatformBulkPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformBulkPayouts(ctx context.Context, params *GetPlatformBulkPayoutsParams, body GetPlatformBulkPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformCompanyState request
	GetPlatformCompanyState(ctx context.Context, businessRegistrationNumber string, params *GetPlatformCompanyStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformContractsWithBody request with any body
	GetPlatformContractsWithBody(ctx context.Context, params *GetPlatformContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformContracts(ctx context.Context, params *GetPlatformContractsParams, body GetPlatformContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformContractWithBody request with any body
	CreatePlatformContractWithBody(ctx context.Context, params *CreatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformContract(ctx context.Context, params *CreatePlatformContractParams, body CreatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformContract request
	GetPlatformContract(ctx context.Context, id string, params *GetPlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlatformContractWithBody request with any body
	UpdatePlatformContractWithBody(ctx context.Context, id string, params *UpdatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlatformContract(ctx context.Context, id string, params *UpdatePlatformContractParams, body UpdatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlatformContract request
	ArchivePlatformContract(ctx context.Context, id string, params *ArchivePlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverPlatformContract request
	RecoverPlatformContract(ctx context.Context, id string, params *RecoverPlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPlatformContractSchedule request
	CancelPlatformContractSchedule(ctx context.Context, id string, params *CancelPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformContractSchedule request
	GetPlatformContractSchedule(ctx context.Context, id string, params *GetPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduleContractWithBody request with any body
	ScheduleContractWithBody(ctx context.Context, id string, params *ScheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScheduleContract(ctx context.Context, id string, params *ScheduleContractParams, body ScheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RescheduleContractWithBody request with any body
	RescheduleContractWithBody(ctx context.Context, id string, params *RescheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RescheduleContract(ctx context.Context, id string, params *RescheduleContractParams, body RescheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDiscountSharePoliciesWithBody request with any body
	GetPlatformDiscountSharePoliciesWithBody(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformDiscountSharePolicies(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, body GetPlatformDiscountSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformDiscountSharePolicyWithBody request with any body
	CreatePlatformDiscountSharePolicyWithBody(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformDiscountSharePolicy(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, body CreatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDiscountSharePolicy request
	GetPlatformDiscountSharePolicy(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlatformDiscountSharePolicyWithBody request with any body
	UpdatePlatformDiscountSharePolicyWithBody(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlatformDiscountSharePolicy(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, body UpdatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlatformDiscountSharePolicy request
	ArchivePlatformDiscountSharePolicy(ctx context.Context, id string, params *ArchivePlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverPlatformDiscountSharePolicy request
	RecoverPlatformDiscountSharePolicy(ctx context.Context, id string, params *RecoverPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPlatformDiscountSharePolicySchedule request
	CancelPlatformDiscountSharePolicySchedule(ctx context.Context, id string, params *CancelPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDiscountSharePolicySchedule request
	GetPlatformDiscountSharePolicySchedule(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScheduleDiscountSharePolicyWithBody request with any body
	ScheduleDiscountSharePolicyWithBody(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScheduleDiscountSharePolicy(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, body ScheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RescheduleDiscountSharePolicyWithBody request with any body
	RescheduleDiscountSharePolicyWithBody(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RescheduleDiscountSharePolicy(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, body RescheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformDiscountSharePolicyFilterOptions request
	GetPlatformDiscountSharePolicyFilterOptions(ctx context.Context, params *GetPlatformDiscountSharePolicyFilterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPartnerFilterOptions request
	GetPlatformPartnerFilterOptions(ctx context.Context, params *GetPlatformPartnerFilterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPartnerSettlementsWithBody request with any body
	GetPlatformPartnerSettlementsWithBody(ctx context.Context, params *GetPlatformPartnerSettlementsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformPartnerSettlements(ctx context.Context, params *GetPlatformPartnerSettlementsParams, body GetPlatformPartnerSettlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPartnersWithBody request with any body
	GetPlatformPartnersWithBody(ctx context.Context, params *GetPlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformPartners(ctx context.Context, params *GetPlatformPartnersParams, body GetPlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformPartnerWithBody request with any body
	CreatePlatformPartnerWithBody(ctx context.Context, params *CreatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformPartner(ctx context.Context, params *CreatePlatformPartnerParams, body CreatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformPartnersWithBody request with any body
	CreatePlatformPartnersWithBody(ctx context.Context, params *CreatePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformPartners(ctx context.Context, params *CreatePlatformPartnersParams, body CreatePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectBulkPartnerMemberCompanyWithBody request with any body
	ConnectBulkPartnerMemberCompanyWithBody(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectBulkPartnerMemberCompany(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, body ConnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectPartnerMemberCompany request
	ConnectPartnerMemberCompany(ctx context.Context, id string, params *ConnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectBulkPartnerMemberCompanyWithBody request with any body
	DisconnectBulkPartnerMemberCompanyWithBody(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisconnectBulkPartnerMemberCompany(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, body DisconnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectPartnerMemberCompany request
	DisconnectPartnerMemberCompany(ctx context.Context, id string, params *DisconnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchedulePlatformPartnersWithBody request with any body
	SchedulePlatformPartnersWithBody(ctx context.Context, params *SchedulePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchedulePlatformPartners(ctx context.Context, params *SchedulePlatformPartnersParams, body SchedulePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPartner request
	GetPlatformPartner(ctx context.Context, id string, params *GetPlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlatformPartnerWithBody request with any body
	UpdatePlatformPartnerWithBody(ctx context.Context, id string, params *UpdatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlatformPartner(ctx context.Context, id string, params *UpdatePlatformPartnerParams, body UpdatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlatformPartner request
	ArchivePlatformPartner(ctx context.Context, id string, params *ArchivePlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverPlatformPartner request
	RecoverPlatformPartner(ctx context.Context, id string, params *RecoverPlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelPlatformPartnerSchedule request
	CancelPlatformPartnerSchedule(ctx context.Context, id string, params *CancelPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPartnerSchedule request
	GetPlatformPartnerSchedule(ctx context.Context, id string, params *GetPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchedulePartnerWithBody request with any body
	SchedulePartnerWithBody(ctx context.Context, id string, params *SchedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchedulePartner(ctx context.Context, id string, params *SchedulePartnerParams, body SchedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReschedulePartnerWithBody request with any body
	ReschedulePartnerWithBody(ctx context.Context, id string, params *ReschedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReschedulePartner(ctx context.Context, id string, params *ReschedulePartnerParams, body ReschedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformPayoutsWithBody request with any body
	GetPlatformPayoutsWithBody(ctx context.Context, params *GetPlatformPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformPayouts(ctx context.Context, params *GetPlatformPayoutsParams, body GetPlatformPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformSetting request
	GetPlatformSetting(ctx context.Context, params *GetPlatformSettingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlatformSettingWithBody request with any body
	UpdatePlatformSettingWithBody(ctx context.Context, params *UpdatePlatformSettingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlatformSetting(ctx context.Context, params *UpdatePlatformSettingParams, body UpdatePlatformSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformTransferSummariesWithBody request with any body
	GetPlatformTransferSummariesWithBody(ctx context.Context, params *GetPlatformTransferSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPlatformTransferSummaries(ctx context.Context, params *GetPlatformTransferSummariesParams, body GetPlatformTransferSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadPlatformTransferSheetWithBody request with any body
	DownloadPlatformTransferSheetWithBody(ctx context.Context, params *DownloadPlatformTransferSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadPlatformTransferSheet(ctx context.Context, params *DownloadPlatformTransferSheetParams, body DownloadPlatformTransferSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformManualTransferWithBody request with any body
	CreatePlatformManualTransferWithBody(ctx context.Context, params *CreatePlatformManualTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformManualTransfer(ctx context.Context, params *CreatePlatformManualTransferParams, body CreatePlatformManualTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformOrderTransferWithBody request with any body
	CreatePlatformOrderTransferWithBody(ctx context.Context, params *CreatePlatformOrderTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformOrderTransfer(ctx context.Context, params *CreatePlatformOrderTransferParams, body CreatePlatformOrderTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlatformOrderCancelTransferWithBody request with any body
	CreatePlatformOrderCancelTransferWithBody(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlatformOrderCancelTransfer(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, body CreatePlatformOrderCancelTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlatformTransfer request
	DeletePlatformTransfer(ctx context.Context, id string, params *DeletePlatformTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformTransfer request
	GetPlatformTransfer(ctx context.Context, id string, params *GetPlatformTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPromotion request
	GetPromotion(ctx context.Context, promotionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshTokenWithBody request with any body
	RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetB2bBulkTaxInvoice(ctx context.Context, bulkTaxInvoiceId string, params *GetB2bBulkTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bBulkTaxInvoiceRequest(c.Server, bulkTaxInvoiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bBusinessInfosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bBusinessInfosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bBusinessInfos(ctx context.Context, body GetB2bBusinessInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bBusinessInfosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateB2bFileUploadUrlWithBody(ctx context.Context, params *CreateB2bFileUploadUrlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateB2bFileUploadUrlRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateB2bFileUploadUrl(ctx context.Context, params *CreateB2bFileUploadUrlParams, body CreateB2bFileUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateB2bFileUploadUrlRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoicesWithBody(ctx context.Context, params *GetB2bTaxInvoicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoicesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoices(ctx context.Context, params *GetB2bTaxInvoicesParams, body GetB2bTaxInvoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoicesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadB2bTaxInvoicesSheetWithBody(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadB2bTaxInvoicesSheetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadB2bTaxInvoicesSheet(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, body DownloadB2bTaxInvoicesSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadB2bTaxInvoicesSheetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftB2bTaxInvoiceWithBody(ctx context.Context, params *DraftB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftB2bTaxInvoiceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DraftB2bTaxInvoice(ctx context.Context, params *DraftB2bTaxInvoiceParams, body DraftB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDraftB2bTaxInvoiceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateB2bTaxInvoiceDraftWithBody(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateB2bTaxInvoiceDraftRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateB2bTaxInvoiceDraft(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, body UpdateB2bTaxInvoiceDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateB2bTaxInvoiceDraftRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueB2bTaxInvoiceImmediatelyWithBody(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueB2bTaxInvoiceImmediatelyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueB2bTaxInvoiceImmediately(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, body IssueB2bTaxInvoiceImmediatelyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueB2bTaxInvoiceImmediatelyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestB2bTaxInvoiceReverseIssuanceWithBody(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestB2bTaxInvoiceReverseIssuanceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestB2bTaxInvoiceReverseIssuance(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, body RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestB2bTaxInvoiceReverseIssuanceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *DeleteB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteB2bTaxInvoiceRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoiceRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachB2bTaxInvoiceFileWithBody(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachB2bTaxInvoiceFileRequestWithBody(c.Server, taxInvoiceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachB2bTaxInvoiceFile(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, body AttachB2bTaxInvoiceFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachB2bTaxInvoiceFileRequest(c.Server, taxInvoiceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoiceAttachments(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoiceAttachmentsRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteB2bTaxInvoiceAttachment(ctx context.Context, taxInvoiceKey string, attachmentId string, params *DeleteB2bTaxInvoiceAttachmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteB2bTaxInvoiceAttachmentRequest(c.Server, taxInvoiceKey, attachmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelB2bTaxInvoiceIssuanceWithBody(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelB2bTaxInvoiceIssuanceRequestWithBody(c.Server, taxInvoiceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelB2bTaxInvoiceIssuance(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, body CancelB2bTaxInvoiceIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelB2bTaxInvoiceIssuanceRequest(c.Server, taxInvoiceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelB2bTaxInvoiceRequestWithBody(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelB2bTaxInvoiceRequestRequestWithBody(c.Server, taxInvoiceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelB2bTaxInvoiceRequest(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, body CancelB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelB2bTaxInvoiceRequestRequest(c.Server, taxInvoiceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueB2bTaxInvoiceWithBody(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueB2bTaxInvoiceRequestWithBody(c.Server, taxInvoiceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, body IssueB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueB2bTaxInvoiceRequest(c.Server, taxInvoiceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoicePdfDownloadUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePdfDownloadUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoicePdfDownloadUrlRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoicePopupUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePopupUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoicePopupUrlRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetB2bTaxInvoicePrintUrl(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePrintUrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetB2bTaxInvoicePrintUrlRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefuseB2bTaxInvoiceRequestWithBody(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefuseB2bTaxInvoiceRequestRequestWithBody(c.Server, taxInvoiceKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefuseB2bTaxInvoiceRequest(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, body RefuseB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefuseB2bTaxInvoiceRequestRequest(c.Server, taxInvoiceKey, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *RequestB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestB2bTaxInvoiceRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendToNtsB2bTaxInvoice(ctx context.Context, taxInvoiceKey string, params *SendToNtsB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendToNtsB2bTaxInvoiceRequest(c.Server, taxInvoiceKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBankInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBankInfosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingKeyInfosWithBody(ctx context.Context, params *GetBillingKeyInfosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingKeyInfosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingKeyInfos(ctx context.Context, params *GetBillingKeyInfosParams, body GetBillingKeyInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingKeyInfosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueBillingKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueBillingKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueBillingKey(ctx context.Context, body IssueBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueBillingKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmBillingKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmBillingKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmBillingKey(ctx context.Context, body ConfirmBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmBillingKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmBillingKeyIssueAndPayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmBillingKeyIssueAndPayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmBillingKeyIssueAndPay(ctx context.Context, body ConfirmBillingKeyIssueAndPayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmBillingKeyIssueAndPayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBillingKey(ctx context.Context, billingKey string, params *DeleteBillingKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillingKeyRequest(c.Server, billingKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingKeyInfo(ctx context.Context, billingKey string, params *GetBillingKeyInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingKeyInfoRequest(c.Server, billingKey, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashReceiptsWithBody(ctx context.Context, params *GetCashReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashReceiptsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashReceipts(ctx context.Context, params *GetCashReceiptsParams, body GetCashReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashReceiptsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCashReceiptWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCashReceiptRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCashReceipt(ctx context.Context, body IssueCashReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCashReceiptRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityVerificationsWithBody(ctx context.Context, params *GetIdentityVerificationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityVerificationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityVerifications(ctx context.Context, params *GetIdentityVerificationsParams, body GetIdentityVerificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityVerificationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIdentityVerification(ctx context.Context, identityVerificationId string, params *GetIdentityVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIdentityVerificationRequest(c.Server, identityVerificationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmIdentityVerificationWithBody(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmIdentityVerificationRequestWithBody(c.Server, identityVerificationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmIdentityVerification(ctx context.Context, identityVerificationId string, body ConfirmIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmIdentityVerificationRequest(c.Server, identityVerificationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendIdentityVerification(ctx context.Context, identityVerificationId string, params *ResendIdentityVerificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendIdentityVerificationRequest(c.Server, identityVerificationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendIdentityVerificationWithBody(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendIdentityVerificationRequestWithBody(c.Server, identityVerificationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendIdentityVerification(ctx context.Context, identityVerificationId string, body SendIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendIdentityVerificationRequest(c.Server, identityVerificationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKakaopayPaymentOrder(ctx context.Context, params *GetKakaopayPaymentOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKakaopayPaymentOrderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginViaApiSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginViaApiSecretRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginViaApiSecret(ctx context.Context, body LoginViaApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginViaApiSecretRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPaymentEventsByCursorWithBody(ctx context.Context, params *GetAllPaymentEventsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPaymentEventsByCursorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPaymentEventsByCursor(ctx context.Context, params *GetAllPaymentEventsByCursorParams, body GetAllPaymentEventsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPaymentEventsByCursorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePaymentSchedulesWithBody(ctx context.Context, params *RevokePaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePaymentSchedulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokePaymentSchedules(ctx context.Context, params *RevokePaymentSchedulesParams, body RevokePaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokePaymentSchedulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedulesWithBody(ctx context.Context, params *GetPaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentSchedulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedules(ctx context.Context, params *GetPaymentSchedulesParams, body GetPaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentSchedulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedule(ctx context.Context, paymentScheduleId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentScheduleRequest(c.Server, paymentScheduleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentsWithBody(ctx context.Context, params *GetPaymentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayments(ctx context.Context, params *GetPaymentsParams, body GetPaymentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPaymentsByCursorWithBody(ctx context.Context, params *GetAllPaymentsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPaymentsByCursorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllPaymentsByCursor(ctx context.Context, params *GetAllPaymentsByCursorParams, body GetAllPaymentsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllPaymentsByCursorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayment(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayWithBillingKeyWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayWithBillingKeyRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayWithBillingKey(ctx context.Context, paymentId string, body PayWithBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayWithBillingKeyRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPaymentRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPayment(ctx context.Context, paymentId string, body CancelPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPaymentRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CapturePaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCapturePaymentRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CapturePayment(ctx context.Context, paymentId string, body CapturePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCapturePaymentRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashReceiptByPaymentId(ctx context.Context, paymentId string, params *GetCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashReceiptByPaymentIdRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelCashReceiptByPaymentId(ctx context.Context, paymentId string, params *CancelCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelCashReceiptByPaymentIdRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmPaymentRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmPayment(ctx context.Context, paymentId string, body ConfirmPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmPaymentRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmEscrowWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmEscrowRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfirmEscrow(ctx context.Context, paymentId string, body ConfirmEscrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfirmEscrowRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEscrowLogisticsWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEscrowLogisticsRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyEscrowLogistics(ctx context.Context, paymentId string, body ModifyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyEscrowLogisticsRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyEscrowLogisticsWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyEscrowLogisticsRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyEscrowLogistics(ctx context.Context, paymentId string, body ApplyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyEscrowLogisticsRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayInstantlyWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayInstantlyRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PayInstantly(ctx context.Context, paymentId string, body PayInstantlyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPayInstantlyRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreRegisterPaymentWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreRegisterPaymentRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreRegisterPayment(ctx context.Context, paymentId string, body PreRegisterPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreRegisterPaymentRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterStoreReceiptWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterStoreReceiptRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterStoreReceipt(ctx context.Context, paymentId string, body RegisterStoreReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterStoreReceiptRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendWebhookWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendWebhookRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResendWebhook(ctx context.Context, paymentId string, body ResendWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResendWebhookRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePaymentScheduleWithBody(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentScheduleRequestWithBody(c.Server, paymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePaymentSchedule(ctx context.Context, paymentId string, body CreatePaymentScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePaymentScheduleRequest(c.Server, paymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentTransactions(ctx context.Context, paymentId string, params *GetPaymentTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentTransactionsRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseVirtualAccount(ctx context.Context, paymentId string, params *CloseVirtualAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseVirtualAccountRequest(c.Server, paymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAccountTransfersWithBody(ctx context.Context, params *GetPlatformAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAccountTransfersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAccountTransfers(ctx context.Context, params *GetPlatformAccountTransfersParams, body GetPlatformAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAccountTransfersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAdditionalFeePoliciesWithBody(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAdditionalFeePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAdditionalFeePolicies(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, body GetPlatformAdditionalFeePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAdditionalFeePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformAdditionalFeePolicyWithBody(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformAdditionalFeePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformAdditionalFeePolicy(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, body CreatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformAdditionalFeePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAdditionalFeePolicy(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAdditionalFeePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformAdditionalFeePolicyWithBody(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformAdditionalFeePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformAdditionalFeePolicy(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, body UpdatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformAdditionalFeePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlatformAdditionalFeePolicy(ctx context.Context, id string, params *ArchivePlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatformAdditionalFeePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverPlatformAdditionalFeePolicy(ctx context.Context, id string, params *RecoverPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverPlatformAdditionalFeePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPlatformAdditionalFeePolicySchedule(ctx context.Context, id string, params *CancelPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPlatformAdditionalFeePolicyScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAdditionalFeePolicySchedule(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAdditionalFeePolicyScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleAdditionalFeePolicyWithBody(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleAdditionalFeePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleAdditionalFeePolicy(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, body ScheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleAdditionalFeePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleAdditionalFeePolicyWithBody(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleAdditionalFeePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleAdditionalFeePolicy(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, body RescheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleAdditionalFeePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAccountHolder(ctx context.Context, bank Bank, accountNumber string, params *GetPlatformAccountHolderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAccountHolderRequest(c.Server, bank, accountNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformBulkAccountTransfersWithBody(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformBulkAccountTransfersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformBulkAccountTransfers(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, body GetPlatformBulkAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformBulkAccountTransfersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformBulkPayoutsWithBody(ctx context.Context, params *GetPlatformBulkPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformBulkPayoutsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformBulkPayouts(ctx context.Context, params *GetPlatformBulkPayoutsParams, body GetPlatformBulkPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformBulkPayoutsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformCompanyState(ctx context.Context, businessRegistrationNumber string, params *GetPlatformCompanyStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformCompanyStateRequest(c.Server, businessRegistrationNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformContractsWithBody(ctx context.Context, params *GetPlatformContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformContractsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformContracts(ctx context.Context, params *GetPlatformContractsParams, body GetPlatformContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformContractsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformContractWithBody(ctx context.Context, params *CreatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformContractRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformContract(ctx context.Context, params *CreatePlatformContractParams, body CreatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformContractRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformContract(ctx context.Context, id string, params *GetPlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformContractRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformContractWithBody(ctx context.Context, id string, params *UpdatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformContractRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformContract(ctx context.Context, id string, params *UpdatePlatformContractParams, body UpdatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformContractRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlatformContract(ctx context.Context, id string, params *ArchivePlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatformContractRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverPlatformContract(ctx context.Context, id string, params *RecoverPlatformContractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverPlatformContractRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPlatformContractSchedule(ctx context.Context, id string, params *CancelPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPlatformContractScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformContractSchedule(ctx context.Context, id string, params *GetPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformContractScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleContractWithBody(ctx context.Context, id string, params *ScheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleContractRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleContract(ctx context.Context, id string, params *ScheduleContractParams, body ScheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleContractRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleContractWithBody(ctx context.Context, id string, params *RescheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleContractRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleContract(ctx context.Context, id string, params *RescheduleContractParams, body RescheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleContractRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDiscountSharePoliciesWithBody(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDiscountSharePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDiscountSharePolicies(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, body GetPlatformDiscountSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDiscountSharePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformDiscountSharePolicyWithBody(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformDiscountSharePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformDiscountSharePolicy(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, body CreatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformDiscountSharePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDiscountSharePolicy(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDiscountSharePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformDiscountSharePolicyWithBody(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformDiscountSharePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformDiscountSharePolicy(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, body UpdatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformDiscountSharePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlatformDiscountSharePolicy(ctx context.Context, id string, params *ArchivePlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatformDiscountSharePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverPlatformDiscountSharePolicy(ctx context.Context, id string, params *RecoverPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverPlatformDiscountSharePolicyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPlatformDiscountSharePolicySchedule(ctx context.Context, id string, params *CancelPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPlatformDiscountSharePolicyScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDiscountSharePolicySchedule(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDiscountSharePolicyScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleDiscountSharePolicyWithBody(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleDiscountSharePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScheduleDiscountSharePolicy(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, body ScheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScheduleDiscountSharePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleDiscountSharePolicyWithBody(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleDiscountSharePolicyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RescheduleDiscountSharePolicy(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, body RescheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRescheduleDiscountSharePolicyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformDiscountSharePolicyFilterOptions(ctx context.Context, params *GetPlatformDiscountSharePolicyFilterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformDiscountSharePolicyFilterOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartnerFilterOptions(ctx context.Context, params *GetPlatformPartnerFilterOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnerFilterOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartnerSettlementsWithBody(ctx context.Context, params *GetPlatformPartnerSettlementsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnerSettlementsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartnerSettlements(ctx context.Context, params *GetPlatformPartnerSettlementsParams, body GetPlatformPartnerSettlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnerSettlementsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartnersWithBody(ctx context.Context, params *GetPlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartners(ctx context.Context, params *GetPlatformPartnersParams, body GetPlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformPartnerWithBody(ctx context.Context, params *CreatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformPartnerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformPartner(ctx context.Context, params *CreatePlatformPartnerParams, body CreatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformPartnerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformPartnersWithBody(ctx context.Context, params *CreatePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformPartnersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformPartners(ctx context.Context, params *CreatePlatformPartnersParams, body CreatePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformPartnersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectBulkPartnerMemberCompanyWithBody(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectBulkPartnerMemberCompanyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectBulkPartnerMemberCompany(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, body ConnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectBulkPartnerMemberCompanyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectPartnerMemberCompany(ctx context.Context, id string, params *ConnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectPartnerMemberCompanyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectBulkPartnerMemberCompanyWithBody(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectBulkPartnerMemberCompanyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectBulkPartnerMemberCompany(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, body DisconnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectBulkPartnerMemberCompanyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectPartnerMemberCompany(ctx context.Context, id string, params *DisconnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectPartnerMemberCompanyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchedulePlatformPartnersWithBody(ctx context.Context, params *SchedulePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchedulePlatformPartnersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchedulePlatformPartners(ctx context.Context, params *SchedulePlatformPartnersParams, body SchedulePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchedulePlatformPartnersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartner(ctx context.Context, id string, params *GetPlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformPartnerWithBody(ctx context.Context, id string, params *UpdatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformPartnerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformPartner(ctx context.Context, id string, params *UpdatePlatformPartnerParams, body UpdatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformPartnerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlatformPartner(ctx context.Context, id string, params *ArchivePlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatformPartnerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverPlatformPartner(ctx context.Context, id string, params *RecoverPlatformPartnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverPlatformPartnerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelPlatformPartnerSchedule(ctx context.Context, id string, params *CancelPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelPlatformPartnerScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPartnerSchedule(ctx context.Context, id string, params *GetPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPartnerScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchedulePartnerWithBody(ctx context.Context, id string, params *SchedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchedulePartnerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchedulePartner(ctx context.Context, id string, params *SchedulePartnerParams, body SchedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchedulePartnerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReschedulePartnerWithBody(ctx context.Context, id string, params *ReschedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReschedulePartnerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReschedulePartner(ctx context.Context, id string, params *ReschedulePartnerParams, body ReschedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReschedulePartnerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPayoutsWithBody(ctx context.Context, params *GetPlatformPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPayoutsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformPayouts(ctx context.Context, params *GetPlatformPayoutsParams, body GetPlatformPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformPayoutsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformSetting(ctx context.Context, params *GetPlatformSettingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformSettingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformSettingWithBody(ctx context.Context, params *UpdatePlatformSettingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformSettingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlatformSetting(ctx context.Context, params *UpdatePlatformSettingParams, body UpdatePlatformSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlatformSettingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformTransferSummariesWithBody(ctx context.Context, params *GetPlatformTransferSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformTransferSummariesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformTransferSummaries(ctx context.Context, params *GetPlatformTransferSummariesParams, body GetPlatformTransferSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformTransferSummariesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPlatformTransferSheetWithBody(ctx context.Context, params *DownloadPlatformTransferSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPlatformTransferSheetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadPlatformTransferSheet(ctx context.Context, params *DownloadPlatformTransferSheetParams, body DownloadPlatformTransferSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadPlatformTransferSheetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformManualTransferWithBody(ctx context.Context, params *CreatePlatformManualTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformManualTransferRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformManualTransfer(ctx context.Context, params *CreatePlatformManualTransferParams, body CreatePlatformManualTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformManualTransferRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformOrderTransferWithBody(ctx context.Context, params *CreatePlatformOrderTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformOrderTransferRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformOrderTransfer(ctx context.Context, params *CreatePlatformOrderTransferParams, body CreatePlatformOrderTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformOrderTransferRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformOrderCancelTransferWithBody(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformOrderCancelTransferRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlatformOrderCancelTransfer(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, body CreatePlatformOrderCancelTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlatformOrderCancelTransferRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlatformTransfer(ctx context.Context, id string, params *DeletePlatformTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlatformTransferRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformTransfer(ctx context.Context, id string, params *GetPlatformTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformTransferRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPromotion(ctx context.Context, promotionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPromotionRequest(c.Server, promotionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetB2bBulkTaxInvoiceRequest generates requests for GetB2bBulkTaxInvoice
func NewGetB2bBulkTaxInvoiceRequest(server string, bulkTaxInvoiceId string, params *GetB2bBulkTaxInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bulkTaxInvoiceId", runtime.ParamLocationPath, bulkTaxInvoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/bulk-tax-invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetB2bBusinessInfosRequest calls the generic GetB2bBusinessInfos builder with application/json body
func NewGetB2bBusinessInfosRequest(server string, body GetB2bBusinessInfosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetB2bBusinessInfosRequestWithBody(server, "application/json", bodyReader)
}

// NewGetB2bBusinessInfosRequestWithBody generates requests for GetB2bBusinessInfos with any type of body
func NewGetB2bBusinessInfosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/companies/business-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateB2bFileUploadUrlRequest calls the generic CreateB2bFileUploadUrl builder with application/json body
func NewCreateB2bFileUploadUrlRequest(server string, params *CreateB2bFileUploadUrlParams, body CreateB2bFileUploadUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateB2bFileUploadUrlRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateB2bFileUploadUrlRequestWithBody generates requests for CreateB2bFileUploadUrl with any type of body
func NewCreateB2bFileUploadUrlRequestWithBody(server string, params *CreateB2bFileUploadUrlParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/file-upload-url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetB2bTaxInvoicesRequest calls the generic GetB2bTaxInvoices builder with application/json body
func NewGetB2bTaxInvoicesRequest(server string, params *GetB2bTaxInvoicesParams, body GetB2bTaxInvoicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetB2bTaxInvoicesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetB2bTaxInvoicesRequestWithBody generates requests for GetB2bTaxInvoices with any type of body
func NewGetB2bTaxInvoicesRequestWithBody(server string, params *GetB2bTaxInvoicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadB2bTaxInvoicesSheetRequest calls the generic DownloadB2bTaxInvoicesSheet builder with application/json body
func NewDownloadB2bTaxInvoicesSheetRequest(server string, params *DownloadB2bTaxInvoicesSheetParams, body DownloadB2bTaxInvoicesSheetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadB2bTaxInvoicesSheetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadB2bTaxInvoicesSheetRequestWithBody generates requests for DownloadB2bTaxInvoicesSheet with any type of body
func NewDownloadB2bTaxInvoicesSheetRequestWithBody(server string, params *DownloadB2bTaxInvoicesSheetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices-sheet")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDraftB2bTaxInvoiceRequest calls the generic DraftB2bTaxInvoice builder with application/json body
func NewDraftB2bTaxInvoiceRequest(server string, params *DraftB2bTaxInvoiceParams, body DraftB2bTaxInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDraftB2bTaxInvoiceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDraftB2bTaxInvoiceRequestWithBody generates requests for DraftB2bTaxInvoice with any type of body
func NewDraftB2bTaxInvoiceRequestWithBody(server string, params *DraftB2bTaxInvoiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/draft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateB2bTaxInvoiceDraftRequest calls the generic UpdateB2bTaxInvoiceDraft builder with application/json body
func NewUpdateB2bTaxInvoiceDraftRequest(server string, params *UpdateB2bTaxInvoiceDraftParams, body UpdateB2bTaxInvoiceDraftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateB2bTaxInvoiceDraftRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateB2bTaxInvoiceDraftRequestWithBody generates requests for UpdateB2bTaxInvoiceDraft with any type of body
func NewUpdateB2bTaxInvoiceDraftRequestWithBody(server string, params *UpdateB2bTaxInvoiceDraftParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/draft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueB2bTaxInvoiceImmediatelyRequest calls the generic IssueB2bTaxInvoiceImmediately builder with application/json body
func NewIssueB2bTaxInvoiceImmediatelyRequest(server string, params *IssueB2bTaxInvoiceImmediatelyParams, body IssueB2bTaxInvoiceImmediatelyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueB2bTaxInvoiceImmediatelyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewIssueB2bTaxInvoiceImmediatelyRequestWithBody generates requests for IssueB2bTaxInvoiceImmediately with any type of body
func NewIssueB2bTaxInvoiceImmediatelyRequestWithBody(server string, params *IssueB2bTaxInvoiceImmediatelyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/issue-immediately")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRequestB2bTaxInvoiceReverseIssuanceRequest calls the generic RequestB2bTaxInvoiceReverseIssuance builder with application/json body
func NewRequestB2bTaxInvoiceReverseIssuanceRequest(server string, params *RequestB2bTaxInvoiceReverseIssuanceParams, body RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestB2bTaxInvoiceReverseIssuanceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRequestB2bTaxInvoiceReverseIssuanceRequestWithBody generates requests for RequestB2bTaxInvoiceReverseIssuance with any type of body
func NewRequestB2bTaxInvoiceReverseIssuanceRequestWithBody(server string, params *RequestB2bTaxInvoiceReverseIssuanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/request-reverse-issuance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteB2bTaxInvoiceRequest generates requests for DeleteB2bTaxInvoice
func NewDeleteB2bTaxInvoiceRequest(server string, taxInvoiceKey string, params *DeleteB2bTaxInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetB2bTaxInvoiceRequest generates requests for GetB2bTaxInvoice
func NewGetB2bTaxInvoiceRequest(server string, taxInvoiceKey string, params *GetB2bTaxInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachB2bTaxInvoiceFileRequest calls the generic AttachB2bTaxInvoiceFile builder with application/json body
func NewAttachB2bTaxInvoiceFileRequest(server string, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, body AttachB2bTaxInvoiceFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachB2bTaxInvoiceFileRequestWithBody(server, taxInvoiceKey, params, "application/json", bodyReader)
}

// NewAttachB2bTaxInvoiceFileRequestWithBody generates requests for AttachB2bTaxInvoiceFile with any type of body
func NewAttachB2bTaxInvoiceFileRequestWithBody(server string, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/attach-file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetB2bTaxInvoiceAttachmentsRequest generates requests for GetB2bTaxInvoiceAttachments
func NewGetB2bTaxInvoiceAttachmentsRequest(server string, taxInvoiceKey string, params *GetB2bTaxInvoiceAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/attachments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteB2bTaxInvoiceAttachmentRequest generates requests for DeleteB2bTaxInvoiceAttachment
func NewDeleteB2bTaxInvoiceAttachmentRequest(server string, taxInvoiceKey string, attachmentId string, params *DeleteB2bTaxInvoiceAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "attachmentId", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelB2bTaxInvoiceIssuanceRequest calls the generic CancelB2bTaxInvoiceIssuance builder with application/json body
func NewCancelB2bTaxInvoiceIssuanceRequest(server string, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, body CancelB2bTaxInvoiceIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelB2bTaxInvoiceIssuanceRequestWithBody(server, taxInvoiceKey, params, "application/json", bodyReader)
}

// NewCancelB2bTaxInvoiceIssuanceRequestWithBody generates requests for CancelB2bTaxInvoiceIssuance with any type of body
func NewCancelB2bTaxInvoiceIssuanceRequestWithBody(server string, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/cancel-issuance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelB2bTaxInvoiceRequestRequest calls the generic CancelB2bTaxInvoiceRequest builder with application/json body
func NewCancelB2bTaxInvoiceRequestRequest(server string, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, body CancelB2bTaxInvoiceRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelB2bTaxInvoiceRequestRequestWithBody(server, taxInvoiceKey, params, "application/json", bodyReader)
}

// NewCancelB2bTaxInvoiceRequestRequestWithBody generates requests for CancelB2bTaxInvoiceRequest with any type of body
func NewCancelB2bTaxInvoiceRequestRequestWithBody(server string, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/cancel-request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueB2bTaxInvoiceRequest calls the generic IssueB2bTaxInvoice builder with application/json body
func NewIssueB2bTaxInvoiceRequest(server string, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, body IssueB2bTaxInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueB2bTaxInvoiceRequestWithBody(server, taxInvoiceKey, params, "application/json", bodyReader)
}

// NewIssueB2bTaxInvoiceRequestWithBody generates requests for IssueB2bTaxInvoice with any type of body
func NewIssueB2bTaxInvoiceRequestWithBody(server string, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/issue", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetB2bTaxInvoicePdfDownloadUrlRequest generates requests for GetB2bTaxInvoicePdfDownloadUrl
func NewGetB2bTaxInvoicePdfDownloadUrlRequest(server string, taxInvoiceKey string, params *GetB2bTaxInvoicePdfDownloadUrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/pdf-download-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetB2bTaxInvoicePopupUrlRequest generates requests for GetB2bTaxInvoicePopupUrl
func NewGetB2bTaxInvoicePopupUrlRequest(server string, taxInvoiceKey string, params *GetB2bTaxInvoicePopupUrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/popup-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMenu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeMenu", runtime.ParamLocationQuery, *params.IncludeMenu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetB2bTaxInvoicePrintUrlRequest generates requests for GetB2bTaxInvoicePrintUrl
func NewGetB2bTaxInvoicePrintUrlRequest(server string, taxInvoiceKey string, params *GetB2bTaxInvoicePrintUrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/print-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefuseB2bTaxInvoiceRequestRequest calls the generic RefuseB2bTaxInvoiceRequest builder with application/json body
func NewRefuseB2bTaxInvoiceRequestRequest(server string, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, body RefuseB2bTaxInvoiceRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefuseB2bTaxInvoiceRequestRequestWithBody(server, taxInvoiceKey, params, "application/json", bodyReader)
}

// NewRefuseB2bTaxInvoiceRequestRequestWithBody generates requests for RefuseB2bTaxInvoiceRequest with any type of body
func NewRefuseB2bTaxInvoiceRequestRequestWithBody(server string, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/refuse-request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRequestB2bTaxInvoiceRequest generates requests for RequestB2bTaxInvoice
func NewRequestB2bTaxInvoiceRequest(server string, taxInvoiceKey string, params *RequestB2bTaxInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendToNtsB2bTaxInvoiceRequest generates requests for SendToNtsB2bTaxInvoice
func NewSendToNtsB2bTaxInvoiceRequest(server string, taxInvoiceKey string, params *SendToNtsB2bTaxInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "taxInvoiceKey", runtime.ParamLocationPath, taxInvoiceKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/b2b/tax-invoices/%s/send-to-nts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Brn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brn", runtime.ParamLocationQuery, *params.Brn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TaxInvoiceKeyType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "taxInvoiceKeyType", runtime.ParamLocationQuery, *params.TaxInvoiceKeyType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBankInfosRequest generates requests for GetBankInfos
func NewGetBankInfosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingKeyInfosRequest calls the generic GetBillingKeyInfos builder with application/json body
func NewGetBillingKeyInfosRequest(server string, params *GetBillingKeyInfosParams, body GetBillingKeyInfosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetBillingKeyInfosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetBillingKeyInfosRequestWithBody generates requests for GetBillingKeyInfos with any type of body
func NewGetBillingKeyInfosRequestWithBody(server string, params *GetBillingKeyInfosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueBillingKeyRequest calls the generic IssueBillingKey builder with application/json body
func NewIssueBillingKeyRequest(server string, body IssueBillingKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueBillingKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewIssueBillingKeyRequestWithBody generates requests for IssueBillingKey with any type of body
func NewIssueBillingKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmBillingKeyRequest calls the generic ConfirmBillingKey builder with application/json body
func NewConfirmBillingKeyRequest(server string, body ConfirmBillingKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmBillingKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewConfirmBillingKeyRequestWithBody generates requests for ConfirmBillingKey with any type of body
func NewConfirmBillingKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys/confirm")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmBillingKeyIssueAndPayRequest calls the generic ConfirmBillingKeyIssueAndPay builder with application/json body
func NewConfirmBillingKeyIssueAndPayRequest(server string, body ConfirmBillingKeyIssueAndPayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmBillingKeyIssueAndPayRequestWithBody(server, "application/json", bodyReader)
}

// NewConfirmBillingKeyIssueAndPayRequestWithBody generates requests for ConfirmBillingKeyIssueAndPay with any type of body
func NewConfirmBillingKeyIssueAndPayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys/confirm-issue-and-pay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBillingKeyRequest generates requests for DeleteBillingKey
func NewDeleteBillingKeyRequest(server string, billingKey string, params *DeleteBillingKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "billingKey", runtime.ParamLocationPath, billingKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Requester != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester", runtime.ParamLocationQuery, *params.Requester); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingKeyInfoRequest generates requests for GetBillingKeyInfo
func NewGetBillingKeyInfoRequest(server string, billingKey string, params *GetBillingKeyInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "billingKey", runtime.ParamLocationPath, billingKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/billing-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCashReceiptsRequest calls the generic GetCashReceipts builder with application/json body
func NewGetCashReceiptsRequest(server string, params *GetCashReceiptsParams, body GetCashReceiptsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetCashReceiptsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetCashReceiptsRequestWithBody generates requests for GetCashReceipts with any type of body
func NewGetCashReceiptsRequestWithBody(server string, params *GetCashReceiptsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cash-receipts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueCashReceiptRequest calls the generic IssueCashReceipt builder with application/json body
func NewIssueCashReceiptRequest(server string, body IssueCashReceiptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueCashReceiptRequestWithBody(server, "application/json", bodyReader)
}

// NewIssueCashReceiptRequestWithBody generates requests for IssueCashReceipt with any type of body
func NewIssueCashReceiptRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cash-receipts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIdentityVerificationsRequest calls the generic GetIdentityVerifications builder with application/json body
func NewGetIdentityVerificationsRequest(server string, params *GetIdentityVerificationsParams, body GetIdentityVerificationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetIdentityVerificationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetIdentityVerificationsRequestWithBody generates requests for GetIdentityVerifications with any type of body
func NewGetIdentityVerificationsRequestWithBody(server string, params *GetIdentityVerificationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity-verifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIdentityVerificationRequest generates requests for GetIdentityVerification
func NewGetIdentityVerificationRequest(server string, identityVerificationId string, params *GetIdentityVerificationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "identityVerificationId", runtime.ParamLocationPath, identityVerificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity-verifications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmIdentityVerificationRequest calls the generic ConfirmIdentityVerification builder with application/json body
func NewConfirmIdentityVerificationRequest(server string, identityVerificationId string, body ConfirmIdentityVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmIdentityVerificationRequestWithBody(server, identityVerificationId, "application/json", bodyReader)
}

// NewConfirmIdentityVerificationRequestWithBody generates requests for ConfirmIdentityVerification with any type of body
func NewConfirmIdentityVerificationRequestWithBody(server string, identityVerificationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "identityVerificationId", runtime.ParamLocationPath, identityVerificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity-verifications/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResendIdentityVerificationRequest generates requests for ResendIdentityVerification
func NewResendIdentityVerificationRequest(server string, identityVerificationId string, params *ResendIdentityVerificationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "identityVerificationId", runtime.ParamLocationPath, identityVerificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity-verifications/%s/resend", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendIdentityVerificationRequest calls the generic SendIdentityVerification builder with application/json body
func NewSendIdentityVerificationRequest(server string, identityVerificationId string, body SendIdentityVerificationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendIdentityVerificationRequestWithBody(server, identityVerificationId, "application/json", bodyReader)
}

// NewSendIdentityVerificationRequestWithBody generates requests for SendIdentityVerification with any type of body
func NewSendIdentityVerificationRequestWithBody(server string, identityVerificationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "identityVerificationId", runtime.ParamLocationPath, identityVerificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identity-verifications/%s/send", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKakaopayPaymentOrderRequest generates requests for GetKakaopayPaymentOrder
func NewGetKakaopayPaymentOrderRequest(server string, params *GetKakaopayPaymentOrderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/kakaopay/payment/order")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pgTxId", runtime.ParamLocationQuery, params.PgTxId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelKey", runtime.ParamLocationQuery, params.ChannelKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginViaApiSecretRequest calls the generic LoginViaApiSecret builder with application/json body
func NewLoginViaApiSecretRequest(server string, body LoginViaApiSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginViaApiSecretRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginViaApiSecretRequestWithBody generates requests for LoginViaApiSecret with any type of body
func NewLoginViaApiSecretRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/login/api-secret")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllPaymentEventsByCursorRequest calls the generic GetAllPaymentEventsByCursor builder with application/json body
func NewGetAllPaymentEventsByCursorRequest(server string, params *GetAllPaymentEventsByCursorParams, body GetAllPaymentEventsByCursorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAllPaymentEventsByCursorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetAllPaymentEventsByCursorRequestWithBody generates requests for GetAllPaymentEventsByCursor with any type of body
func NewGetAllPaymentEventsByCursorRequestWithBody(server string, params *GetAllPaymentEventsByCursorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-events-by-cursor")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokePaymentSchedulesRequest calls the generic RevokePaymentSchedules builder with application/json body
func NewRevokePaymentSchedulesRequest(server string, params *RevokePaymentSchedulesParams, body RevokePaymentSchedulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokePaymentSchedulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRevokePaymentSchedulesRequestWithBody generates requests for RevokePaymentSchedules with any type of body
func NewRevokePaymentSchedulesRequestWithBody(server string, params *RevokePaymentSchedulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentSchedulesRequest calls the generic GetPaymentSchedules builder with application/json body
func NewGetPaymentSchedulesRequest(server string, params *GetPaymentSchedulesParams, body GetPaymentSchedulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPaymentSchedulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPaymentSchedulesRequestWithBody generates requests for GetPaymentSchedules with any type of body
func NewGetPaymentSchedulesRequestWithBody(server string, params *GetPaymentSchedulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentScheduleRequest generates requests for GetPaymentSchedule
func NewGetPaymentScheduleRequest(server string, paymentScheduleId string, params *GetPaymentScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentScheduleId", runtime.ParamLocationPath, paymentScheduleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPaymentsRequest calls the generic GetPayments builder with application/json body
func NewGetPaymentsRequest(server string, params *GetPaymentsParams, body GetPaymentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPaymentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPaymentsRequestWithBody generates requests for GetPayments with any type of body
func NewGetPaymentsRequestWithBody(server string, params *GetPaymentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllPaymentsByCursorRequest calls the generic GetAllPaymentsByCursor builder with application/json body
func NewGetAllPaymentsByCursorRequest(server string, params *GetAllPaymentsByCursorParams, body GetAllPaymentsByCursorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAllPaymentsByCursorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetAllPaymentsByCursorRequestWithBody generates requests for GetAllPaymentsByCursor with any type of body
func NewGetAllPaymentsByCursorRequestWithBody(server string, params *GetAllPaymentsByCursorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments-by-cursor")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentRequest generates requests for GetPayment
func NewGetPaymentRequest(server string, paymentId string, params *GetPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPayWithBillingKeyRequest calls the generic PayWithBillingKey builder with application/json body
func NewPayWithBillingKeyRequest(server string, paymentId string, body PayWithBillingKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPayWithBillingKeyRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewPayWithBillingKeyRequestWithBody generates requests for PayWithBillingKey with any type of body
func NewPayWithBillingKeyRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/billing-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelPaymentRequest calls the generic CancelPayment builder with application/json body
func NewCancelPaymentRequest(server string, paymentId string, body CancelPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelPaymentRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewCancelPaymentRequestWithBody generates requests for CancelPayment with any type of body
func NewCancelPaymentRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCapturePaymentRequest calls the generic CapturePayment builder with application/json body
func NewCapturePaymentRequest(server string, paymentId string, body CapturePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCapturePaymentRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewCapturePaymentRequestWithBody generates requests for CapturePayment with any type of body
func NewCapturePaymentRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/capture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCashReceiptByPaymentIdRequest generates requests for GetCashReceiptByPaymentId
func NewGetCashReceiptByPaymentIdRequest(server string, paymentId string, params *GetCashReceiptByPaymentIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/cash-receipt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelCashReceiptByPaymentIdRequest generates requests for CancelCashReceiptByPaymentId
func NewCancelCashReceiptByPaymentIdRequest(server string, paymentId string, params *CancelCashReceiptByPaymentIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/cash-receipt/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfirmPaymentRequest calls the generic ConfirmPayment builder with application/json body
func NewConfirmPaymentRequest(server string, paymentId string, body ConfirmPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmPaymentRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewConfirmPaymentRequestWithBody generates requests for ConfirmPayment with any type of body
func NewConfirmPaymentRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/confirm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConfirmEscrowRequest calls the generic ConfirmEscrow builder with application/json body
func NewConfirmEscrowRequest(server string, paymentId string, body ConfirmEscrowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfirmEscrowRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewConfirmEscrowRequestWithBody generates requests for ConfirmEscrow with any type of body
func NewConfirmEscrowRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/escrow/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewModifyEscrowLogisticsRequest calls the generic ModifyEscrowLogistics builder with application/json body
func NewModifyEscrowLogisticsRequest(server string, paymentId string, body ModifyEscrowLogisticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyEscrowLogisticsRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewModifyEscrowLogisticsRequestWithBody generates requests for ModifyEscrowLogistics with any type of body
func NewModifyEscrowLogisticsRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/escrow/logistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApplyEscrowLogisticsRequest calls the generic ApplyEscrowLogistics builder with application/json body
func NewApplyEscrowLogisticsRequest(server string, paymentId string, body ApplyEscrowLogisticsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplyEscrowLogisticsRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewApplyEscrowLogisticsRequestWithBody generates requests for ApplyEscrowLogistics with any type of body
func NewApplyEscrowLogisticsRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/escrow/logistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPayInstantlyRequest calls the generic PayInstantly builder with application/json body
func NewPayInstantlyRequest(server string, paymentId string, body PayInstantlyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPayInstantlyRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewPayInstantlyRequestWithBody generates requests for PayInstantly with any type of body
func NewPayInstantlyRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/instant", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreRegisterPaymentRequest calls the generic PreRegisterPayment builder with application/json body
func NewPreRegisterPaymentRequest(server string, paymentId string, body PreRegisterPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreRegisterPaymentRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewPreRegisterPaymentRequestWithBody generates requests for PreRegisterPayment with any type of body
func NewPreRegisterPaymentRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/pre-register", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRegisterStoreReceiptRequest calls the generic RegisterStoreReceipt builder with application/json body
func NewRegisterStoreReceiptRequest(server string, paymentId string, body RegisterStoreReceiptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterStoreReceiptRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewRegisterStoreReceiptRequestWithBody generates requests for RegisterStoreReceipt with any type of body
func NewRegisterStoreReceiptRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/register-store-receipt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResendWebhookRequest calls the generic ResendWebhook builder with application/json body
func NewResendWebhookRequest(server string, paymentId string, body ResendWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResendWebhookRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewResendWebhookRequestWithBody generates requests for ResendWebhook with any type of body
func NewResendWebhookRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/resend-webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePaymentScheduleRequest calls the generic CreatePaymentSchedule builder with application/json body
func NewCreatePaymentScheduleRequest(server string, paymentId string, body CreatePaymentScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePaymentScheduleRequestWithBody(server, paymentId, "application/json", bodyReader)
}

// NewCreatePaymentScheduleRequestWithBody generates requests for CreatePaymentSchedule with any type of body
func NewCreatePaymentScheduleRequestWithBody(server string, paymentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPaymentTransactionsRequest generates requests for GetPaymentTransactions
func NewGetPaymentTransactionsRequest(server string, paymentId string, params *GetPaymentTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloseVirtualAccountRequest generates requests for CloseVirtualAccount
func NewCloseVirtualAccountRequest(server string, paymentId string, params *CloseVirtualAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "paymentId", runtime.ParamLocationPath, paymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payments/%s/virtual-account/close", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StoreId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storeId", runtime.ParamLocationQuery, *params.StoreId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformAccountTransfersRequest calls the generic GetPlatformAccountTransfers builder with application/json body
func NewGetPlatformAccountTransfersRequest(server string, params *GetPlatformAccountTransfersParams, body GetPlatformAccountTransfersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformAccountTransfersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformAccountTransfersRequestWithBody generates requests for GetPlatformAccountTransfers with any type of body
func NewGetPlatformAccountTransfersRequestWithBody(server string, params *GetPlatformAccountTransfersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/account-transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformAdditionalFeePoliciesRequest calls the generic GetPlatformAdditionalFeePolicies builder with application/json body
func NewGetPlatformAdditionalFeePoliciesRequest(server string, params *GetPlatformAdditionalFeePoliciesParams, body GetPlatformAdditionalFeePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformAdditionalFeePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformAdditionalFeePoliciesRequestWithBody generates requests for GetPlatformAdditionalFeePolicies with any type of body
func NewGetPlatformAdditionalFeePoliciesRequestWithBody(server string, params *GetPlatformAdditionalFeePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformAdditionalFeePolicyRequest calls the generic CreatePlatformAdditionalFeePolicy builder with application/json body
func NewCreatePlatformAdditionalFeePolicyRequest(server string, params *CreatePlatformAdditionalFeePolicyParams, body CreatePlatformAdditionalFeePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformAdditionalFeePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformAdditionalFeePolicyRequestWithBody generates requests for CreatePlatformAdditionalFeePolicy with any type of body
func NewCreatePlatformAdditionalFeePolicyRequestWithBody(server string, params *CreatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformAdditionalFeePolicyRequest generates requests for GetPlatformAdditionalFeePolicy
func NewGetPlatformAdditionalFeePolicyRequest(server string, id string, params *GetPlatformAdditionalFeePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlatformAdditionalFeePolicyRequest calls the generic UpdatePlatformAdditionalFeePolicy builder with application/json body
func NewUpdatePlatformAdditionalFeePolicyRequest(server string, id string, params *UpdatePlatformAdditionalFeePolicyParams, body UpdatePlatformAdditionalFeePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlatformAdditionalFeePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdatePlatformAdditionalFeePolicyRequestWithBody generates requests for UpdatePlatformAdditionalFeePolicy with any type of body
func NewUpdatePlatformAdditionalFeePolicyRequestWithBody(server string, id string, params *UpdatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlatformAdditionalFeePolicyRequest generates requests for ArchivePlatformAdditionalFeePolicy
func NewArchivePlatformAdditionalFeePolicyRequest(server string, id string, params *ArchivePlatformAdditionalFeePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverPlatformAdditionalFeePolicyRequest generates requests for RecoverPlatformAdditionalFeePolicy
func NewRecoverPlatformAdditionalFeePolicyRequest(server string, id string, params *RecoverPlatformAdditionalFeePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelPlatformAdditionalFeePolicyScheduleRequest generates requests for CancelPlatformAdditionalFeePolicySchedule
func NewCancelPlatformAdditionalFeePolicyScheduleRequest(server string, id string, params *CancelPlatformAdditionalFeePolicyScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformAdditionalFeePolicyScheduleRequest generates requests for GetPlatformAdditionalFeePolicySchedule
func NewGetPlatformAdditionalFeePolicyScheduleRequest(server string, id string, params *GetPlatformAdditionalFeePolicyScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleAdditionalFeePolicyRequest calls the generic ScheduleAdditionalFeePolicy builder with application/json body
func NewScheduleAdditionalFeePolicyRequest(server string, id string, params *ScheduleAdditionalFeePolicyParams, body ScheduleAdditionalFeePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduleAdditionalFeePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewScheduleAdditionalFeePolicyRequestWithBody generates requests for ScheduleAdditionalFeePolicy with any type of body
func NewScheduleAdditionalFeePolicyRequestWithBody(server string, id string, params *ScheduleAdditionalFeePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRescheduleAdditionalFeePolicyRequest calls the generic RescheduleAdditionalFeePolicy builder with application/json body
func NewRescheduleAdditionalFeePolicyRequest(server string, id string, params *RescheduleAdditionalFeePolicyParams, body RescheduleAdditionalFeePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRescheduleAdditionalFeePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewRescheduleAdditionalFeePolicyRequestWithBody generates requests for RescheduleAdditionalFeePolicy with any type of body
func NewRescheduleAdditionalFeePolicyRequestWithBody(server string, id string, params *RescheduleAdditionalFeePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/additional-fee-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformAccountHolderRequest generates requests for GetPlatformAccountHolder
func NewGetPlatformAccountHolderRequest(server string, bank Bank, accountNumber string, params *GetPlatformAccountHolderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bank", runtime.ParamLocationPath, bank)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accountNumber", runtime.ParamLocationPath, accountNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/bank-accounts/%s/%s/holder", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Birthdate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "birthdate", runtime.ParamLocationQuery, *params.Birthdate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BusinessRegistrationNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "businessRegistrationNumber", runtime.ParamLocationQuery, *params.BusinessRegistrationNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformBulkAccountTransfersRequest calls the generic GetPlatformBulkAccountTransfers builder with application/json body
func NewGetPlatformBulkAccountTransfersRequest(server string, params *GetPlatformBulkAccountTransfersParams, body GetPlatformBulkAccountTransfersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformBulkAccountTransfersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformBulkAccountTransfersRequestWithBody generates requests for GetPlatformBulkAccountTransfers with any type of body
func NewGetPlatformBulkAccountTransfersRequestWithBody(server string, params *GetPlatformBulkAccountTransfersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/bulk-account-transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformBulkPayoutsRequest calls the generic GetPlatformBulkPayouts builder with application/json body
func NewGetPlatformBulkPayoutsRequest(server string, params *GetPlatformBulkPayoutsParams, body GetPlatformBulkPayoutsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformBulkPayoutsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformBulkPayoutsRequestWithBody generates requests for GetPlatformBulkPayouts with any type of body
func NewGetPlatformBulkPayoutsRequestWithBody(server string, params *GetPlatformBulkPayoutsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/bulk-payouts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformCompanyStateRequest generates requests for GetPlatformCompanyState
func NewGetPlatformCompanyStateRequest(server string, businessRegistrationNumber string, params *GetPlatformCompanyStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "businessRegistrationNumber", runtime.ParamLocationPath, businessRegistrationNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/companies/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformContractsRequest calls the generic GetPlatformContracts builder with application/json body
func NewGetPlatformContractsRequest(server string, params *GetPlatformContractsParams, body GetPlatformContractsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformContractsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformContractsRequestWithBody generates requests for GetPlatformContracts with any type of body
func NewGetPlatformContractsRequestWithBody(server string, params *GetPlatformContractsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformContractRequest calls the generic CreatePlatformContract builder with application/json body
func NewCreatePlatformContractRequest(server string, params *CreatePlatformContractParams, body CreatePlatformContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformContractRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformContractRequestWithBody generates requests for CreatePlatformContract with any type of body
func NewCreatePlatformContractRequestWithBody(server string, params *CreatePlatformContractParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformContractRequest generates requests for GetPlatformContract
func NewGetPlatformContractRequest(server string, id string, params *GetPlatformContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlatformContractRequest calls the generic UpdatePlatformContract builder with application/json body
func NewUpdatePlatformContractRequest(server string, id string, params *UpdatePlatformContractParams, body UpdatePlatformContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlatformContractRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdatePlatformContractRequestWithBody generates requests for UpdatePlatformContract with any type of body
func NewUpdatePlatformContractRequestWithBody(server string, id string, params *UpdatePlatformContractParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlatformContractRequest generates requests for ArchivePlatformContract
func NewArchivePlatformContractRequest(server string, id string, params *ArchivePlatformContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverPlatformContractRequest generates requests for RecoverPlatformContract
func NewRecoverPlatformContractRequest(server string, id string, params *RecoverPlatformContractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelPlatformContractScheduleRequest generates requests for CancelPlatformContractSchedule
func NewCancelPlatformContractScheduleRequest(server string, id string, params *CancelPlatformContractScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformContractScheduleRequest generates requests for GetPlatformContractSchedule
func NewGetPlatformContractScheduleRequest(server string, id string, params *GetPlatformContractScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleContractRequest calls the generic ScheduleContract builder with application/json body
func NewScheduleContractRequest(server string, id string, params *ScheduleContractParams, body ScheduleContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduleContractRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewScheduleContractRequestWithBody generates requests for ScheduleContract with any type of body
func NewScheduleContractRequestWithBody(server string, id string, params *ScheduleContractParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRescheduleContractRequest calls the generic RescheduleContract builder with application/json body
func NewRescheduleContractRequest(server string, id string, params *RescheduleContractParams, body RescheduleContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRescheduleContractRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewRescheduleContractRequestWithBody generates requests for RescheduleContract with any type of body
func NewRescheduleContractRequestWithBody(server string, id string, params *RescheduleContractParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/contracts/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformDiscountSharePoliciesRequest calls the generic GetPlatformDiscountSharePolicies builder with application/json body
func NewGetPlatformDiscountSharePoliciesRequest(server string, params *GetPlatformDiscountSharePoliciesParams, body GetPlatformDiscountSharePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformDiscountSharePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformDiscountSharePoliciesRequestWithBody generates requests for GetPlatformDiscountSharePolicies with any type of body
func NewGetPlatformDiscountSharePoliciesRequestWithBody(server string, params *GetPlatformDiscountSharePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformDiscountSharePolicyRequest calls the generic CreatePlatformDiscountSharePolicy builder with application/json body
func NewCreatePlatformDiscountSharePolicyRequest(server string, params *CreatePlatformDiscountSharePolicyParams, body CreatePlatformDiscountSharePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformDiscountSharePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformDiscountSharePolicyRequestWithBody generates requests for CreatePlatformDiscountSharePolicy with any type of body
func NewCreatePlatformDiscountSharePolicyRequestWithBody(server string, params *CreatePlatformDiscountSharePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformDiscountSharePolicyRequest generates requests for GetPlatformDiscountSharePolicy
func NewGetPlatformDiscountSharePolicyRequest(server string, id string, params *GetPlatformDiscountSharePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlatformDiscountSharePolicyRequest calls the generic UpdatePlatformDiscountSharePolicy builder with application/json body
func NewUpdatePlatformDiscountSharePolicyRequest(server string, id string, params *UpdatePlatformDiscountSharePolicyParams, body UpdatePlatformDiscountSharePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlatformDiscountSharePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdatePlatformDiscountSharePolicyRequestWithBody generates requests for UpdatePlatformDiscountSharePolicy with any type of body
func NewUpdatePlatformDiscountSharePolicyRequestWithBody(server string, id string, params *UpdatePlatformDiscountSharePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlatformDiscountSharePolicyRequest generates requests for ArchivePlatformDiscountSharePolicy
func NewArchivePlatformDiscountSharePolicyRequest(server string, id string, params *ArchivePlatformDiscountSharePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverPlatformDiscountSharePolicyRequest generates requests for RecoverPlatformDiscountSharePolicy
func NewRecoverPlatformDiscountSharePolicyRequest(server string, id string, params *RecoverPlatformDiscountSharePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelPlatformDiscountSharePolicyScheduleRequest generates requests for CancelPlatformDiscountSharePolicySchedule
func NewCancelPlatformDiscountSharePolicyScheduleRequest(server string, id string, params *CancelPlatformDiscountSharePolicyScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformDiscountSharePolicyScheduleRequest generates requests for GetPlatformDiscountSharePolicySchedule
func NewGetPlatformDiscountSharePolicyScheduleRequest(server string, id string, params *GetPlatformDiscountSharePolicyScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScheduleDiscountSharePolicyRequest calls the generic ScheduleDiscountSharePolicy builder with application/json body
func NewScheduleDiscountSharePolicyRequest(server string, id string, params *ScheduleDiscountSharePolicyParams, body ScheduleDiscountSharePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScheduleDiscountSharePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewScheduleDiscountSharePolicyRequestWithBody generates requests for ScheduleDiscountSharePolicy with any type of body
func NewScheduleDiscountSharePolicyRequestWithBody(server string, id string, params *ScheduleDiscountSharePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRescheduleDiscountSharePolicyRequest calls the generic RescheduleDiscountSharePolicy builder with application/json body
func NewRescheduleDiscountSharePolicyRequest(server string, id string, params *RescheduleDiscountSharePolicyParams, body RescheduleDiscountSharePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRescheduleDiscountSharePolicyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewRescheduleDiscountSharePolicyRequestWithBody generates requests for RescheduleDiscountSharePolicy with any type of body
func NewRescheduleDiscountSharePolicyRequestWithBody(server string, id string, params *RescheduleDiscountSharePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policies/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformDiscountSharePolicyFilterOptionsRequest generates requests for GetPlatformDiscountSharePolicyFilterOptions
func NewGetPlatformDiscountSharePolicyFilterOptionsRequest(server string, params *GetPlatformDiscountSharePolicyFilterOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/discount-share-policy-filter-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isArchived", runtime.ParamLocationQuery, *params.IsArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformPartnerFilterOptionsRequest generates requests for GetPlatformPartnerFilterOptions
func NewGetPlatformPartnerFilterOptionsRequest(server string, params *GetPlatformPartnerFilterOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partner-filter-options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isArchived", runtime.ParamLocationQuery, *params.IsArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformPartnerSettlementsRequest calls the generic GetPlatformPartnerSettlements builder with application/json body
func NewGetPlatformPartnerSettlementsRequest(server string, params *GetPlatformPartnerSettlementsParams, body GetPlatformPartnerSettlementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformPartnerSettlementsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformPartnerSettlementsRequestWithBody generates requests for GetPlatformPartnerSettlements with any type of body
func NewGetPlatformPartnerSettlementsRequestWithBody(server string, params *GetPlatformPartnerSettlementsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partner-settlements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformPartnersRequest calls the generic GetPlatformPartners builder with application/json body
func NewGetPlatformPartnersRequest(server string, params *GetPlatformPartnersParams, body GetPlatformPartnersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformPartnersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformPartnersRequestWithBody generates requests for GetPlatformPartners with any type of body
func NewGetPlatformPartnersRequestWithBody(server string, params *GetPlatformPartnersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformPartnerRequest calls the generic CreatePlatformPartner builder with application/json body
func NewCreatePlatformPartnerRequest(server string, params *CreatePlatformPartnerParams, body CreatePlatformPartnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformPartnerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformPartnerRequestWithBody generates requests for CreatePlatformPartner with any type of body
func NewCreatePlatformPartnerRequestWithBody(server string, params *CreatePlatformPartnerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformPartnersRequest calls the generic CreatePlatformPartners builder with application/json body
func NewCreatePlatformPartnersRequest(server string, params *CreatePlatformPartnersParams, body CreatePlatformPartnersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformPartnersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformPartnersRequestWithBody generates requests for CreatePlatformPartners with any type of body
func NewCreatePlatformPartnersRequestWithBody(server string, params *CreatePlatformPartnersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectBulkPartnerMemberCompanyRequest calls the generic ConnectBulkPartnerMemberCompany builder with application/json body
func NewConnectBulkPartnerMemberCompanyRequest(server string, params *ConnectBulkPartnerMemberCompanyParams, body ConnectBulkPartnerMemberCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectBulkPartnerMemberCompanyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewConnectBulkPartnerMemberCompanyRequestWithBody generates requests for ConnectBulkPartnerMemberCompany with any type of body
func NewConnectBulkPartnerMemberCompanyRequestWithBody(server string, params *ConnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/member-company-connect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectPartnerMemberCompanyRequest generates requests for ConnectPartnerMemberCompany
func NewConnectPartnerMemberCompanyRequest(server string, id string, params *ConnectPartnerMemberCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/member-company-connect/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisconnectBulkPartnerMemberCompanyRequest calls the generic DisconnectBulkPartnerMemberCompany builder with application/json body
func NewDisconnectBulkPartnerMemberCompanyRequest(server string, params *DisconnectBulkPartnerMemberCompanyParams, body DisconnectBulkPartnerMemberCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisconnectBulkPartnerMemberCompanyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDisconnectBulkPartnerMemberCompanyRequestWithBody generates requests for DisconnectBulkPartnerMemberCompany with any type of body
func NewDisconnectBulkPartnerMemberCompanyRequestWithBody(server string, params *DisconnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/member-company-disconnect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisconnectPartnerMemberCompanyRequest generates requests for DisconnectPartnerMemberCompany
func NewDisconnectPartnerMemberCompanyRequest(server string, id string, params *DisconnectPartnerMemberCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/member-company-disconnect/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchedulePlatformPartnersRequest calls the generic SchedulePlatformPartners builder with application/json body
func NewSchedulePlatformPartnersRequest(server string, params *SchedulePlatformPartnersParams, body SchedulePlatformPartnersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchedulePlatformPartnersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSchedulePlatformPartnersRequestWithBody generates requests for SchedulePlatformPartners with any type of body
func NewSchedulePlatformPartnersRequestWithBody(server string, params *SchedulePlatformPartnersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformPartnerRequest generates requests for GetPlatformPartner
func NewGetPlatformPartnerRequest(server string, id string, params *GetPlatformPartnerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlatformPartnerRequest calls the generic UpdatePlatformPartner builder with application/json body
func NewUpdatePlatformPartnerRequest(server string, id string, params *UpdatePlatformPartnerParams, body UpdatePlatformPartnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlatformPartnerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdatePlatformPartnerRequestWithBody generates requests for UpdatePlatformPartner with any type of body
func NewUpdatePlatformPartnerRequestWithBody(server string, id string, params *UpdatePlatformPartnerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlatformPartnerRequest generates requests for ArchivePlatformPartner
func NewArchivePlatformPartnerRequest(server string, id string, params *ArchivePlatformPartnerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecoverPlatformPartnerRequest generates requests for RecoverPlatformPartner
func NewRecoverPlatformPartnerRequest(server string, id string, params *RecoverPlatformPartnerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/recover", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelPlatformPartnerScheduleRequest generates requests for CancelPlatformPartnerSchedule
func NewCancelPlatformPartnerScheduleRequest(server string, id string, params *CancelPlatformPartnerScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformPartnerScheduleRequest generates requests for GetPlatformPartnerSchedule
func NewGetPlatformPartnerScheduleRequest(server string, id string, params *GetPlatformPartnerScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchedulePartnerRequest calls the generic SchedulePartner builder with application/json body
func NewSchedulePartnerRequest(server string, id string, params *SchedulePartnerParams, body SchedulePartnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchedulePartnerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewSchedulePartnerRequestWithBody generates requests for SchedulePartner with any type of body
func NewSchedulePartnerRequestWithBody(server string, id string, params *SchedulePartnerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReschedulePartnerRequest calls the generic ReschedulePartner builder with application/json body
func NewReschedulePartnerRequest(server string, id string, params *ReschedulePartnerParams, body ReschedulePartnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReschedulePartnerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewReschedulePartnerRequestWithBody generates requests for ReschedulePartner with any type of body
func NewReschedulePartnerRequestWithBody(server string, id string, params *ReschedulePartnerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/partners/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformPayoutsRequest calls the generic GetPlatformPayouts builder with application/json body
func NewGetPlatformPayoutsRequest(server string, params *GetPlatformPayoutsParams, body GetPlatformPayoutsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformPayoutsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformPayoutsRequestWithBody generates requests for GetPlatformPayouts with any type of body
func NewGetPlatformPayoutsRequestWithBody(server string, params *GetPlatformPayoutsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/payouts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformSettingRequest generates requests for GetPlatformSetting
func NewGetPlatformSettingRequest(server string, params *GetPlatformSettingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/setting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlatformSettingRequest calls the generic UpdatePlatformSetting builder with application/json body
func NewUpdatePlatformSettingRequest(server string, params *UpdatePlatformSettingParams, body UpdatePlatformSettingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlatformSettingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdatePlatformSettingRequestWithBody generates requests for UpdatePlatformSetting with any type of body
func NewUpdatePlatformSettingRequestWithBody(server string, params *UpdatePlatformSettingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/setting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlatformTransferSummariesRequest calls the generic GetPlatformTransferSummaries builder with application/json body
func NewGetPlatformTransferSummariesRequest(server string, params *GetPlatformTransferSummariesParams, body GetPlatformTransferSummariesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPlatformTransferSummariesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPlatformTransferSummariesRequestWithBody generates requests for GetPlatformTransferSummaries with any type of body
func NewGetPlatformTransferSummariesRequestWithBody(server string, params *GetPlatformTransferSummariesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfer-summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadPlatformTransferSheetRequest calls the generic DownloadPlatformTransferSheet builder with application/json body
func NewDownloadPlatformTransferSheetRequest(server string, params *DownloadPlatformTransferSheetParams, body DownloadPlatformTransferSheetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDownloadPlatformTransferSheetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDownloadPlatformTransferSheetRequestWithBody generates requests for DownloadPlatformTransferSheet with any type of body
func NewDownloadPlatformTransferSheetRequestWithBody(server string, params *DownloadPlatformTransferSheetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfer-summaries/sheet-file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequestBody != nil {

			if queryParamBuf, err := json.Marshal(*params.RequestBody); err != nil {
				return nil, err
			} else {
				queryValues.Add("requestBody", string(queryParamBuf))
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformManualTransferRequest calls the generic CreatePlatformManualTransfer builder with application/json body
func NewCreatePlatformManualTransferRequest(server string, params *CreatePlatformManualTransferParams, body CreatePlatformManualTransferJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformManualTransferRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformManualTransferRequestWithBody generates requests for CreatePlatformManualTransfer with any type of body
func NewCreatePlatformManualTransferRequestWithBody(server string, params *CreatePlatformManualTransferParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfers/manual")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformOrderTransferRequest calls the generic CreatePlatformOrderTransfer builder with application/json body
func NewCreatePlatformOrderTransferRequest(server string, params *CreatePlatformOrderTransferParams, body CreatePlatformOrderTransferJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformOrderTransferRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformOrderTransferRequestWithBody generates requests for CreatePlatformOrderTransfer with any type of body
func NewCreatePlatformOrderTransferRequestWithBody(server string, params *CreatePlatformOrderTransferParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfers/order")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePlatformOrderCancelTransferRequest calls the generic CreatePlatformOrderCancelTransfer builder with application/json body
func NewCreatePlatformOrderCancelTransferRequest(server string, params *CreatePlatformOrderCancelTransferParams, body CreatePlatformOrderCancelTransferJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlatformOrderCancelTransferRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlatformOrderCancelTransferRequestWithBody generates requests for CreatePlatformOrderCancelTransfer with any type of body
func NewCreatePlatformOrderCancelTransferRequestWithBody(server string, params *CreatePlatformOrderCancelTransferParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfers/order-cancel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePlatformTransferRequest generates requests for DeletePlatformTransfer
func NewDeletePlatformTransferRequest(server string, id string, params *DeletePlatformTransferParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformTransferRequest generates requests for GetPlatformTransfer
func NewGetPlatformTransferRequest(server string, id string, params *GetPlatformTransferParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/transfers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Test != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test", runtime.ParamLocationQuery, *params.Test); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPromotionRequest generates requests for GetPromotion
func NewGetPromotionRequest(server string, promotionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "promotionId", runtime.ParamLocationPath, promotionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/promotions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetB2bBulkTaxInvoiceWithResponse request
	GetB2bBulkTaxInvoiceWithResponse(ctx context.Context, bulkTaxInvoiceId string, params *GetB2bBulkTaxInvoiceParams, reqEditors ...RequestEditorFn) (*GetB2bBulkTaxInvoiceHTTPResponse, error)

	// GetB2bBusinessInfosWithBodyWithResponse request with any body
	GetB2bBusinessInfosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetB2bBusinessInfosHTTPResponse, error)

	GetB2bBusinessInfosWithResponse(ctx context.Context, body GetB2bBusinessInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*GetB2bBusinessInfosHTTPResponse, error)

	// CreateB2bFileUploadUrlWithBodyWithResponse request with any body
	CreateB2bFileUploadUrlWithBodyWithResponse(ctx context.Context, params *CreateB2bFileUploadUrlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateB2bFileUploadUrlHTTPResponse, error)

	CreateB2bFileUploadUrlWithResponse(ctx context.Context, params *CreateB2bFileUploadUrlParams, body CreateB2bFileUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateB2bFileUploadUrlHTTPResponse, error)

	// GetB2bTaxInvoicesWithBodyWithResponse request with any body
	GetB2bTaxInvoicesWithBodyWithResponse(ctx context.Context, params *GetB2bTaxInvoicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicesHTTPResponse, error)

	GetB2bTaxInvoicesWithResponse(ctx context.Context, params *GetB2bTaxInvoicesParams, body GetB2bTaxInvoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicesHTTPResponse, error)

	// DownloadB2bTaxInvoicesSheetWithBodyWithResponse request with any body
	DownloadB2bTaxInvoicesSheetWithBodyWithResponse(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadB2bTaxInvoicesSheetHTTPResponse, error)

	DownloadB2bTaxInvoicesSheetWithResponse(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, body DownloadB2bTaxInvoicesSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadB2bTaxInvoicesSheetHTTPResponse, error)

	// DraftB2bTaxInvoiceWithBodyWithResponse request with any body
	DraftB2bTaxInvoiceWithBodyWithResponse(ctx context.Context, params *DraftB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DraftB2bTaxInvoiceHTTPResponse, error)

	DraftB2bTaxInvoiceWithResponse(ctx context.Context, params *DraftB2bTaxInvoiceParams, body DraftB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*DraftB2bTaxInvoiceHTTPResponse, error)

	// UpdateB2bTaxInvoiceDraftWithBodyWithResponse request with any body
	UpdateB2bTaxInvoiceDraftWithBodyWithResponse(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateB2bTaxInvoiceDraftHTTPResponse, error)

	UpdateB2bTaxInvoiceDraftWithResponse(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, body UpdateB2bTaxInvoiceDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateB2bTaxInvoiceDraftHTTPResponse, error)

	// IssueB2bTaxInvoiceImmediatelyWithBodyWithResponse request with any body
	IssueB2bTaxInvoiceImmediatelyWithBodyWithResponse(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceImmediatelyHTTPResponse, error)

	IssueB2bTaxInvoiceImmediatelyWithResponse(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, body IssueB2bTaxInvoiceImmediatelyJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceImmediatelyHTTPResponse, error)

	// RequestB2bTaxInvoiceReverseIssuanceWithBodyWithResponse request with any body
	RequestB2bTaxInvoiceReverseIssuanceWithBodyWithResponse(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceReverseIssuanceHTTPResponse, error)

	RequestB2bTaxInvoiceReverseIssuanceWithResponse(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, body RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceReverseIssuanceHTTPResponse, error)

	// DeleteB2bTaxInvoiceWithResponse request
	DeleteB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *DeleteB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*DeleteB2bTaxInvoiceHTTPResponse, error)

	// GetB2bTaxInvoiceWithResponse request
	GetB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoiceHTTPResponse, error)

	// AttachB2bTaxInvoiceFileWithBodyWithResponse request with any body
	AttachB2bTaxInvoiceFileWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachB2bTaxInvoiceFileHTTPResponse, error)

	AttachB2bTaxInvoiceFileWithResponse(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, body AttachB2bTaxInvoiceFileJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachB2bTaxInvoiceFileHTTPResponse, error)

	// GetB2bTaxInvoiceAttachmentsWithResponse request
	GetB2bTaxInvoiceAttachmentsWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoiceAttachmentsHTTPResponse, error)

	// DeleteB2bTaxInvoiceAttachmentWithResponse request
	DeleteB2bTaxInvoiceAttachmentWithResponse(ctx context.Context, taxInvoiceKey string, attachmentId string, params *DeleteB2bTaxInvoiceAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteB2bTaxInvoiceAttachmentHTTPResponse, error)

	// CancelB2bTaxInvoiceIssuanceWithBodyWithResponse request with any body
	CancelB2bTaxInvoiceIssuanceWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceIssuanceHTTPResponse, error)

	CancelB2bTaxInvoiceIssuanceWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, body CancelB2bTaxInvoiceIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceIssuanceHTTPResponse, error)

	// CancelB2bTaxInvoiceRequestWithBodyWithResponse request with any body
	CancelB2bTaxInvoiceRequestWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceRequestHTTPResponse, error)

	CancelB2bTaxInvoiceRequestWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, body CancelB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceRequestHTTPResponse, error)

	// IssueB2bTaxInvoiceWithBodyWithResponse request with any body
	IssueB2bTaxInvoiceWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceHTTPResponse, error)

	IssueB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, body IssueB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceHTTPResponse, error)

	// GetB2bTaxInvoicePdfDownloadUrlWithResponse request
	GetB2bTaxInvoicePdfDownloadUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePdfDownloadUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePdfDownloadUrlHTTPResponse, error)

	// GetB2bTaxInvoicePopupUrlWithResponse request
	GetB2bTaxInvoicePopupUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePopupUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePopupUrlHTTPResponse, error)

	// GetB2bTaxInvoicePrintUrlWithResponse request
	GetB2bTaxInvoicePrintUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePrintUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePrintUrlHTTPResponse, error)

	// RefuseB2bTaxInvoiceRequestWithBodyWithResponse request with any body
	RefuseB2bTaxInvoiceRequestWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefuseB2bTaxInvoiceRequestHTTPResponse, error)

	RefuseB2bTaxInvoiceRequestWithResponse(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, body RefuseB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*RefuseB2bTaxInvoiceRequestHTTPResponse, error)

	// RequestB2bTaxInvoiceWithResponse request
	RequestB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *RequestB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceHTTPResponse, error)

	// SendToNtsB2bTaxInvoiceWithResponse request
	SendToNtsB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *SendToNtsB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*SendToNtsB2bTaxInvoiceHTTPResponse, error)

	// GetBankInfosWithResponse request
	GetBankInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBankInfosHTTPResponse, error)

	// GetBillingKeyInfosWithBodyWithResponse request with any body
	GetBillingKeyInfosWithBodyWithResponse(ctx context.Context, params *GetBillingKeyInfosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBillingKeyInfosHTTPResponse, error)

	GetBillingKeyInfosWithResponse(ctx context.Context, params *GetBillingKeyInfosParams, body GetBillingKeyInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBillingKeyInfosHTTPResponse, error)

	// IssueBillingKeyWithBodyWithResponse request with any body
	IssueBillingKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueBillingKeyHTTPResponse, error)

	IssueBillingKeyWithResponse(ctx context.Context, body IssueBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueBillingKeyHTTPResponse, error)

	// ConfirmBillingKeyWithBodyWithResponse request with any body
	ConfirmBillingKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyHTTPResponse, error)

	ConfirmBillingKeyWithResponse(ctx context.Context, body ConfirmBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyHTTPResponse, error)

	// ConfirmBillingKeyIssueAndPayWithBodyWithResponse request with any body
	ConfirmBillingKeyIssueAndPayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyIssueAndPayHTTPResponse, error)

	ConfirmBillingKeyIssueAndPayWithResponse(ctx context.Context, body ConfirmBillingKeyIssueAndPayJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyIssueAndPayHTTPResponse, error)

	// DeleteBillingKeyWithResponse request
	DeleteBillingKeyWithResponse(ctx context.Context, billingKey string, params *DeleteBillingKeyParams, reqEditors ...RequestEditorFn) (*DeleteBillingKeyHTTPResponse, error)

	// GetBillingKeyInfoWithResponse request
	GetBillingKeyInfoWithResponse(ctx context.Context, billingKey string, params *GetBillingKeyInfoParams, reqEditors ...RequestEditorFn) (*GetBillingKeyInfoHTTPResponse, error)

	// GetCashReceiptsWithBodyWithResponse request with any body
	GetCashReceiptsWithBodyWithResponse(ctx context.Context, params *GetCashReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetCashReceiptsHTTPResponse, error)

	GetCashReceiptsWithResponse(ctx context.Context, params *GetCashReceiptsParams, body GetCashReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetCashReceiptsHTTPResponse, error)

	// IssueCashReceiptWithBodyWithResponse request with any body
	IssueCashReceiptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCashReceiptHTTPResponse, error)

	IssueCashReceiptWithResponse(ctx context.Context, body IssueCashReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCashReceiptHTTPResponse, error)

	// GetIdentityVerificationsWithBodyWithResponse request with any body
	GetIdentityVerificationsWithBodyWithResponse(ctx context.Context, params *GetIdentityVerificationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetIdentityVerificationsHTTPResponse, error)

	GetIdentityVerificationsWithResponse(ctx context.Context, params *GetIdentityVerificationsParams, body GetIdentityVerificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetIdentityVerificationsHTTPResponse, error)

	// GetIdentityVerificationWithResponse request
	GetIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, params *GetIdentityVerificationParams, reqEditors ...RequestEditorFn) (*GetIdentityVerificationHTTPResponse, error)

	// ConfirmIdentityVerificationWithBodyWithResponse request with any body
	ConfirmIdentityVerificationWithBodyWithResponse(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmIdentityVerificationHTTPResponse, error)

	ConfirmIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, body ConfirmIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmIdentityVerificationHTTPResponse, error)

	// ResendIdentityVerificationWithResponse request
	ResendIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, params *ResendIdentityVerificationParams, reqEditors ...RequestEditorFn) (*ResendIdentityVerificationHTTPResponse, error)

	// SendIdentityVerificationWithBodyWithResponse request with any body
	SendIdentityVerificationWithBodyWithResponse(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendIdentityVerificationHTTPResponse, error)

	SendIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, body SendIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendIdentityVerificationHTTPResponse, error)

	// GetKakaopayPaymentOrderWithResponse request
	GetKakaopayPaymentOrderWithResponse(ctx context.Context, params *GetKakaopayPaymentOrderParams, reqEditors ...RequestEditorFn) (*GetKakaopayPaymentOrderHTTPResponse, error)

	// LoginViaApiSecretWithBodyWithResponse request with any body
	LoginViaApiSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginViaApiSecretHTTPResponse, error)

	LoginViaApiSecretWithResponse(ctx context.Context, body LoginViaApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginViaApiSecretHTTPResponse, error)

	// GetAllPaymentEventsByCursorWithBodyWithResponse request with any body
	GetAllPaymentEventsByCursorWithBodyWithResponse(ctx context.Context, params *GetAllPaymentEventsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAllPaymentEventsByCursorHTTPResponse, error)

	GetAllPaymentEventsByCursorWithResponse(ctx context.Context, params *GetAllPaymentEventsByCursorParams, body GetAllPaymentEventsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAllPaymentEventsByCursorHTTPResponse, error)

	// RevokePaymentSchedulesWithBodyWithResponse request with any body
	RevokePaymentSchedulesWithBodyWithResponse(ctx context.Context, params *RevokePaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokePaymentSchedulesHTTPResponse, error)

	RevokePaymentSchedulesWithResponse(ctx context.Context, params *RevokePaymentSchedulesParams, body RevokePaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokePaymentSchedulesHTTPResponse, error)

	// GetPaymentSchedulesWithBodyWithResponse request with any body
	GetPaymentSchedulesWithBodyWithResponse(ctx context.Context, params *GetPaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPaymentSchedulesHTTPResponse, error)

	GetPaymentSchedulesWithResponse(ctx context.Context, params *GetPaymentSchedulesParams, body GetPaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPaymentSchedulesHTTPResponse, error)

	// GetPaymentScheduleWithResponse request
	GetPaymentScheduleWithResponse(ctx context.Context, paymentScheduleId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleHTTPResponse, error)

	// GetPaymentsWithBodyWithResponse request with any body
	GetPaymentsWithBodyWithResponse(ctx context.Context, params *GetPaymentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPaymentsHTTPResponse, error)

	GetPaymentsWithResponse(ctx context.Context, params *GetPaymentsParams, body GetPaymentsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPaymentsHTTPResponse, error)

	// GetAllPaymentsByCursorWithBodyWithResponse request with any body
	GetAllPaymentsByCursorWithBodyWithResponse(ctx context.Context, params *GetAllPaymentsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAllPaymentsByCursorHTTPResponse, error)

	GetAllPaymentsByCursorWithResponse(ctx context.Context, params *GetAllPaymentsByCursorParams, body GetAllPaymentsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAllPaymentsByCursorHTTPResponse, error)

	// GetPaymentWithResponse request
	GetPaymentWithResponse(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*GetPaymentHTTPResponse, error)

	// PayWithBillingKeyWithBodyWithResponse request with any body
	PayWithBillingKeyWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PayWithBillingKeyHTTPResponse, error)

	PayWithBillingKeyWithResponse(ctx context.Context, paymentId string, body PayWithBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PayWithBillingKeyHTTPResponse, error)

	// CancelPaymentWithBodyWithResponse request with any body
	CancelPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPaymentHTTPResponse, error)

	CancelPaymentWithResponse(ctx context.Context, paymentId string, body CancelPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPaymentHTTPResponse, error)

	// CapturePaymentWithBodyWithResponse request with any body
	CapturePaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CapturePaymentHTTPResponse, error)

	CapturePaymentWithResponse(ctx context.Context, paymentId string, body CapturePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CapturePaymentHTTPResponse, error)

	// GetCashReceiptByPaymentIdWithResponse request
	GetCashReceiptByPaymentIdWithResponse(ctx context.Context, paymentId string, params *GetCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*GetCashReceiptByPaymentIdHTTPResponse, error)

	// CancelCashReceiptByPaymentIdWithResponse request
	CancelCashReceiptByPaymentIdWithResponse(ctx context.Context, paymentId string, params *CancelCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*CancelCashReceiptByPaymentIdHTTPResponse, error)

	// ConfirmPaymentWithBodyWithResponse request with any body
	ConfirmPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmPaymentHTTPResponse, error)

	ConfirmPaymentWithResponse(ctx context.Context, paymentId string, body ConfirmPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmPaymentHTTPResponse, error)

	// ConfirmEscrowWithBodyWithResponse request with any body
	ConfirmEscrowWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmEscrowHTTPResponse, error)

	ConfirmEscrowWithResponse(ctx context.Context, paymentId string, body ConfirmEscrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmEscrowHTTPResponse, error)

	// ModifyEscrowLogisticsWithBodyWithResponse request with any body
	ModifyEscrowLogisticsWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEscrowLogisticsHTTPResponse, error)

	ModifyEscrowLogisticsWithResponse(ctx context.Context, paymentId string, body ModifyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEscrowLogisticsHTTPResponse, error)

	// ApplyEscrowLogisticsWithBodyWithResponse request with any body
	ApplyEscrowLogisticsWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyEscrowLogisticsHTTPResponse, error)

	ApplyEscrowLogisticsWithResponse(ctx context.Context, paymentId string, body ApplyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyEscrowLogisticsHTTPResponse, error)

	// PayInstantlyWithBodyWithResponse request with any body
	PayInstantlyWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PayInstantlyHTTPResponse, error)

	PayInstantlyWithResponse(ctx context.Context, paymentId string, body PayInstantlyJSONRequestBody, reqEditors ...RequestEditorFn) (*PayInstantlyHTTPResponse, error)

	// PreRegisterPaymentWithBodyWithResponse request with any body
	PreRegisterPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreRegisterPaymentHTTPResponse, error)

	PreRegisterPaymentWithResponse(ctx context.Context, paymentId string, body PreRegisterPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*PreRegisterPaymentHTTPResponse, error)

	// RegisterStoreReceiptWithBodyWithResponse request with any body
	RegisterStoreReceiptWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterStoreReceiptHTTPResponse, error)

	RegisterStoreReceiptWithResponse(ctx context.Context, paymentId string, body RegisterStoreReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterStoreReceiptHTTPResponse, error)

	// ResendWebhookWithBodyWithResponse request with any body
	ResendWebhookWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendWebhookHTTPResponse, error)

	ResendWebhookWithResponse(ctx context.Context, paymentId string, body ResendWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendWebhookHTTPResponse, error)

	// CreatePaymentScheduleWithBodyWithResponse request with any body
	CreatePaymentScheduleWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentScheduleHTTPResponse, error)

	CreatePaymentScheduleWithResponse(ctx context.Context, paymentId string, body CreatePaymentScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentScheduleHTTPResponse, error)

	// GetPaymentTransactionsWithResponse request
	GetPaymentTransactionsWithResponse(ctx context.Context, paymentId string, params *GetPaymentTransactionsParams, reqEditors ...RequestEditorFn) (*GetPaymentTransactionsHTTPResponse, error)

	// CloseVirtualAccountWithResponse request
	CloseVirtualAccountWithResponse(ctx context.Context, paymentId string, params *CloseVirtualAccountParams, reqEditors ...RequestEditorFn) (*CloseVirtualAccountHTTPResponse, error)

	// GetPlatformAccountTransfersWithBodyWithResponse request with any body
	GetPlatformAccountTransfersWithBodyWithResponse(ctx context.Context, params *GetPlatformAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformAccountTransfersHTTPResponse, error)

	GetPlatformAccountTransfersWithResponse(ctx context.Context, params *GetPlatformAccountTransfersParams, body GetPlatformAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformAccountTransfersHTTPResponse, error)

	// GetPlatformAdditionalFeePoliciesWithBodyWithResponse request with any body
	GetPlatformAdditionalFeePoliciesWithBodyWithResponse(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePoliciesHTTPResponse, error)

	GetPlatformAdditionalFeePoliciesWithResponse(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, body GetPlatformAdditionalFeePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePoliciesHTTPResponse, error)

	// CreatePlatformAdditionalFeePolicyWithBodyWithResponse request with any body
	CreatePlatformAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformAdditionalFeePolicyHTTPResponse, error)

	CreatePlatformAdditionalFeePolicyWithResponse(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, body CreatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformAdditionalFeePolicyHTTPResponse, error)

	// GetPlatformAdditionalFeePolicyWithResponse request
	GetPlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePolicyHTTPResponse, error)

	// UpdatePlatformAdditionalFeePolicyWithBodyWithResponse request with any body
	UpdatePlatformAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformAdditionalFeePolicyHTTPResponse, error)

	UpdatePlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, body UpdatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformAdditionalFeePolicyHTTPResponse, error)

	// ArchivePlatformAdditionalFeePolicyWithResponse request
	ArchivePlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *ArchivePlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*ArchivePlatformAdditionalFeePolicyHTTPResponse, error)

	// RecoverPlatformAdditionalFeePolicyWithResponse request
	RecoverPlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *RecoverPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*RecoverPlatformAdditionalFeePolicyHTTPResponse, error)

	// CancelPlatformAdditionalFeePolicyScheduleWithResponse request
	CancelPlatformAdditionalFeePolicyScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformAdditionalFeePolicyScheduleHTTPResponse, error)

	// GetPlatformAdditionalFeePolicyScheduleWithResponse request
	GetPlatformAdditionalFeePolicyScheduleWithResponse(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePolicyScheduleHTTPResponse, error)

	// ScheduleAdditionalFeePolicyWithBodyWithResponse request with any body
	ScheduleAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleAdditionalFeePolicyHTTPResponse, error)

	ScheduleAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, body ScheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleAdditionalFeePolicyHTTPResponse, error)

	// RescheduleAdditionalFeePolicyWithBodyWithResponse request with any body
	RescheduleAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleAdditionalFeePolicyHTTPResponse, error)

	RescheduleAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, body RescheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleAdditionalFeePolicyHTTPResponse, error)

	// GetPlatformAccountHolderWithResponse request
	GetPlatformAccountHolderWithResponse(ctx context.Context, bank Bank, accountNumber string, params *GetPlatformAccountHolderParams, reqEditors ...RequestEditorFn) (*GetPlatformAccountHolderHTTPResponse, error)

	// GetPlatformBulkAccountTransfersWithBodyWithResponse request with any body
	GetPlatformBulkAccountTransfersWithBodyWithResponse(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformBulkAccountTransfersHTTPResponse, error)

	GetPlatformBulkAccountTransfersWithResponse(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, body GetPlatformBulkAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformBulkAccountTransfersHTTPResponse, error)

	// GetPlatformBulkPayoutsWithBodyWithResponse request with any body
	GetPlatformBulkPayoutsWithBodyWithResponse(ctx context.Context, params *GetPlatformBulkPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformBulkPayoutsHTTPResponse, error)

	GetPlatformBulkPayoutsWithResponse(ctx context.Context, params *GetPlatformBulkPayoutsParams, body GetPlatformBulkPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformBulkPayoutsHTTPResponse, error)

	// GetPlatformCompanyStateWithResponse request
	GetPlatformCompanyStateWithResponse(ctx context.Context, businessRegistrationNumber string, params *GetPlatformCompanyStateParams, reqEditors ...RequestEditorFn) (*GetPlatformCompanyStateHTTPResponse, error)

	// GetPlatformContractsWithBodyWithResponse request with any body
	GetPlatformContractsWithBodyWithResponse(ctx context.Context, params *GetPlatformContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformContractsHTTPResponse, error)

	GetPlatformContractsWithResponse(ctx context.Context, params *GetPlatformContractsParams, body GetPlatformContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformContractsHTTPResponse, error)

	// CreatePlatformContractWithBodyWithResponse request with any body
	CreatePlatformContractWithBodyWithResponse(ctx context.Context, params *CreatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformContractHTTPResponse, error)

	CreatePlatformContractWithResponse(ctx context.Context, params *CreatePlatformContractParams, body CreatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformContractHTTPResponse, error)

	// GetPlatformContractWithResponse request
	GetPlatformContractWithResponse(ctx context.Context, id string, params *GetPlatformContractParams, reqEditors ...RequestEditorFn) (*GetPlatformContractHTTPResponse, error)

	// UpdatePlatformContractWithBodyWithResponse request with any body
	UpdatePlatformContractWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformContractHTTPResponse, error)

	UpdatePlatformContractWithResponse(ctx context.Context, id string, params *UpdatePlatformContractParams, body UpdatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformContractHTTPResponse, error)

	// ArchivePlatformContractWithResponse request
	ArchivePlatformContractWithResponse(ctx context.Context, id string, params *ArchivePlatformContractParams, reqEditors ...RequestEditorFn) (*ArchivePlatformContractHTTPResponse, error)

	// RecoverPlatformContractWithResponse request
	RecoverPlatformContractWithResponse(ctx context.Context, id string, params *RecoverPlatformContractParams, reqEditors ...RequestEditorFn) (*RecoverPlatformContractHTTPResponse, error)

	// CancelPlatformContractScheduleWithResponse request
	CancelPlatformContractScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformContractScheduleHTTPResponse, error)

	// GetPlatformContractScheduleWithResponse request
	GetPlatformContractScheduleWithResponse(ctx context.Context, id string, params *GetPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformContractScheduleHTTPResponse, error)

	// ScheduleContractWithBodyWithResponse request with any body
	ScheduleContractWithBodyWithResponse(ctx context.Context, id string, params *ScheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleContractHTTPResponse, error)

	ScheduleContractWithResponse(ctx context.Context, id string, params *ScheduleContractParams, body ScheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleContractHTTPResponse, error)

	// RescheduleContractWithBodyWithResponse request with any body
	RescheduleContractWithBodyWithResponse(ctx context.Context, id string, params *RescheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleContractHTTPResponse, error)

	RescheduleContractWithResponse(ctx context.Context, id string, params *RescheduleContractParams, body RescheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleContractHTTPResponse, error)

	// GetPlatformDiscountSharePoliciesWithBodyWithResponse request with any body
	GetPlatformDiscountSharePoliciesWithBodyWithResponse(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePoliciesHTTPResponse, error)

	GetPlatformDiscountSharePoliciesWithResponse(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, body GetPlatformDiscountSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePoliciesHTTPResponse, error)

	// CreatePlatformDiscountSharePolicyWithBodyWithResponse request with any body
	CreatePlatformDiscountSharePolicyWithBodyWithResponse(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformDiscountSharePolicyHTTPResponse, error)

	CreatePlatformDiscountSharePolicyWithResponse(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, body CreatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformDiscountSharePolicyHTTPResponse, error)

	// GetPlatformDiscountSharePolicyWithResponse request
	GetPlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyHTTPResponse, error)

	// UpdatePlatformDiscountSharePolicyWithBodyWithResponse request with any body
	UpdatePlatformDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformDiscountSharePolicyHTTPResponse, error)

	UpdatePlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, body UpdatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformDiscountSharePolicyHTTPResponse, error)

	// ArchivePlatformDiscountSharePolicyWithResponse request
	ArchivePlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *ArchivePlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*ArchivePlatformDiscountSharePolicyHTTPResponse, error)

	// RecoverPlatformDiscountSharePolicyWithResponse request
	RecoverPlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *RecoverPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*RecoverPlatformDiscountSharePolicyHTTPResponse, error)

	// CancelPlatformDiscountSharePolicyScheduleWithResponse request
	CancelPlatformDiscountSharePolicyScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformDiscountSharePolicyScheduleHTTPResponse, error)

	// GetPlatformDiscountSharePolicyScheduleWithResponse request
	GetPlatformDiscountSharePolicyScheduleWithResponse(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyScheduleHTTPResponse, error)

	// ScheduleDiscountSharePolicyWithBodyWithResponse request with any body
	ScheduleDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleDiscountSharePolicyHTTPResponse, error)

	ScheduleDiscountSharePolicyWithResponse(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, body ScheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleDiscountSharePolicyHTTPResponse, error)

	// RescheduleDiscountSharePolicyWithBodyWithResponse request with any body
	RescheduleDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleDiscountSharePolicyHTTPResponse, error)

	RescheduleDiscountSharePolicyWithResponse(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, body RescheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleDiscountSharePolicyHTTPResponse, error)

	// GetPlatformDiscountSharePolicyFilterOptionsWithResponse request
	GetPlatformDiscountSharePolicyFilterOptionsWithResponse(ctx context.Context, params *GetPlatformDiscountSharePolicyFilterOptionsParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse, error)

	// GetPlatformPartnerFilterOptionsWithResponse request
	GetPlatformPartnerFilterOptionsWithResponse(ctx context.Context, params *GetPlatformPartnerFilterOptionsParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerFilterOptionsHTTPResponse, error)

	// GetPlatformPartnerSettlementsWithBodyWithResponse request with any body
	GetPlatformPartnerSettlementsWithBodyWithResponse(ctx context.Context, params *GetPlatformPartnerSettlementsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPartnerSettlementsHTTPResponse, error)

	GetPlatformPartnerSettlementsWithResponse(ctx context.Context, params *GetPlatformPartnerSettlementsParams, body GetPlatformPartnerSettlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPartnerSettlementsHTTPResponse, error)

	// GetPlatformPartnersWithBodyWithResponse request with any body
	GetPlatformPartnersWithBodyWithResponse(ctx context.Context, params *GetPlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPartnersHTTPResponse, error)

	GetPlatformPartnersWithResponse(ctx context.Context, params *GetPlatformPartnersParams, body GetPlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPartnersHTTPResponse, error)

	// CreatePlatformPartnerWithBodyWithResponse request with any body
	CreatePlatformPartnerWithBodyWithResponse(ctx context.Context, params *CreatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformPartnerHTTPResponse, error)

	CreatePlatformPartnerWithResponse(ctx context.Context, params *CreatePlatformPartnerParams, body CreatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformPartnerHTTPResponse, error)

	// CreatePlatformPartnersWithBodyWithResponse request with any body
	CreatePlatformPartnersWithBodyWithResponse(ctx context.Context, params *CreatePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformPartnersHTTPResponse, error)

	CreatePlatformPartnersWithResponse(ctx context.Context, params *CreatePlatformPartnersParams, body CreatePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformPartnersHTTPResponse, error)

	// ConnectBulkPartnerMemberCompanyWithBodyWithResponse request with any body
	ConnectBulkPartnerMemberCompanyWithBodyWithResponse(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectBulkPartnerMemberCompanyHTTPResponse, error)

	ConnectBulkPartnerMemberCompanyWithResponse(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, body ConnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectBulkPartnerMemberCompanyHTTPResponse, error)

	// ConnectPartnerMemberCompanyWithResponse request
	ConnectPartnerMemberCompanyWithResponse(ctx context.Context, id string, params *ConnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*ConnectPartnerMemberCompanyHTTPResponse, error)

	// DisconnectBulkPartnerMemberCompanyWithBodyWithResponse request with any body
	DisconnectBulkPartnerMemberCompanyWithBodyWithResponse(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisconnectBulkPartnerMemberCompanyHTTPResponse, error)

	DisconnectBulkPartnerMemberCompanyWithResponse(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, body DisconnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*DisconnectBulkPartnerMemberCompanyHTTPResponse, error)

	// DisconnectPartnerMemberCompanyWithResponse request
	DisconnectPartnerMemberCompanyWithResponse(ctx context.Context, id string, params *DisconnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*DisconnectPartnerMemberCompanyHTTPResponse, error)

	// SchedulePlatformPartnersWithBodyWithResponse request with any body
	SchedulePlatformPartnersWithBodyWithResponse(ctx context.Context, params *SchedulePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchedulePlatformPartnersHTTPResponse, error)

	SchedulePlatformPartnersWithResponse(ctx context.Context, params *SchedulePlatformPartnersParams, body SchedulePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*SchedulePlatformPartnersHTTPResponse, error)

	// GetPlatformPartnerWithResponse request
	GetPlatformPartnerWithResponse(ctx context.Context, id string, params *GetPlatformPartnerParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerHTTPResponse, error)

	// UpdatePlatformPartnerWithBodyWithResponse request with any body
	UpdatePlatformPartnerWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformPartnerHTTPResponse, error)

	UpdatePlatformPartnerWithResponse(ctx context.Context, id string, params *UpdatePlatformPartnerParams, body UpdatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformPartnerHTTPResponse, error)

	// ArchivePlatformPartnerWithResponse request
	ArchivePlatformPartnerWithResponse(ctx context.Context, id string, params *ArchivePlatformPartnerParams, reqEditors ...RequestEditorFn) (*ArchivePlatformPartnerHTTPResponse, error)

	// RecoverPlatformPartnerWithResponse request
	RecoverPlatformPartnerWithResponse(ctx context.Context, id string, params *RecoverPlatformPartnerParams, reqEditors ...RequestEditorFn) (*RecoverPlatformPartnerHTTPResponse, error)

	// CancelPlatformPartnerScheduleWithResponse request
	CancelPlatformPartnerScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformPartnerScheduleHTTPResponse, error)

	// GetPlatformPartnerScheduleWithResponse request
	GetPlatformPartnerScheduleWithResponse(ctx context.Context, id string, params *GetPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerScheduleHTTPResponse, error)

	// SchedulePartnerWithBodyWithResponse request with any body
	SchedulePartnerWithBodyWithResponse(ctx context.Context, id string, params *SchedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchedulePartnerHTTPResponse, error)

	SchedulePartnerWithResponse(ctx context.Context, id string, params *SchedulePartnerParams, body SchedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*SchedulePartnerHTTPResponse, error)

	// ReschedulePartnerWithBodyWithResponse request with any body
	ReschedulePartnerWithBodyWithResponse(ctx context.Context, id string, params *ReschedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReschedulePartnerHTTPResponse, error)

	ReschedulePartnerWithResponse(ctx context.Context, id string, params *ReschedulePartnerParams, body ReschedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReschedulePartnerHTTPResponse, error)

	// GetPlatformPayoutsWithBodyWithResponse request with any body
	GetPlatformPayoutsWithBodyWithResponse(ctx context.Context, params *GetPlatformPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPayoutsHTTPResponse, error)

	GetPlatformPayoutsWithResponse(ctx context.Context, params *GetPlatformPayoutsParams, body GetPlatformPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPayoutsHTTPResponse, error)

	// GetPlatformSettingWithResponse request
	GetPlatformSettingWithResponse(ctx context.Context, params *GetPlatformSettingParams, reqEditors ...RequestEditorFn) (*GetPlatformSettingHTTPResponse, error)

	// UpdatePlatformSettingWithBodyWithResponse request with any body
	UpdatePlatformSettingWithBodyWithResponse(ctx context.Context, params *UpdatePlatformSettingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformSettingHTTPResponse, error)

	UpdatePlatformSettingWithResponse(ctx context.Context, params *UpdatePlatformSettingParams, body UpdatePlatformSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformSettingHTTPResponse, error)

	// GetPlatformTransferSummariesWithBodyWithResponse request with any body
	GetPlatformTransferSummariesWithBodyWithResponse(ctx context.Context, params *GetPlatformTransferSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformTransferSummariesHTTPResponse, error)

	GetPlatformTransferSummariesWithResponse(ctx context.Context, params *GetPlatformTransferSummariesParams, body GetPlatformTransferSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformTransferSummariesHTTPResponse, error)

	// DownloadPlatformTransferSheetWithBodyWithResponse request with any body
	DownloadPlatformTransferSheetWithBodyWithResponse(ctx context.Context, params *DownloadPlatformTransferSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadPlatformTransferSheetHTTPResponse, error)

	DownloadPlatformTransferSheetWithResponse(ctx context.Context, params *DownloadPlatformTransferSheetParams, body DownloadPlatformTransferSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadPlatformTransferSheetHTTPResponse, error)

	// CreatePlatformManualTransferWithBodyWithResponse request with any body
	CreatePlatformManualTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformManualTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformManualTransferHTTPResponse, error)

	CreatePlatformManualTransferWithResponse(ctx context.Context, params *CreatePlatformManualTransferParams, body CreatePlatformManualTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformManualTransferHTTPResponse, error)

	// CreatePlatformOrderTransferWithBodyWithResponse request with any body
	CreatePlatformOrderTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformOrderTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformOrderTransferHTTPResponse, error)

	CreatePlatformOrderTransferWithResponse(ctx context.Context, params *CreatePlatformOrderTransferParams, body CreatePlatformOrderTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformOrderTransferHTTPResponse, error)

	// CreatePlatformOrderCancelTransferWithBodyWithResponse request with any body
	CreatePlatformOrderCancelTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformOrderCancelTransferHTTPResponse, error)

	CreatePlatformOrderCancelTransferWithResponse(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, body CreatePlatformOrderCancelTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformOrderCancelTransferHTTPResponse, error)

	// DeletePlatformTransferWithResponse request
	DeletePlatformTransferWithResponse(ctx context.Context, id string, params *DeletePlatformTransferParams, reqEditors ...RequestEditorFn) (*DeletePlatformTransferHTTPResponse, error)

	// GetPlatformTransferWithResponse request
	GetPlatformTransferWithResponse(ctx context.Context, id string, params *GetPlatformTransferParams, reqEditors ...RequestEditorFn) (*GetPlatformTransferHTTPResponse, error)

	// GetPromotionWithResponse request
	GetPromotionWithResponse(ctx context.Context, promotionId string, reqEditors ...RequestEditorFn) (*GetPromotionHTTPResponse, error)

	// RefreshTokenWithBodyWithResponse request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenHTTPResponse, error)

	RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenHTTPResponse, error)
}

type GetB2bBulkTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *B2bBulkTaxInvoice
	JSON400      *GetB2bBulkTaxInvoiceError
	JSON401      *GetB2bBulkTaxInvoiceError
	JSON403      *GetB2bBulkTaxInvoiceError
	JSON404      *GetB2bBulkTaxInvoiceError
	JSON502      *GetB2bBulkTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r GetB2bBulkTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bBulkTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bBusinessInfosHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bBusinessInfosResponse
	JSON400      *GetB2bBusinessInfosError
	JSON401      *GetB2bBusinessInfosError
	JSON403      *GetB2bBusinessInfosError
	JSON502      *GetB2bBusinessInfosError
}

// Status returns HTTPResponse.Status
func (r GetB2bBusinessInfosHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bBusinessInfosHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateB2bFileUploadUrlHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateB2bFileUploadUrlPayload
	JSON400      *CreateB2bFileUploadUrlError
	JSON401      *CreateB2bFileUploadUrlError
	JSON403      *CreateB2bFileUploadUrlError
	JSON502      *CreateB2bFileUploadUrlError
}

// Status returns HTTPResponse.Status
func (r CreateB2bFileUploadUrlHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateB2bFileUploadUrlHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoicesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bTaxInvoicesResponse
	JSON400      *GetB2bTaxInvoicesError
	JSON401      *GetB2bTaxInvoicesError
	JSON403      *GetB2bTaxInvoicesError
	JSON404      *GetB2bTaxInvoicesError
	JSON502      *GetB2bTaxInvoicesError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoicesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoicesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadB2bTaxInvoicesSheetHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *DownloadB2bTaxInvoicesSheetError
	JSON401      *DownloadB2bTaxInvoicesSheetError
}

// Status returns HTTPResponse.Status
func (r DownloadB2bTaxInvoicesSheetHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadB2bTaxInvoicesSheetHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DraftB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DraftB2bTaxInvoiceResponse
	JSON400      *DraftB2bTaxInvoiceError
	JSON401      *DraftB2bTaxInvoiceError
	JSON403      *DraftB2bTaxInvoiceError
	JSON404      *DraftB2bTaxInvoiceError
	JSON409      *DraftB2bTaxInvoiceError
	JSON502      *DraftB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r DraftB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DraftB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateB2bTaxInvoiceDraftHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateB2bTaxInvoiceDraftResponse
	JSON400      *UpdateB2bTaxInvoiceDraftError
	JSON401      *UpdateB2bTaxInvoiceDraftError
	JSON403      *UpdateB2bTaxInvoiceDraftError
	JSON404      *UpdateB2bTaxInvoiceDraftError
	JSON409      *UpdateB2bTaxInvoiceDraftError
	JSON502      *UpdateB2bTaxInvoiceDraftError
}

// Status returns HTTPResponse.Status
func (r UpdateB2bTaxInvoiceDraftHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateB2bTaxInvoiceDraftHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueB2bTaxInvoiceImmediatelyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueB2bTaxInvoiceImmediatelyResponse
	JSON400      *IssueB2bTaxInvoiceImmediatelyError
	JSON401      *IssueB2bTaxInvoiceImmediatelyError
	JSON403      *IssueB2bTaxInvoiceImmediatelyError
	JSON404      *IssueB2bTaxInvoiceImmediatelyError
	JSON409      *IssueB2bTaxInvoiceImmediatelyError
	JSON502      *IssueB2bTaxInvoiceImmediatelyError
}

// Status returns HTTPResponse.Status
func (r IssueB2bTaxInvoiceImmediatelyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueB2bTaxInvoiceImmediatelyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestB2bTaxInvoiceReverseIssuanceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestB2bTaxInvoiceReverseIssuanceResponse
	JSON400      *RequestB2bTaxInvoiceReverseIssuanceError
	JSON401      *RequestB2bTaxInvoiceReverseIssuanceError
	JSON403      *RequestB2bTaxInvoiceReverseIssuanceError
	JSON404      *RequestB2bTaxInvoiceReverseIssuanceError
	JSON409      *RequestB2bTaxInvoiceReverseIssuanceError
	JSON502      *RequestB2bTaxInvoiceReverseIssuanceError
}

// Status returns HTTPResponse.Status
func (r RequestB2bTaxInvoiceReverseIssuanceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestB2bTaxInvoiceReverseIssuanceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteB2bTaxInvoiceResponse
	JSON400      *DeleteB2bTaxInvoiceError
	JSON401      *DeleteB2bTaxInvoiceError
	JSON403      *DeleteB2bTaxInvoiceError
	JSON404      *DeleteB2bTaxInvoiceError
	JSON502      *DeleteB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r DeleteB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *B2bTaxInvoice
	JSON400      *GetB2bTaxInvoiceError
	JSON401      *GetB2bTaxInvoiceError
	JSON403      *GetB2bTaxInvoiceError
	JSON404      *GetB2bTaxInvoiceError
	JSON502      *GetB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachB2bTaxInvoiceFileHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *AttachB2bTaxInvoiceFileError
	JSON401      *AttachB2bTaxInvoiceFileError
	JSON403      *AttachB2bTaxInvoiceFileError
	JSON404      *AttachB2bTaxInvoiceFileError
	JSON502      *AttachB2bTaxInvoiceFileError
}

// Status returns HTTPResponse.Status
func (r AttachB2bTaxInvoiceFileHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachB2bTaxInvoiceFileHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoiceAttachmentsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bTaxInvoiceAttachmentsResponse
	JSON400      *GetB2bTaxInvoiceAttachmentsError
	JSON401      *GetB2bTaxInvoiceAttachmentsError
	JSON403      *GetB2bTaxInvoiceAttachmentsError
	JSON404      *GetB2bTaxInvoiceAttachmentsError
	JSON502      *GetB2bTaxInvoiceAttachmentsError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoiceAttachmentsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoiceAttachmentsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteB2bTaxInvoiceAttachmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *DeleteB2bTaxInvoiceAttachmentError
	JSON401      *DeleteB2bTaxInvoiceAttachmentError
	JSON403      *DeleteB2bTaxInvoiceAttachmentError
	JSON404      *DeleteB2bTaxInvoiceAttachmentError
	JSON502      *DeleteB2bTaxInvoiceAttachmentError
}

// Status returns HTTPResponse.Status
func (r DeleteB2bTaxInvoiceAttachmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteB2bTaxInvoiceAttachmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelB2bTaxInvoiceIssuanceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelB2bTaxInvoiceIssuanceResponse
	JSON400      *CancelB2bTaxInvoiceIssuanceError
	JSON401      *CancelB2bTaxInvoiceIssuanceError
	JSON403      *CancelB2bTaxInvoiceIssuanceError
	JSON404      *CancelB2bTaxInvoiceIssuanceError
	JSON502      *CancelB2bTaxInvoiceIssuanceError
}

// Status returns HTTPResponse.Status
func (r CancelB2bTaxInvoiceIssuanceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelB2bTaxInvoiceIssuanceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelB2bTaxInvoiceRequestHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelB2bTaxInvoiceRequestResponse
	JSON400      *CancelB2bTaxInvoiceRequestError
	JSON401      *CancelB2bTaxInvoiceRequestError
	JSON403      *CancelB2bTaxInvoiceRequestError
	JSON404      *CancelB2bTaxInvoiceRequestError
	JSON502      *CancelB2bTaxInvoiceRequestError
}

// Status returns HTTPResponse.Status
func (r CancelB2bTaxInvoiceRequestHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelB2bTaxInvoiceRequestHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueB2bTaxInvoiceResponse
	JSON400      *IssueB2bTaxInvoiceError
	JSON401      *IssueB2bTaxInvoiceError
	JSON403      *IssueB2bTaxInvoiceError
	JSON404      *IssueB2bTaxInvoiceError
	JSON502      *IssueB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r IssueB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoicePdfDownloadUrlHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bTaxInvoicePdfDownloadUrlResponse
	JSON400      *GetB2bTaxInvoicePdfDownloadUrlError
	JSON401      *GetB2bTaxInvoicePdfDownloadUrlError
	JSON403      *GetB2bTaxInvoicePdfDownloadUrlError
	JSON404      *GetB2bTaxInvoicePdfDownloadUrlError
	JSON502      *GetB2bTaxInvoicePdfDownloadUrlError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoicePdfDownloadUrlHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoicePdfDownloadUrlHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoicePopupUrlHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bTaxInvoicePopupUrlResponse
	JSON400      *GetB2bTaxInvoicePopupUrlError
	JSON401      *GetB2bTaxInvoicePopupUrlError
	JSON403      *GetB2bTaxInvoicePopupUrlError
	JSON404      *GetB2bTaxInvoicePopupUrlError
	JSON502      *GetB2bTaxInvoicePopupUrlError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoicePopupUrlHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoicePopupUrlHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetB2bTaxInvoicePrintUrlHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetB2bTaxInvoicePrintUrlResponse
	JSON400      *GetB2bTaxInvoicePrintUrlError
	JSON401      *GetB2bTaxInvoicePrintUrlError
	JSON403      *GetB2bTaxInvoicePrintUrlError
	JSON404      *GetB2bTaxInvoicePrintUrlError
	JSON502      *GetB2bTaxInvoicePrintUrlError
}

// Status returns HTTPResponse.Status
func (r GetB2bTaxInvoicePrintUrlHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetB2bTaxInvoicePrintUrlHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefuseB2bTaxInvoiceRequestHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefuseB2bTaxInvoiceRequestResponse
	JSON400      *RefuseB2bTaxInvoiceRequestError
	JSON401      *RefuseB2bTaxInvoiceRequestError
	JSON403      *RefuseB2bTaxInvoiceRequestError
	JSON404      *RefuseB2bTaxInvoiceRequestError
	JSON502      *RefuseB2bTaxInvoiceRequestError
}

// Status returns HTTPResponse.Status
func (r RefuseB2bTaxInvoiceRequestHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefuseB2bTaxInvoiceRequestHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestB2bTaxInvoiceResponse
	JSON400      *RequestB2bTaxInvoiceError
	JSON401      *RequestB2bTaxInvoiceError
	JSON403      *RequestB2bTaxInvoiceError
	JSON404      *RequestB2bTaxInvoiceError
	JSON502      *RequestB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r RequestB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendToNtsB2bTaxInvoiceHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendToNtsB2bTaxInvoiceResponse
	JSON400      *SendToNtsB2bTaxInvoiceError
	JSON401      *SendToNtsB2bTaxInvoiceError
	JSON403      *SendToNtsB2bTaxInvoiceError
	JSON404      *SendToNtsB2bTaxInvoiceError
	JSON502      *SendToNtsB2bTaxInvoiceError
}

// Status returns HTTPResponse.Status
func (r SendToNtsB2bTaxInvoiceHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendToNtsB2bTaxInvoiceHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBankInfosHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBankInfosResponse
	JSON400      *GetBankInfosError
}

// Status returns HTTPResponse.Status
func (r GetBankInfosHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBankInfosHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingKeyInfosHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBillingKeyInfosResponse
	JSON400      *GetBillingKeyInfosError
	JSON401      *GetBillingKeyInfosError
	JSON403      *GetBillingKeyInfosError
}

// Status returns HTTPResponse.Status
func (r GetBillingKeyInfosHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingKeyInfosHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueBillingKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueBillingKeyResponse
	JSON400      *IssueBillingKeyError
	JSON401      *IssueBillingKeyError
	JSON403      *IssueBillingKeyError
	JSON404      *IssueBillingKeyError
	JSON502      *IssueBillingKeyError
}

// Status returns HTTPResponse.Status
func (r IssueBillingKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueBillingKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmBillingKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmedBillingKeySummary
	JSON400      *ConfirmBillingKeyError
	JSON401      *ConfirmBillingKeyError
	JSON403      *ConfirmBillingKeyError
	JSON404      *ConfirmBillingKeyError
	JSON409      *ConfirmBillingKeyError
	JSON502      *ConfirmBillingKeyError
}

// Status returns HTTPResponse.Status
func (r ConfirmBillingKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmBillingKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmBillingKeyIssueAndPayHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmedBillingKeyIssueAndPaySummary
	JSON400      *ConfirmBillingKeyIssueAndPayError
	JSON401      *ConfirmBillingKeyIssueAndPayError
	JSON403      *ConfirmBillingKeyIssueAndPayError
	JSON404      *ConfirmBillingKeyIssueAndPayError
	JSON409      *ConfirmBillingKeyIssueAndPayError
	JSON502      *ConfirmBillingKeyIssueAndPayError
}

// Status returns HTTPResponse.Status
func (r ConfirmBillingKeyIssueAndPayHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmBillingKeyIssueAndPayHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillingKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteBillingKeyResponse
	JSON400      *DeleteBillingKeyError
	JSON401      *DeleteBillingKeyError
	JSON403      *DeleteBillingKeyError
	JSON404      *DeleteBillingKeyError
	JSON409      *DeleteBillingKeyError
	JSON502      *DeleteBillingKeyError
}

// Status returns HTTPResponse.Status
func (r DeleteBillingKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillingKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingKeyInfoHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BillingKeyInfo
	JSON400      *GetBillingKeyInfoError
	JSON401      *GetBillingKeyInfoError
	JSON403      *GetBillingKeyInfoError
	JSON404      *GetBillingKeyInfoError
}

// Status returns HTTPResponse.Status
func (r GetBillingKeyInfoHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingKeyInfoHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashReceiptsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCashReceiptsResponse
	JSON400      *GetCashReceiptsError
	JSON401      *GetCashReceiptsError
	JSON403      *GetCashReceiptsError
}

// Status returns HTTPResponse.Status
func (r GetCashReceiptsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashReceiptsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCashReceiptHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueCashReceiptResponse
	JSON400      *IssueCashReceiptError
	JSON401      *IssueCashReceiptError
	JSON403      *IssueCashReceiptError
	JSON404      *IssueCashReceiptError
	JSON409      *IssueCashReceiptError
	JSON502      *IssueCashReceiptError
}

// Status returns HTTPResponse.Status
func (r IssueCashReceiptHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCashReceiptHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityVerificationsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetIdentityVerificationsResponse
	JSON400      *GetIdentityVerificationsError
	JSON401      *GetIdentityVerificationsError
	JSON403      *GetIdentityVerificationsError
}

// Status returns HTTPResponse.Status
func (r GetIdentityVerificationsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityVerificationsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIdentityVerificationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentityVerification
	JSON400      *GetIdentityVerificationError
	JSON401      *GetIdentityVerificationError
	JSON403      *GetIdentityVerificationError
	JSON404      *GetIdentityVerificationError
}

// Status returns HTTPResponse.Status
func (r GetIdentityVerificationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIdentityVerificationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmIdentityVerificationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmIdentityVerificationResponse
	JSON400      *ConfirmIdentityVerificationError
	JSON401      *ConfirmIdentityVerificationError
	JSON403      *ConfirmIdentityVerificationError
	JSON404      *ConfirmIdentityVerificationError
	JSON409      *ConfirmIdentityVerificationError
	JSON502      *ConfirmIdentityVerificationError
}

// Status returns HTTPResponse.Status
func (r ConfirmIdentityVerificationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmIdentityVerificationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResendIdentityVerificationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResendIdentityVerificationResponse
	JSON400      *ResendIdentityVerificationError
	JSON401      *ResendIdentityVerificationError
	JSON403      *ResendIdentityVerificationError
	JSON404      *ResendIdentityVerificationError
	JSON409      *ResendIdentityVerificationError
	JSON502      *ResendIdentityVerificationError
}

// Status returns HTTPResponse.Status
func (r ResendIdentityVerificationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResendIdentityVerificationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendIdentityVerificationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendIdentityVerificationResponse
	JSON400      *SendIdentityVerificationError
	JSON401      *SendIdentityVerificationError
	JSON403      *SendIdentityVerificationError
	JSON404      *SendIdentityVerificationError
	JSON409      *SendIdentityVerificationError
	JSON502      *SendIdentityVerificationError
}

// Status returns HTTPResponse.Status
func (r SendIdentityVerificationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendIdentityVerificationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKakaopayPaymentOrderHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetKakaopayPaymentOrderResponse
	JSON400      *GetKakaopayPaymentOrderError
	JSON401      *GetKakaopayPaymentOrderError
}

// Status returns HTTPResponse.Status
func (r GetKakaopayPaymentOrderHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKakaopayPaymentOrderHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginViaApiSecretHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginViaApiSecretResponse
	JSON400      *LoginViaApiSecretError
	JSON401      *LoginViaApiSecretError
}

// Status returns HTTPResponse.Status
func (r LoginViaApiSecretHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginViaApiSecretHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllPaymentEventsByCursorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllPaymentEventsByCursorResponse
	JSON400      *GetAllPaymentEventsError
	JSON401      *GetAllPaymentEventsError
	JSON403      *GetAllPaymentEventsError
}

// Status returns HTTPResponse.Status
func (r GetAllPaymentEventsByCursorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllPaymentEventsByCursorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokePaymentSchedulesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RevokePaymentSchedulesResponse
	JSON400      *RevokePaymentSchedulesError
	JSON401      *RevokePaymentSchedulesError
	JSON403      *RevokePaymentSchedulesError
	JSON404      *RevokePaymentSchedulesError
	JSON409      *RevokePaymentSchedulesError
}

// Status returns HTTPResponse.Status
func (r RevokePaymentSchedulesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokePaymentSchedulesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentSchedulesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPaymentSchedulesResponse
	JSON400      *GetPaymentSchedulesError
	JSON401      *GetPaymentSchedulesError
	JSON403      *GetPaymentSchedulesError
}

// Status returns HTTPResponse.Status
func (r GetPaymentSchedulesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentSchedulesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaymentSchedule
	JSON400      *GetPaymentScheduleError
	JSON401      *GetPaymentScheduleError
	JSON403      *GetPaymentScheduleError
	JSON404      *GetPaymentScheduleError
}

// Status returns HTTPResponse.Status
func (r GetPaymentScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPaymentsResponse
	JSON400      *GetPaymentsError
	JSON401      *GetPaymentsError
	JSON403      *GetPaymentsError
}

// Status returns HTTPResponse.Status
func (r GetPaymentsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllPaymentsByCursorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllPaymentsByCursorResponse
	JSON400      *GetAllPaymentsError
	JSON401      *GetAllPaymentsError
	JSON403      *GetAllPaymentsError
}

// Status returns HTTPResponse.Status
func (r GetAllPaymentsByCursorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllPaymentsByCursorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payment
	JSON400      *GetPaymentError
	JSON401      *GetPaymentError
	JSON403      *GetPaymentError
	JSON404      *GetPaymentError
}

// Status returns HTTPResponse.Status
func (r GetPaymentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayWithBillingKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayWithBillingKeyResponse
	JSON400      *PayWithBillingKeyError
	JSON401      *PayWithBillingKeyError
	JSON403      *PayWithBillingKeyError
	JSON404      *PayWithBillingKeyError
	JSON409      *PayWithBillingKeyError
	JSON502      *PayWithBillingKeyError
}

// Status returns HTTPResponse.Status
func (r PayWithBillingKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayWithBillingKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPaymentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelPaymentResponse
	JSON400      *CancelPaymentError
	JSON401      *CancelPaymentError
	JSON403      *CancelPaymentError
	JSON404      *CancelPaymentError
	JSON409      *CancelPaymentError
	JSON502      *CancelPaymentError
}

// Status returns HTTPResponse.Status
func (r CancelPaymentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPaymentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CapturePaymentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CapturePaymentResponse
	JSON400      *CapturePaymentError
	JSON401      *CapturePaymentError
	JSON403      *CapturePaymentError
	JSON404      *CapturePaymentError
	JSON409      *CapturePaymentError
	JSON502      *CapturePaymentError
}

// Status returns HTTPResponse.Status
func (r CapturePaymentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CapturePaymentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashReceiptByPaymentIdHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashReceipt
	JSON400      *GetCashReceiptError
	JSON401      *GetCashReceiptError
	JSON403      *GetCashReceiptError
	JSON404      *GetCashReceiptError
}

// Status returns HTTPResponse.Status
func (r GetCashReceiptByPaymentIdHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashReceiptByPaymentIdHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelCashReceiptByPaymentIdHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelCashReceiptResponse
	JSON400      *CancelCashReceiptError
	JSON401      *CancelCashReceiptError
	JSON403      *CancelCashReceiptError
	JSON404      *CancelCashReceiptError
	JSON502      *CancelCashReceiptError
}

// Status returns HTTPResponse.Status
func (r CancelCashReceiptByPaymentIdHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelCashReceiptByPaymentIdHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmPaymentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmedPaymentSummary
	JSON400      *ConfirmPaymentError
	JSON401      *ConfirmPaymentError
	JSON403      *ConfirmPaymentError
	JSON404      *ConfirmPaymentError
	JSON409      *ConfirmPaymentError
	JSON502      *ConfirmPaymentError
}

// Status returns HTTPResponse.Status
func (r ConfirmPaymentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmPaymentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfirmEscrowHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfirmEscrowResponse
	JSON400      *ConfirmEscrowError
	JSON401      *ConfirmEscrowError
	JSON403      *ConfirmEscrowError
	JSON404      *ConfirmEscrowError
	JSON409      *ConfirmEscrowError
	JSON502      *ConfirmEscrowError
}

// Status returns HTTPResponse.Status
func (r ConfirmEscrowHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfirmEscrowHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyEscrowLogisticsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModifyEscrowLogisticsResponse
	JSON400      *ModifyEscrowLogisticsError
	JSON401      *ModifyEscrowLogisticsError
	JSON403      *ModifyEscrowLogisticsError
	JSON404      *ModifyEscrowLogisticsError
	JSON409      *ModifyEscrowLogisticsError
	JSON502      *ModifyEscrowLogisticsError
}

// Status returns HTTPResponse.Status
func (r ModifyEscrowLogisticsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyEscrowLogisticsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApplyEscrowLogisticsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplyEscrowLogisticsResponse
	JSON400      *ApplyEscrowLogisticsError
	JSON401      *ApplyEscrowLogisticsError
	JSON403      *ApplyEscrowLogisticsError
	JSON404      *ApplyEscrowLogisticsError
	JSON409      *ApplyEscrowLogisticsError
	JSON502      *ApplyEscrowLogisticsError
}

// Status returns HTTPResponse.Status
func (r ApplyEscrowLogisticsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplyEscrowLogisticsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PayInstantlyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayInstantlyResponse
	JSON400      *PayInstantlyError
	JSON401      *PayInstantlyError
	JSON403      *PayInstantlyError
	JSON404      *PayInstantlyError
	JSON409      *PayInstantlyError
	JSON502      *PayInstantlyError
}

// Status returns HTTPResponse.Status
func (r PayInstantlyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PayInstantlyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreRegisterPaymentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreRegisterPaymentResponse
	JSON400      *PreRegisterPaymentError
	JSON401      *PreRegisterPaymentError
	JSON403      *PreRegisterPaymentError
	JSON409      *PreRegisterPaymentError
}

// Status returns HTTPResponse.Status
func (r PreRegisterPaymentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreRegisterPaymentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterStoreReceiptHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisterStoreReceiptResponse
	JSON400      *RegisterStoreReceiptError
	JSON401      *RegisterStoreReceiptError
	JSON403      *RegisterStoreReceiptError
	JSON404      *RegisterStoreReceiptError
	JSON409      *RegisterStoreReceiptError
	JSON502      *RegisterStoreReceiptError
}

// Status returns HTTPResponse.Status
func (r RegisterStoreReceiptHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterStoreReceiptHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResendWebhookHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResendWebhookResponse
	JSON400      *ResendWebhookError
	JSON401      *ResendWebhookError
	JSON403      *ResendWebhookError
	JSON404      *ResendWebhookError
}

// Status returns HTTPResponse.Status
func (r ResendWebhookHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResendWebhookHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePaymentScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePaymentScheduleResponse
	JSON400      *CreatePaymentScheduleError
	JSON401      *CreatePaymentScheduleError
	JSON403      *CreatePaymentScheduleError
	JSON404      *CreatePaymentScheduleError
	JSON409      *CreatePaymentScheduleError
}

// Status returns HTTPResponse.Status
func (r CreatePaymentScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentTransactionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPaymentTransactionsResponse
	JSON400      *GetPaymentTransactionsError
	JSON401      *GetPaymentTransactionsError
	JSON403      *GetPaymentTransactionsError
	JSON404      *GetPaymentTransactionsError
}

// Status returns HTTPResponse.Status
func (r GetPaymentTransactionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentTransactionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseVirtualAccountHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloseVirtualAccountResponse
	JSON400      *CloseVirtualAccountError
	JSON401      *CloseVirtualAccountError
	JSON403      *CloseVirtualAccountError
	JSON404      *CloseVirtualAccountError
	JSON409      *CloseVirtualAccountError
	JSON502      *CloseVirtualAccountError
}

// Status returns HTTPResponse.Status
func (r CloseVirtualAccountHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseVirtualAccountHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAccountTransfersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformAccountTransfersResponse
	JSON400      *GetPlatformAccountTransfersError
	JSON401      *GetPlatformAccountTransfersError
	JSON403      *GetPlatformAccountTransfersError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAccountTransfersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAccountTransfersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAdditionalFeePoliciesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformAdditionalFeePoliciesResponse
	JSON400      *GetPlatformAdditionalFeePoliciesError
	JSON401      *GetPlatformAdditionalFeePoliciesError
	JSON403      *GetPlatformAdditionalFeePoliciesError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAdditionalFeePoliciesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAdditionalFeePoliciesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlatformAdditionalFeePolicyResponse
	JSON400      *CreatePlatformAdditionalFeePolicyError
	JSON401      *CreatePlatformAdditionalFeePolicyError
	JSON403      *CreatePlatformAdditionalFeePolicyError
	JSON409      *CreatePlatformAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformAdditionalFeePolicy
	JSON400      *GetPlatformAdditionalFeePolicyError
	JSON401      *GetPlatformAdditionalFeePolicyError
	JSON403      *GetPlatformAdditionalFeePolicyError
	JSON404      *GetPlatformAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlatformAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePlatformAdditionalFeePolicyResponse
	JSON400      *UpdatePlatformAdditionalFeePolicyError
	JSON401      *UpdatePlatformAdditionalFeePolicyError
	JSON403      *UpdatePlatformAdditionalFeePolicyError
	JSON404      *UpdatePlatformAdditionalFeePolicyError
	JSON409      *UpdatePlatformAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r UpdatePlatformAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlatformAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlatformAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchivePlatformAdditionalFeePolicyResponse
	JSON400      *ArchivePlatformAdditionalFeePolicyError
	JSON401      *ArchivePlatformAdditionalFeePolicyError
	JSON403      *ArchivePlatformAdditionalFeePolicyError
	JSON404      *ArchivePlatformAdditionalFeePolicyError
	JSON409      *ArchivePlatformAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r ArchivePlatformAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlatformAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverPlatformAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoverPlatformAdditionalFeePolicyResponse
	JSON400      *RecoverPlatformAdditionalFeePolicyError
	JSON401      *RecoverPlatformAdditionalFeePolicyError
	JSON403      *RecoverPlatformAdditionalFeePolicyError
	JSON404      *RecoverPlatformAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r RecoverPlatformAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverPlatformAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPlatformAdditionalFeePolicyScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelPlatformAdditionalFeePolicyScheduleResponse
	JSON400      *CancelPlatformAdditionalFeePolicyScheduleError
	JSON401      *CancelPlatformAdditionalFeePolicyScheduleError
	JSON403      *CancelPlatformAdditionalFeePolicyScheduleError
	JSON404      *CancelPlatformAdditionalFeePolicyScheduleError
}

// Status returns HTTPResponse.Status
func (r CancelPlatformAdditionalFeePolicyScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPlatformAdditionalFeePolicyScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAdditionalFeePolicyScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformAdditionalFeePolicy
	JSON400      *GetPlatformAdditionalFeePolicyScheduleError
	JSON401      *GetPlatformAdditionalFeePolicyScheduleError
	JSON403      *GetPlatformAdditionalFeePolicyScheduleError
	JSON404      *GetPlatformAdditionalFeePolicyScheduleError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAdditionalFeePolicyScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAdditionalFeePolicyScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchedulePlatformAdditionalFeePolicyResponse
	JSON400      *ScheduleAdditionalFeePolicyError
	JSON401      *ScheduleAdditionalFeePolicyError
	JSON403      *ScheduleAdditionalFeePolicyError
	JSON404      *ScheduleAdditionalFeePolicyError
	JSON409      *ScheduleAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r ScheduleAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RescheduleAdditionalFeePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReschedulePlatformAdditionalFeePolicyResponse
	JSON400      *RescheduleAdditionalFeePolicyError
	JSON401      *RescheduleAdditionalFeePolicyError
	JSON403      *RescheduleAdditionalFeePolicyError
	JSON404      *RescheduleAdditionalFeePolicyError
}

// Status returns HTTPResponse.Status
func (r RescheduleAdditionalFeePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RescheduleAdditionalFeePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAccountHolderHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformAccountHolder
	JSON400      *GetPlatformAccountHolderError
	JSON401      *GetPlatformAccountHolderError
	JSON403      *GetPlatformAccountHolderError
	JSON503      *GetPlatformAccountHolderError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAccountHolderHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAccountHolderHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformBulkAccountTransfersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformBulkAccountTransfersResponse
	JSON400      *GetPlatformBulkAccountTransfersError
	JSON401      *GetPlatformBulkAccountTransfersError
	JSON403      *GetPlatformBulkAccountTransfersError
}

// Status returns HTTPResponse.Status
func (r GetPlatformBulkAccountTransfersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformBulkAccountTransfersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformBulkPayoutsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformBulkPayoutsResponse
	JSON400      *GetPlatformBulkPayoutsError
	JSON401      *GetPlatformBulkPayoutsError
	JSON403      *GetPlatformBulkPayoutsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformBulkPayoutsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformBulkPayoutsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformCompanyStateHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformCompanyStatePayload
	JSON400      *GetPlatformCompanyStateError
	JSON401      *GetPlatformCompanyStateError
	JSON403      *GetPlatformCompanyStateError
	JSON404      *GetPlatformCompanyStateError
	JSON503      *GetPlatformCompanyStateError
}

// Status returns HTTPResponse.Status
func (r GetPlatformCompanyStateHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformCompanyStateHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformContractsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformContractsResponse
	JSON400      *GetPlatformContractsError
	JSON401      *GetPlatformContractsError
	JSON403      *GetPlatformContractsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformContractsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformContractsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlatformContractResponse
	JSON400      *CreatePlatformContractError
	JSON401      *CreatePlatformContractError
	JSON403      *CreatePlatformContractError
	JSON409      *CreatePlatformContractError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformContract
	JSON400      *GetPlatformContractError
	JSON401      *GetPlatformContractError
	JSON403      *GetPlatformContractError
	JSON404      *GetPlatformContractError
}

// Status returns HTTPResponse.Status
func (r GetPlatformContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlatformContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePlatformContractResponse
	JSON400      *UpdatePlatformContractError
	JSON401      *UpdatePlatformContractError
	JSON403      *UpdatePlatformContractError
	JSON404      *UpdatePlatformContractError
	JSON409      *UpdatePlatformContractError
}

// Status returns HTTPResponse.Status
func (r UpdatePlatformContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlatformContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlatformContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchivePlatformContractResponse
	JSON400      *ArchivePlatformContractError
	JSON401      *ArchivePlatformContractError
	JSON403      *ArchivePlatformContractError
	JSON404      *ArchivePlatformContractError
	JSON409      *ArchivePlatformContractError
}

// Status returns HTTPResponse.Status
func (r ArchivePlatformContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlatformContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverPlatformContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoverPlatformContractResponse
	JSON400      *RecoverPlatformContractError
	JSON401      *RecoverPlatformContractError
	JSON403      *RecoverPlatformContractError
	JSON404      *RecoverPlatformContractError
}

// Status returns HTTPResponse.Status
func (r RecoverPlatformContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverPlatformContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPlatformContractScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelPlatformContractScheduleResponse
	JSON400      *CancelPlatformContractScheduleError
	JSON401      *CancelPlatformContractScheduleError
	JSON403      *CancelPlatformContractScheduleError
	JSON404      *CancelPlatformContractScheduleError
}

// Status returns HTTPResponse.Status
func (r CancelPlatformContractScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPlatformContractScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformContractScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformContract
	JSON400      *GetPlatformContractScheduleError
	JSON401      *GetPlatformContractScheduleError
	JSON403      *GetPlatformContractScheduleError
	JSON404      *GetPlatformContractScheduleError
}

// Status returns HTTPResponse.Status
func (r GetPlatformContractScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformContractScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchedulePlatformContractResponse
	JSON400      *ScheduleContractError
	JSON401      *ScheduleContractError
	JSON403      *ScheduleContractError
	JSON404      *ScheduleContractError
	JSON409      *ScheduleContractError
}

// Status returns HTTPResponse.Status
func (r ScheduleContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RescheduleContractHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReschedulePlatformContractResponse
	JSON400      *RescheduleContractError
	JSON401      *RescheduleContractError
	JSON403      *RescheduleContractError
	JSON404      *RescheduleContractError
}

// Status returns HTTPResponse.Status
func (r RescheduleContractHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RescheduleContractHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDiscountSharePoliciesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformDiscountSharePoliciesResponse
	JSON400      *GetPlatformDiscountSharePoliciesError
	JSON401      *GetPlatformDiscountSharePoliciesError
	JSON403      *GetPlatformDiscountSharePoliciesError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDiscountSharePoliciesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDiscountSharePoliciesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlatformDiscountSharePolicyResponse
	JSON400      *CreatePlatformDiscountSharePolicyError
	JSON401      *CreatePlatformDiscountSharePolicyError
	JSON403      *CreatePlatformDiscountSharePolicyError
	JSON409      *CreatePlatformDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformDiscountSharePolicy
	JSON400      *GetPlatformDiscountSharePolicyError
	JSON401      *GetPlatformDiscountSharePolicyError
	JSON403      *GetPlatformDiscountSharePolicyError
	JSON404      *GetPlatformDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlatformDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePlatformDiscountSharePolicyResponse
	JSON400      *UpdatePlatformDiscountSharePolicyError
	JSON401      *UpdatePlatformDiscountSharePolicyError
	JSON403      *UpdatePlatformDiscountSharePolicyError
	JSON404      *UpdatePlatformDiscountSharePolicyError
	JSON409      *UpdatePlatformDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r UpdatePlatformDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlatformDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlatformDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchivePlatformDiscountSharePolicyResponse
	JSON400      *ArchivePlatformDiscountSharePolicyError
	JSON401      *ArchivePlatformDiscountSharePolicyError
	JSON403      *ArchivePlatformDiscountSharePolicyError
	JSON404      *ArchivePlatformDiscountSharePolicyError
	JSON409      *ArchivePlatformDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r ArchivePlatformDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlatformDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverPlatformDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoverPlatformDiscountSharePolicyResponse
	JSON400      *RecoverPlatformDiscountSharePolicyError
	JSON401      *RecoverPlatformDiscountSharePolicyError
	JSON403      *RecoverPlatformDiscountSharePolicyError
	JSON404      *RecoverPlatformDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r RecoverPlatformDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverPlatformDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPlatformDiscountSharePolicyScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelPlatformDiscountSharePolicyScheduleResponse
	JSON400      *CancelPlatformDiscountSharePolicyScheduleError
	JSON401      *CancelPlatformDiscountSharePolicyScheduleError
	JSON403      *CancelPlatformDiscountSharePolicyScheduleError
	JSON404      *CancelPlatformDiscountSharePolicyScheduleError
}

// Status returns HTTPResponse.Status
func (r CancelPlatformDiscountSharePolicyScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPlatformDiscountSharePolicyScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDiscountSharePolicyScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformDiscountSharePolicy
	JSON400      *GetPlatformDiscountSharePolicyScheduleError
	JSON401      *GetPlatformDiscountSharePolicyScheduleError
	JSON403      *GetPlatformDiscountSharePolicyScheduleError
	JSON404      *GetPlatformDiscountSharePolicyScheduleError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDiscountSharePolicyScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDiscountSharePolicyScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScheduleDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchedulePlatformDiscountSharePolicyResponse
	JSON400      *ScheduleDiscountSharePolicyError
	JSON401      *ScheduleDiscountSharePolicyError
	JSON403      *ScheduleDiscountSharePolicyError
	JSON404      *ScheduleDiscountSharePolicyError
	JSON409      *ScheduleDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r ScheduleDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScheduleDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RescheduleDiscountSharePolicyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReschedulePlatformDiscountSharePolicyResponse
	JSON400      *RescheduleDiscountSharePolicyError
	JSON401      *RescheduleDiscountSharePolicyError
	JSON403      *RescheduleDiscountSharePolicyError
	JSON404      *RescheduleDiscountSharePolicyError
}

// Status returns HTTPResponse.Status
func (r RescheduleDiscountSharePolicyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RescheduleDiscountSharePolicyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformDiscountSharePolicyFilterOptions
	JSON400      *GetPlatformDiscountSharePolicyFilterOptionsError
	JSON401      *GetPlatformDiscountSharePolicyFilterOptionsError
	JSON403      *GetPlatformDiscountSharePolicyFilterOptionsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPartnerFilterOptionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformPartnerFilterOptions
	JSON400      *GetPlatformPartnerFilterOptionsError
	JSON401      *GetPlatformPartnerFilterOptionsError
	JSON403      *GetPlatformPartnerFilterOptionsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPartnerFilterOptionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPartnerFilterOptionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPartnerSettlementsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformPartnerSettlementsResponse
	JSON400      *GetPlatformPartnerSettlementsError
	JSON401      *GetPlatformPartnerSettlementsError
	JSON403      *GetPlatformPartnerSettlementsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPartnerSettlementsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPartnerSettlementsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPartnersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformPartnersResponse
	JSON400      *GetPlatformPartnersError
	JSON401      *GetPlatformPartnersError
	JSON403      *GetPlatformPartnersError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPartnersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPartnersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformPartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlatformPartnerResponse
	JSON400      *CreatePlatformPartnerError
	JSON401      *CreatePlatformPartnerError
	JSON403      *CreatePlatformPartnerError
	JSON404      *CreatePlatformPartnerError
	JSON409      *CreatePlatformPartnerError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformPartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformPartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformPartnersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePlatformPartnersResponse
	JSON400      *CreatePlatformPartnersError
	JSON401      *CreatePlatformPartnersError
	JSON403      *CreatePlatformPartnersError
	JSON404      *CreatePlatformPartnersError
	JSON409      *CreatePlatformPartnersError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformPartnersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformPartnersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectBulkPartnerMemberCompanyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectBulkPartnerMemberCompanyResponse
	JSON400      *ConnectBulkPartnerMemberCompanyError
	JSON401      *ConnectBulkPartnerMemberCompanyError
	JSON403      *ConnectBulkPartnerMemberCompanyError
	JSON404      *ConnectBulkPartnerMemberCompanyError
	JSON503      *ConnectBulkPartnerMemberCompanyError
}

// Status returns HTTPResponse.Status
func (r ConnectBulkPartnerMemberCompanyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectBulkPartnerMemberCompanyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectPartnerMemberCompanyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectPartnerMemberCompanyResponse
	JSON400      *ConnectPartnerMemberCompanyError
	JSON401      *ConnectPartnerMemberCompanyError
	JSON403      *ConnectPartnerMemberCompanyError
	JSON404      *ConnectPartnerMemberCompanyError
	JSON409      *ConnectPartnerMemberCompanyError
	JSON503      *ConnectPartnerMemberCompanyError
}

// Status returns HTTPResponse.Status
func (r ConnectPartnerMemberCompanyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectPartnerMemberCompanyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectBulkPartnerMemberCompanyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DisconnectBulkPartnerMemberCompanyResponse
	JSON400      *DisconnectBulkPartnerMemberCompanyError
	JSON401      *DisconnectBulkPartnerMemberCompanyError
	JSON403      *DisconnectBulkPartnerMemberCompanyError
	JSON404      *DisconnectBulkPartnerMemberCompanyError
	JSON503      *DisconnectBulkPartnerMemberCompanyError
}

// Status returns HTTPResponse.Status
func (r DisconnectBulkPartnerMemberCompanyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectBulkPartnerMemberCompanyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectPartnerMemberCompanyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DisconnectPartnerMemberCompanyResponse
	JSON400      *DisconnectPartnerMemberCompanyError
	JSON401      *DisconnectPartnerMemberCompanyError
	JSON403      *DisconnectPartnerMemberCompanyError
	JSON404      *DisconnectPartnerMemberCompanyError
	JSON409      *DisconnectPartnerMemberCompanyError
	JSON503      *DisconnectPartnerMemberCompanyError
}

// Status returns HTTPResponse.Status
func (r DisconnectPartnerMemberCompanyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectPartnerMemberCompanyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchedulePlatformPartnersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchedulePlatformPartnersResponse
	JSON400      *SchedulePlatformPartnersError
	JSON401      *SchedulePlatformPartnersError
	JSON403      *SchedulePlatformPartnersError
	JSON404      *SchedulePlatformPartnersError
	JSON409      *SchedulePlatformPartnersError
}

// Status returns HTTPResponse.Status
func (r SchedulePlatformPartnersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchedulePlatformPartnersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformPartner
	JSON400      *GetPlatformPartnerError
	JSON401      *GetPlatformPartnerError
	JSON403      *GetPlatformPartnerError
	JSON404      *GetPlatformPartnerError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlatformPartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePlatformPartnerResponse
	JSON400      *UpdatePlatformPartnerError
	JSON401      *UpdatePlatformPartnerError
	JSON403      *UpdatePlatformPartnerError
	JSON404      *UpdatePlatformPartnerError
	JSON409      *UpdatePlatformPartnerError
}

// Status returns HTTPResponse.Status
func (r UpdatePlatformPartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlatformPartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlatformPartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchivePlatformPartnerResponse
	JSON400      *ArchivePlatformPartnerError
	JSON401      *ArchivePlatformPartnerError
	JSON403      *ArchivePlatformPartnerError
	JSON404      *ArchivePlatformPartnerError
	JSON409      *ArchivePlatformPartnerError
}

// Status returns HTTPResponse.Status
func (r ArchivePlatformPartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlatformPartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverPlatformPartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecoverPlatformPartnerResponse
	JSON400      *RecoverPlatformPartnerError
	JSON401      *RecoverPlatformPartnerError
	JSON403      *RecoverPlatformPartnerError
	JSON404      *RecoverPlatformPartnerError
}

// Status returns HTTPResponse.Status
func (r RecoverPlatformPartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverPlatformPartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelPlatformPartnerScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelPlatformPartnerScheduleResponse
	JSON400      *CancelPlatformPartnerScheduleError
	JSON401      *CancelPlatformPartnerScheduleError
	JSON403      *CancelPlatformPartnerScheduleError
	JSON404      *CancelPlatformPartnerScheduleError
}

// Status returns HTTPResponse.Status
func (r CancelPlatformPartnerScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelPlatformPartnerScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPartnerScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformPartner
	JSON400      *GetPlatformPartnerScheduleError
	JSON401      *GetPlatformPartnerScheduleError
	JSON403      *GetPlatformPartnerScheduleError
	JSON404      *GetPlatformPartnerScheduleError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPartnerScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPartnerScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchedulePartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchedulePlatformPartnerResponse
	JSON400      *SchedulePartnerError
	JSON401      *SchedulePartnerError
	JSON403      *SchedulePartnerError
	JSON404      *SchedulePartnerError
	JSON409      *SchedulePartnerError
}

// Status returns HTTPResponse.Status
func (r SchedulePartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchedulePartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReschedulePartnerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReschedulePlatformPartnerResponse
	JSON400      *ReschedulePartnerError
	JSON401      *ReschedulePartnerError
	JSON403      *ReschedulePartnerError
	JSON404      *ReschedulePartnerError
	JSON409      *ReschedulePartnerError
}

// Status returns HTTPResponse.Status
func (r ReschedulePartnerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReschedulePartnerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformPayoutsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformPayoutsResponse
	JSON400      *GetPlatformPayoutsError
	JSON401      *GetPlatformPayoutsError
	JSON403      *GetPlatformPayoutsError
}

// Status returns HTTPResponse.Status
func (r GetPlatformPayoutsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformPayoutsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformSettingHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformSetting
	JSON400      *GetPlatformSettingError
	JSON401      *GetPlatformSettingError
	JSON403      *GetPlatformSettingError
}

// Status returns HTTPResponse.Status
func (r GetPlatformSettingHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformSettingHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlatformSettingHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePlatformSettingResponse
	JSON400      *UpdatePlatformSettingError
	JSON401      *UpdatePlatformSettingError
	JSON403      *UpdatePlatformSettingError
}

// Status returns HTTPResponse.Status
func (r UpdatePlatformSettingHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlatformSettingHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformTransferSummariesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPlatformTransferSummariesResponse
	JSON400      *GetPlatformTransferSummariesError
	JSON401      *GetPlatformTransferSummariesError
	JSON403      *GetPlatformTransferSummariesError
}

// Status returns HTTPResponse.Status
func (r GetPlatformTransferSummariesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformTransferSummariesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadPlatformTransferSheetHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *DownloadPlatformTransferSheetError
	JSON401      *DownloadPlatformTransferSheetError
}

// Status returns HTTPResponse.Status
func (r DownloadPlatformTransferSheetHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadPlatformTransferSheetHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformManualTransferHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateManualTransferResponse
	JSON400      *CreatePlatformManualTransferError
	JSON401      *CreatePlatformManualTransferError
	JSON403      *CreatePlatformManualTransferError
	JSON404      *CreatePlatformManualTransferError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformManualTransferHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformManualTransferHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformOrderTransferHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrderTransferResponse
	JSON400      *CreatePlatformOrderTransferError
	JSON401      *CreatePlatformOrderTransferError
	JSON403      *CreatePlatformOrderTransferError
	JSON404      *CreatePlatformOrderTransferError
	JSON409      *CreatePlatformOrderTransferError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformOrderTransferHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformOrderTransferHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlatformOrderCancelTransferHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrderCancelTransferResponse
	JSON400      *CreatePlatformOrderCancelTransferError
	JSON401      *CreatePlatformOrderCancelTransferError
	JSON403      *CreatePlatformOrderCancelTransferError
	JSON404      *CreatePlatformOrderCancelTransferError
	JSON409      *CreatePlatformOrderCancelTransferError
}

// Status returns HTTPResponse.Status
func (r CreatePlatformOrderCancelTransferHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlatformOrderCancelTransferHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlatformTransferHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePlatformTransferResponse
	JSON400      *DeletePlatformTransferError
	JSON401      *DeletePlatformTransferError
	JSON403      *DeletePlatformTransferError
	JSON404      *DeletePlatformTransferError
}

// Status returns HTTPResponse.Status
func (r DeletePlatformTransferHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlatformTransferHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformTransferHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatformTransfer
	JSON400      *GetPlatformTransferError
	JSON401      *GetPlatformTransferError
	JSON403      *GetPlatformTransferError
	JSON404      *GetPlatformTransferError
}

// Status returns HTTPResponse.Status
func (r GetPlatformTransferHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformTransferHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPromotionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Promotion
	JSON400      *GetPromotionError
	JSON401      *GetPromotionError
	JSON403      *GetPromotionError
	JSON404      *GetPromotionError
}

// Status returns HTTPResponse.Status
func (r GetPromotionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPromotionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshTokenResponse
	JSON400      *RefreshTokenError
	JSON401      *RefreshTokenError
}

// Status returns HTTPResponse.Status
func (r RefreshTokenHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetB2bBulkTaxInvoiceWithResponse request returning *GetB2bBulkTaxInvoiceHTTPResponse
func (c *ClientWithResponses) GetB2bBulkTaxInvoiceWithResponse(ctx context.Context, bulkTaxInvoiceId string, params *GetB2bBulkTaxInvoiceParams, reqEditors ...RequestEditorFn) (*GetB2bBulkTaxInvoiceHTTPResponse, error) {
	rsp, err := c.GetB2bBulkTaxInvoice(ctx, bulkTaxInvoiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bBulkTaxInvoiceHTTPResponse(rsp)
}

// GetB2bBusinessInfosWithBodyWithResponse request with arbitrary body returning *GetB2bBusinessInfosHTTPResponse
func (c *ClientWithResponses) GetB2bBusinessInfosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetB2bBusinessInfosHTTPResponse, error) {
	rsp, err := c.GetB2bBusinessInfosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bBusinessInfosHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetB2bBusinessInfosWithResponse(ctx context.Context, body GetB2bBusinessInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*GetB2bBusinessInfosHTTPResponse, error) {
	rsp, err := c.GetB2bBusinessInfos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bBusinessInfosHTTPResponse(rsp)
}

// CreateB2bFileUploadUrlWithBodyWithResponse request with arbitrary body returning *CreateB2bFileUploadUrlHTTPResponse
func (c *ClientWithResponses) CreateB2bFileUploadUrlWithBodyWithResponse(ctx context.Context, params *CreateB2bFileUploadUrlParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateB2bFileUploadUrlHTTPResponse, error) {
	rsp, err := c.CreateB2bFileUploadUrlWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateB2bFileUploadUrlHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreateB2bFileUploadUrlWithResponse(ctx context.Context, params *CreateB2bFileUploadUrlParams, body CreateB2bFileUploadUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateB2bFileUploadUrlHTTPResponse, error) {
	rsp, err := c.CreateB2bFileUploadUrl(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateB2bFileUploadUrlHTTPResponse(rsp)
}

// GetB2bTaxInvoicesWithBodyWithResponse request with arbitrary body returning *GetB2bTaxInvoicesHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoicesWithBodyWithResponse(ctx context.Context, params *GetB2bTaxInvoicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicesHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoicesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoicesHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetB2bTaxInvoicesWithResponse(ctx context.Context, params *GetB2bTaxInvoicesParams, body GetB2bTaxInvoicesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicesHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoices(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoicesHTTPResponse(rsp)
}

// DownloadB2bTaxInvoicesSheetWithBodyWithResponse request with arbitrary body returning *DownloadB2bTaxInvoicesSheetHTTPResponse
func (c *ClientWithResponses) DownloadB2bTaxInvoicesSheetWithBodyWithResponse(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadB2bTaxInvoicesSheetHTTPResponse, error) {
	rsp, err := c.DownloadB2bTaxInvoicesSheetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadB2bTaxInvoicesSheetHTTPResponse(rsp)
}

func (c *ClientWithResponses) DownloadB2bTaxInvoicesSheetWithResponse(ctx context.Context, params *DownloadB2bTaxInvoicesSheetParams, body DownloadB2bTaxInvoicesSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadB2bTaxInvoicesSheetHTTPResponse, error) {
	rsp, err := c.DownloadB2bTaxInvoicesSheet(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadB2bTaxInvoicesSheetHTTPResponse(rsp)
}

// DraftB2bTaxInvoiceWithBodyWithResponse request with arbitrary body returning *DraftB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) DraftB2bTaxInvoiceWithBodyWithResponse(ctx context.Context, params *DraftB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DraftB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.DraftB2bTaxInvoiceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftB2bTaxInvoiceHTTPResponse(rsp)
}

func (c *ClientWithResponses) DraftB2bTaxInvoiceWithResponse(ctx context.Context, params *DraftB2bTaxInvoiceParams, body DraftB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*DraftB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.DraftB2bTaxInvoice(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDraftB2bTaxInvoiceHTTPResponse(rsp)
}

// UpdateB2bTaxInvoiceDraftWithBodyWithResponse request with arbitrary body returning *UpdateB2bTaxInvoiceDraftHTTPResponse
func (c *ClientWithResponses) UpdateB2bTaxInvoiceDraftWithBodyWithResponse(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateB2bTaxInvoiceDraftHTTPResponse, error) {
	rsp, err := c.UpdateB2bTaxInvoiceDraftWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateB2bTaxInvoiceDraftHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdateB2bTaxInvoiceDraftWithResponse(ctx context.Context, params *UpdateB2bTaxInvoiceDraftParams, body UpdateB2bTaxInvoiceDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateB2bTaxInvoiceDraftHTTPResponse, error) {
	rsp, err := c.UpdateB2bTaxInvoiceDraft(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateB2bTaxInvoiceDraftHTTPResponse(rsp)
}

// IssueB2bTaxInvoiceImmediatelyWithBodyWithResponse request with arbitrary body returning *IssueB2bTaxInvoiceImmediatelyHTTPResponse
func (c *ClientWithResponses) IssueB2bTaxInvoiceImmediatelyWithBodyWithResponse(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceImmediatelyHTTPResponse, error) {
	rsp, err := c.IssueB2bTaxInvoiceImmediatelyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueB2bTaxInvoiceImmediatelyHTTPResponse(rsp)
}

func (c *ClientWithResponses) IssueB2bTaxInvoiceImmediatelyWithResponse(ctx context.Context, params *IssueB2bTaxInvoiceImmediatelyParams, body IssueB2bTaxInvoiceImmediatelyJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceImmediatelyHTTPResponse, error) {
	rsp, err := c.IssueB2bTaxInvoiceImmediately(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueB2bTaxInvoiceImmediatelyHTTPResponse(rsp)
}

// RequestB2bTaxInvoiceReverseIssuanceWithBodyWithResponse request with arbitrary body returning *RequestB2bTaxInvoiceReverseIssuanceHTTPResponse
func (c *ClientWithResponses) RequestB2bTaxInvoiceReverseIssuanceWithBodyWithResponse(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceReverseIssuanceHTTPResponse, error) {
	rsp, err := c.RequestB2bTaxInvoiceReverseIssuanceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestB2bTaxInvoiceReverseIssuanceHTTPResponse(rsp)
}

func (c *ClientWithResponses) RequestB2bTaxInvoiceReverseIssuanceWithResponse(ctx context.Context, params *RequestB2bTaxInvoiceReverseIssuanceParams, body RequestB2bTaxInvoiceReverseIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceReverseIssuanceHTTPResponse, error) {
	rsp, err := c.RequestB2bTaxInvoiceReverseIssuance(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestB2bTaxInvoiceReverseIssuanceHTTPResponse(rsp)
}

// DeleteB2bTaxInvoiceWithResponse request returning *DeleteB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) DeleteB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *DeleteB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*DeleteB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.DeleteB2bTaxInvoice(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteB2bTaxInvoiceHTTPResponse(rsp)
}

// GetB2bTaxInvoiceWithResponse request returning *GetB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoice(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoiceHTTPResponse(rsp)
}

// AttachB2bTaxInvoiceFileWithBodyWithResponse request with arbitrary body returning *AttachB2bTaxInvoiceFileHTTPResponse
func (c *ClientWithResponses) AttachB2bTaxInvoiceFileWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachB2bTaxInvoiceFileHTTPResponse, error) {
	rsp, err := c.AttachB2bTaxInvoiceFileWithBody(ctx, taxInvoiceKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachB2bTaxInvoiceFileHTTPResponse(rsp)
}

func (c *ClientWithResponses) AttachB2bTaxInvoiceFileWithResponse(ctx context.Context, taxInvoiceKey string, params *AttachB2bTaxInvoiceFileParams, body AttachB2bTaxInvoiceFileJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachB2bTaxInvoiceFileHTTPResponse, error) {
	rsp, err := c.AttachB2bTaxInvoiceFile(ctx, taxInvoiceKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachB2bTaxInvoiceFileHTTPResponse(rsp)
}

// GetB2bTaxInvoiceAttachmentsWithResponse request returning *GetB2bTaxInvoiceAttachmentsHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoiceAttachmentsWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoiceAttachmentsParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoiceAttachmentsHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoiceAttachments(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoiceAttachmentsHTTPResponse(rsp)
}

// DeleteB2bTaxInvoiceAttachmentWithResponse request returning *DeleteB2bTaxInvoiceAttachmentHTTPResponse
func (c *ClientWithResponses) DeleteB2bTaxInvoiceAttachmentWithResponse(ctx context.Context, taxInvoiceKey string, attachmentId string, params *DeleteB2bTaxInvoiceAttachmentParams, reqEditors ...RequestEditorFn) (*DeleteB2bTaxInvoiceAttachmentHTTPResponse, error) {
	rsp, err := c.DeleteB2bTaxInvoiceAttachment(ctx, taxInvoiceKey, attachmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteB2bTaxInvoiceAttachmentHTTPResponse(rsp)
}

// CancelB2bTaxInvoiceIssuanceWithBodyWithResponse request with arbitrary body returning *CancelB2bTaxInvoiceIssuanceHTTPResponse
func (c *ClientWithResponses) CancelB2bTaxInvoiceIssuanceWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceIssuanceHTTPResponse, error) {
	rsp, err := c.CancelB2bTaxInvoiceIssuanceWithBody(ctx, taxInvoiceKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelB2bTaxInvoiceIssuanceHTTPResponse(rsp)
}

func (c *ClientWithResponses) CancelB2bTaxInvoiceIssuanceWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceIssuanceParams, body CancelB2bTaxInvoiceIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceIssuanceHTTPResponse, error) {
	rsp, err := c.CancelB2bTaxInvoiceIssuance(ctx, taxInvoiceKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelB2bTaxInvoiceIssuanceHTTPResponse(rsp)
}

// CancelB2bTaxInvoiceRequestWithBodyWithResponse request with arbitrary body returning *CancelB2bTaxInvoiceRequestHTTPResponse
func (c *ClientWithResponses) CancelB2bTaxInvoiceRequestWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceRequestHTTPResponse, error) {
	rsp, err := c.CancelB2bTaxInvoiceRequestWithBody(ctx, taxInvoiceKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelB2bTaxInvoiceRequestHTTPResponse(rsp)
}

func (c *ClientWithResponses) CancelB2bTaxInvoiceRequestWithResponse(ctx context.Context, taxInvoiceKey string, params *CancelB2bTaxInvoiceRequestParams, body CancelB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelB2bTaxInvoiceRequestHTTPResponse, error) {
	rsp, err := c.CancelB2bTaxInvoiceRequest(ctx, taxInvoiceKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelB2bTaxInvoiceRequestHTTPResponse(rsp)
}

// IssueB2bTaxInvoiceWithBodyWithResponse request with arbitrary body returning *IssueB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) IssueB2bTaxInvoiceWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.IssueB2bTaxInvoiceWithBody(ctx, taxInvoiceKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueB2bTaxInvoiceHTTPResponse(rsp)
}

func (c *ClientWithResponses) IssueB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *IssueB2bTaxInvoiceParams, body IssueB2bTaxInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.IssueB2bTaxInvoice(ctx, taxInvoiceKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueB2bTaxInvoiceHTTPResponse(rsp)
}

// GetB2bTaxInvoicePdfDownloadUrlWithResponse request returning *GetB2bTaxInvoicePdfDownloadUrlHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoicePdfDownloadUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePdfDownloadUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePdfDownloadUrlHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoicePdfDownloadUrl(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoicePdfDownloadUrlHTTPResponse(rsp)
}

// GetB2bTaxInvoicePopupUrlWithResponse request returning *GetB2bTaxInvoicePopupUrlHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoicePopupUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePopupUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePopupUrlHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoicePopupUrl(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoicePopupUrlHTTPResponse(rsp)
}

// GetB2bTaxInvoicePrintUrlWithResponse request returning *GetB2bTaxInvoicePrintUrlHTTPResponse
func (c *ClientWithResponses) GetB2bTaxInvoicePrintUrlWithResponse(ctx context.Context, taxInvoiceKey string, params *GetB2bTaxInvoicePrintUrlParams, reqEditors ...RequestEditorFn) (*GetB2bTaxInvoicePrintUrlHTTPResponse, error) {
	rsp, err := c.GetB2bTaxInvoicePrintUrl(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetB2bTaxInvoicePrintUrlHTTPResponse(rsp)
}

// RefuseB2bTaxInvoiceRequestWithBodyWithResponse request with arbitrary body returning *RefuseB2bTaxInvoiceRequestHTTPResponse
func (c *ClientWithResponses) RefuseB2bTaxInvoiceRequestWithBodyWithResponse(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefuseB2bTaxInvoiceRequestHTTPResponse, error) {
	rsp, err := c.RefuseB2bTaxInvoiceRequestWithBody(ctx, taxInvoiceKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefuseB2bTaxInvoiceRequestHTTPResponse(rsp)
}

func (c *ClientWithResponses) RefuseB2bTaxInvoiceRequestWithResponse(ctx context.Context, taxInvoiceKey string, params *RefuseB2bTaxInvoiceRequestParams, body RefuseB2bTaxInvoiceRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*RefuseB2bTaxInvoiceRequestHTTPResponse, error) {
	rsp, err := c.RefuseB2bTaxInvoiceRequest(ctx, taxInvoiceKey, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefuseB2bTaxInvoiceRequestHTTPResponse(rsp)
}

// RequestB2bTaxInvoiceWithResponse request returning *RequestB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) RequestB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *RequestB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*RequestB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.RequestB2bTaxInvoice(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestB2bTaxInvoiceHTTPResponse(rsp)
}

// SendToNtsB2bTaxInvoiceWithResponse request returning *SendToNtsB2bTaxInvoiceHTTPResponse
func (c *ClientWithResponses) SendToNtsB2bTaxInvoiceWithResponse(ctx context.Context, taxInvoiceKey string, params *SendToNtsB2bTaxInvoiceParams, reqEditors ...RequestEditorFn) (*SendToNtsB2bTaxInvoiceHTTPResponse, error) {
	rsp, err := c.SendToNtsB2bTaxInvoice(ctx, taxInvoiceKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendToNtsB2bTaxInvoiceHTTPResponse(rsp)
}

// GetBankInfosWithResponse request returning *GetBankInfosHTTPResponse
func (c *ClientWithResponses) GetBankInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBankInfosHTTPResponse, error) {
	rsp, err := c.GetBankInfos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBankInfosHTTPResponse(rsp)
}

// GetBillingKeyInfosWithBodyWithResponse request with arbitrary body returning *GetBillingKeyInfosHTTPResponse
func (c *ClientWithResponses) GetBillingKeyInfosWithBodyWithResponse(ctx context.Context, params *GetBillingKeyInfosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetBillingKeyInfosHTTPResponse, error) {
	rsp, err := c.GetBillingKeyInfosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingKeyInfosHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetBillingKeyInfosWithResponse(ctx context.Context, params *GetBillingKeyInfosParams, body GetBillingKeyInfosJSONRequestBody, reqEditors ...RequestEditorFn) (*GetBillingKeyInfosHTTPResponse, error) {
	rsp, err := c.GetBillingKeyInfos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingKeyInfosHTTPResponse(rsp)
}

// IssueBillingKeyWithBodyWithResponse request with arbitrary body returning *IssueBillingKeyHTTPResponse
func (c *ClientWithResponses) IssueBillingKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueBillingKeyHTTPResponse, error) {
	rsp, err := c.IssueBillingKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueBillingKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) IssueBillingKeyWithResponse(ctx context.Context, body IssueBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueBillingKeyHTTPResponse, error) {
	rsp, err := c.IssueBillingKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueBillingKeyHTTPResponse(rsp)
}

// ConfirmBillingKeyWithBodyWithResponse request with arbitrary body returning *ConfirmBillingKeyHTTPResponse
func (c *ClientWithResponses) ConfirmBillingKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyHTTPResponse, error) {
	rsp, err := c.ConfirmBillingKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmBillingKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmBillingKeyWithResponse(ctx context.Context, body ConfirmBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyHTTPResponse, error) {
	rsp, err := c.ConfirmBillingKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmBillingKeyHTTPResponse(rsp)
}

// ConfirmBillingKeyIssueAndPayWithBodyWithResponse request with arbitrary body returning *ConfirmBillingKeyIssueAndPayHTTPResponse
func (c *ClientWithResponses) ConfirmBillingKeyIssueAndPayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyIssueAndPayHTTPResponse, error) {
	rsp, err := c.ConfirmBillingKeyIssueAndPayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmBillingKeyIssueAndPayHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmBillingKeyIssueAndPayWithResponse(ctx context.Context, body ConfirmBillingKeyIssueAndPayJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmBillingKeyIssueAndPayHTTPResponse, error) {
	rsp, err := c.ConfirmBillingKeyIssueAndPay(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmBillingKeyIssueAndPayHTTPResponse(rsp)
}

// DeleteBillingKeyWithResponse request returning *DeleteBillingKeyHTTPResponse
func (c *ClientWithResponses) DeleteBillingKeyWithResponse(ctx context.Context, billingKey string, params *DeleteBillingKeyParams, reqEditors ...RequestEditorFn) (*DeleteBillingKeyHTTPResponse, error) {
	rsp, err := c.DeleteBillingKey(ctx, billingKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillingKeyHTTPResponse(rsp)
}

// GetBillingKeyInfoWithResponse request returning *GetBillingKeyInfoHTTPResponse
func (c *ClientWithResponses) GetBillingKeyInfoWithResponse(ctx context.Context, billingKey string, params *GetBillingKeyInfoParams, reqEditors ...RequestEditorFn) (*GetBillingKeyInfoHTTPResponse, error) {
	rsp, err := c.GetBillingKeyInfo(ctx, billingKey, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingKeyInfoHTTPResponse(rsp)
}

// GetCashReceiptsWithBodyWithResponse request with arbitrary body returning *GetCashReceiptsHTTPResponse
func (c *ClientWithResponses) GetCashReceiptsWithBodyWithResponse(ctx context.Context, params *GetCashReceiptsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetCashReceiptsHTTPResponse, error) {
	rsp, err := c.GetCashReceiptsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashReceiptsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetCashReceiptsWithResponse(ctx context.Context, params *GetCashReceiptsParams, body GetCashReceiptsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetCashReceiptsHTTPResponse, error) {
	rsp, err := c.GetCashReceipts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashReceiptsHTTPResponse(rsp)
}

// IssueCashReceiptWithBodyWithResponse request with arbitrary body returning *IssueCashReceiptHTTPResponse
func (c *ClientWithResponses) IssueCashReceiptWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCashReceiptHTTPResponse, error) {
	rsp, err := c.IssueCashReceiptWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCashReceiptHTTPResponse(rsp)
}

func (c *ClientWithResponses) IssueCashReceiptWithResponse(ctx context.Context, body IssueCashReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCashReceiptHTTPResponse, error) {
	rsp, err := c.IssueCashReceipt(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCashReceiptHTTPResponse(rsp)
}

// GetIdentityVerificationsWithBodyWithResponse request with arbitrary body returning *GetIdentityVerificationsHTTPResponse
func (c *ClientWithResponses) GetIdentityVerificationsWithBodyWithResponse(ctx context.Context, params *GetIdentityVerificationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetIdentityVerificationsHTTPResponse, error) {
	rsp, err := c.GetIdentityVerificationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityVerificationsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetIdentityVerificationsWithResponse(ctx context.Context, params *GetIdentityVerificationsParams, body GetIdentityVerificationsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetIdentityVerificationsHTTPResponse, error) {
	rsp, err := c.GetIdentityVerifications(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityVerificationsHTTPResponse(rsp)
}

// GetIdentityVerificationWithResponse request returning *GetIdentityVerificationHTTPResponse
func (c *ClientWithResponses) GetIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, params *GetIdentityVerificationParams, reqEditors ...RequestEditorFn) (*GetIdentityVerificationHTTPResponse, error) {
	rsp, err := c.GetIdentityVerification(ctx, identityVerificationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIdentityVerificationHTTPResponse(rsp)
}

// ConfirmIdentityVerificationWithBodyWithResponse request with arbitrary body returning *ConfirmIdentityVerificationHTTPResponse
func (c *ClientWithResponses) ConfirmIdentityVerificationWithBodyWithResponse(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmIdentityVerificationHTTPResponse, error) {
	rsp, err := c.ConfirmIdentityVerificationWithBody(ctx, identityVerificationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmIdentityVerificationHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, body ConfirmIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmIdentityVerificationHTTPResponse, error) {
	rsp, err := c.ConfirmIdentityVerification(ctx, identityVerificationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmIdentityVerificationHTTPResponse(rsp)
}

// ResendIdentityVerificationWithResponse request returning *ResendIdentityVerificationHTTPResponse
func (c *ClientWithResponses) ResendIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, params *ResendIdentityVerificationParams, reqEditors ...RequestEditorFn) (*ResendIdentityVerificationHTTPResponse, error) {
	rsp, err := c.ResendIdentityVerification(ctx, identityVerificationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendIdentityVerificationHTTPResponse(rsp)
}

// SendIdentityVerificationWithBodyWithResponse request with arbitrary body returning *SendIdentityVerificationHTTPResponse
func (c *ClientWithResponses) SendIdentityVerificationWithBodyWithResponse(ctx context.Context, identityVerificationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendIdentityVerificationHTTPResponse, error) {
	rsp, err := c.SendIdentityVerificationWithBody(ctx, identityVerificationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendIdentityVerificationHTTPResponse(rsp)
}

func (c *ClientWithResponses) SendIdentityVerificationWithResponse(ctx context.Context, identityVerificationId string, body SendIdentityVerificationJSONRequestBody, reqEditors ...RequestEditorFn) (*SendIdentityVerificationHTTPResponse, error) {
	rsp, err := c.SendIdentityVerification(ctx, identityVerificationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendIdentityVerificationHTTPResponse(rsp)
}

// GetKakaopayPaymentOrderWithResponse request returning *GetKakaopayPaymentOrderHTTPResponse
func (c *ClientWithResponses) GetKakaopayPaymentOrderWithResponse(ctx context.Context, params *GetKakaopayPaymentOrderParams, reqEditors ...RequestEditorFn) (*GetKakaopayPaymentOrderHTTPResponse, error) {
	rsp, err := c.GetKakaopayPaymentOrder(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKakaopayPaymentOrderHTTPResponse(rsp)
}

// LoginViaApiSecretWithBodyWithResponse request with arbitrary body returning *LoginViaApiSecretHTTPResponse
func (c *ClientWithResponses) LoginViaApiSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginViaApiSecretHTTPResponse, error) {
	rsp, err := c.LoginViaApiSecretWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginViaApiSecretHTTPResponse(rsp)
}

func (c *ClientWithResponses) LoginViaApiSecretWithResponse(ctx context.Context, body LoginViaApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginViaApiSecretHTTPResponse, error) {
	rsp, err := c.LoginViaApiSecret(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginViaApiSecretHTTPResponse(rsp)
}

// GetAllPaymentEventsByCursorWithBodyWithResponse request with arbitrary body returning *GetAllPaymentEventsByCursorHTTPResponse
func (c *ClientWithResponses) GetAllPaymentEventsByCursorWithBodyWithResponse(ctx context.Context, params *GetAllPaymentEventsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAllPaymentEventsByCursorHTTPResponse, error) {
	rsp, err := c.GetAllPaymentEventsByCursorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPaymentEventsByCursorHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetAllPaymentEventsByCursorWithResponse(ctx context.Context, params *GetAllPaymentEventsByCursorParams, body GetAllPaymentEventsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAllPaymentEventsByCursorHTTPResponse, error) {
	rsp, err := c.GetAllPaymentEventsByCursor(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPaymentEventsByCursorHTTPResponse(rsp)
}

// RevokePaymentSchedulesWithBodyWithResponse request with arbitrary body returning *RevokePaymentSchedulesHTTPResponse
func (c *ClientWithResponses) RevokePaymentSchedulesWithBodyWithResponse(ctx context.Context, params *RevokePaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokePaymentSchedulesHTTPResponse, error) {
	rsp, err := c.RevokePaymentSchedulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePaymentSchedulesHTTPResponse(rsp)
}

func (c *ClientWithResponses) RevokePaymentSchedulesWithResponse(ctx context.Context, params *RevokePaymentSchedulesParams, body RevokePaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokePaymentSchedulesHTTPResponse, error) {
	rsp, err := c.RevokePaymentSchedules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokePaymentSchedulesHTTPResponse(rsp)
}

// GetPaymentSchedulesWithBodyWithResponse request with arbitrary body returning *GetPaymentSchedulesHTTPResponse
func (c *ClientWithResponses) GetPaymentSchedulesWithBodyWithResponse(ctx context.Context, params *GetPaymentSchedulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPaymentSchedulesHTTPResponse, error) {
	rsp, err := c.GetPaymentSchedulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentSchedulesHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPaymentSchedulesWithResponse(ctx context.Context, params *GetPaymentSchedulesParams, body GetPaymentSchedulesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPaymentSchedulesHTTPResponse, error) {
	rsp, err := c.GetPaymentSchedules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentSchedulesHTTPResponse(rsp)
}

// GetPaymentScheduleWithResponse request returning *GetPaymentScheduleHTTPResponse
func (c *ClientWithResponses) GetPaymentScheduleWithResponse(ctx context.Context, paymentScheduleId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleHTTPResponse, error) {
	rsp, err := c.GetPaymentSchedule(ctx, paymentScheduleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentScheduleHTTPResponse(rsp)
}

// GetPaymentsWithBodyWithResponse request with arbitrary body returning *GetPaymentsHTTPResponse
func (c *ClientWithResponses) GetPaymentsWithBodyWithResponse(ctx context.Context, params *GetPaymentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPaymentsHTTPResponse, error) {
	rsp, err := c.GetPaymentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPaymentsWithResponse(ctx context.Context, params *GetPaymentsParams, body GetPaymentsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPaymentsHTTPResponse, error) {
	rsp, err := c.GetPayments(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentsHTTPResponse(rsp)
}

// GetAllPaymentsByCursorWithBodyWithResponse request with arbitrary body returning *GetAllPaymentsByCursorHTTPResponse
func (c *ClientWithResponses) GetAllPaymentsByCursorWithBodyWithResponse(ctx context.Context, params *GetAllPaymentsByCursorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetAllPaymentsByCursorHTTPResponse, error) {
	rsp, err := c.GetAllPaymentsByCursorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPaymentsByCursorHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetAllPaymentsByCursorWithResponse(ctx context.Context, params *GetAllPaymentsByCursorParams, body GetAllPaymentsByCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*GetAllPaymentsByCursorHTTPResponse, error) {
	rsp, err := c.GetAllPaymentsByCursor(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllPaymentsByCursorHTTPResponse(rsp)
}

// GetPaymentWithResponse request returning *GetPaymentHTTPResponse
func (c *ClientWithResponses) GetPaymentWithResponse(ctx context.Context, paymentId string, params *GetPaymentParams, reqEditors ...RequestEditorFn) (*GetPaymentHTTPResponse, error) {
	rsp, err := c.GetPayment(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentHTTPResponse(rsp)
}

// PayWithBillingKeyWithBodyWithResponse request with arbitrary body returning *PayWithBillingKeyHTTPResponse
func (c *ClientWithResponses) PayWithBillingKeyWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PayWithBillingKeyHTTPResponse, error) {
	rsp, err := c.PayWithBillingKeyWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayWithBillingKeyHTTPResponse(rsp)
}

func (c *ClientWithResponses) PayWithBillingKeyWithResponse(ctx context.Context, paymentId string, body PayWithBillingKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PayWithBillingKeyHTTPResponse, error) {
	rsp, err := c.PayWithBillingKey(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayWithBillingKeyHTTPResponse(rsp)
}

// CancelPaymentWithBodyWithResponse request with arbitrary body returning *CancelPaymentHTTPResponse
func (c *ClientWithResponses) CancelPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelPaymentHTTPResponse, error) {
	rsp, err := c.CancelPaymentWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPaymentHTTPResponse(rsp)
}

func (c *ClientWithResponses) CancelPaymentWithResponse(ctx context.Context, paymentId string, body CancelPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelPaymentHTTPResponse, error) {
	rsp, err := c.CancelPayment(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPaymentHTTPResponse(rsp)
}

// CapturePaymentWithBodyWithResponse request with arbitrary body returning *CapturePaymentHTTPResponse
func (c *ClientWithResponses) CapturePaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CapturePaymentHTTPResponse, error) {
	rsp, err := c.CapturePaymentWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCapturePaymentHTTPResponse(rsp)
}

func (c *ClientWithResponses) CapturePaymentWithResponse(ctx context.Context, paymentId string, body CapturePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*CapturePaymentHTTPResponse, error) {
	rsp, err := c.CapturePayment(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCapturePaymentHTTPResponse(rsp)
}

// GetCashReceiptByPaymentIdWithResponse request returning *GetCashReceiptByPaymentIdHTTPResponse
func (c *ClientWithResponses) GetCashReceiptByPaymentIdWithResponse(ctx context.Context, paymentId string, params *GetCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*GetCashReceiptByPaymentIdHTTPResponse, error) {
	rsp, err := c.GetCashReceiptByPaymentId(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashReceiptByPaymentIdHTTPResponse(rsp)
}

// CancelCashReceiptByPaymentIdWithResponse request returning *CancelCashReceiptByPaymentIdHTTPResponse
func (c *ClientWithResponses) CancelCashReceiptByPaymentIdWithResponse(ctx context.Context, paymentId string, params *CancelCashReceiptByPaymentIdParams, reqEditors ...RequestEditorFn) (*CancelCashReceiptByPaymentIdHTTPResponse, error) {
	rsp, err := c.CancelCashReceiptByPaymentId(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelCashReceiptByPaymentIdHTTPResponse(rsp)
}

// ConfirmPaymentWithBodyWithResponse request with arbitrary body returning *ConfirmPaymentHTTPResponse
func (c *ClientWithResponses) ConfirmPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmPaymentHTTPResponse, error) {
	rsp, err := c.ConfirmPaymentWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPaymentHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmPaymentWithResponse(ctx context.Context, paymentId string, body ConfirmPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmPaymentHTTPResponse, error) {
	rsp, err := c.ConfirmPayment(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmPaymentHTTPResponse(rsp)
}

// ConfirmEscrowWithBodyWithResponse request with arbitrary body returning *ConfirmEscrowHTTPResponse
func (c *ClientWithResponses) ConfirmEscrowWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfirmEscrowHTTPResponse, error) {
	rsp, err := c.ConfirmEscrowWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmEscrowHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConfirmEscrowWithResponse(ctx context.Context, paymentId string, body ConfirmEscrowJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfirmEscrowHTTPResponse, error) {
	rsp, err := c.ConfirmEscrow(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfirmEscrowHTTPResponse(rsp)
}

// ModifyEscrowLogisticsWithBodyWithResponse request with arbitrary body returning *ModifyEscrowLogisticsHTTPResponse
func (c *ClientWithResponses) ModifyEscrowLogisticsWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyEscrowLogisticsHTTPResponse, error) {
	rsp, err := c.ModifyEscrowLogisticsWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEscrowLogisticsHTTPResponse(rsp)
}

func (c *ClientWithResponses) ModifyEscrowLogisticsWithResponse(ctx context.Context, paymentId string, body ModifyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyEscrowLogisticsHTTPResponse, error) {
	rsp, err := c.ModifyEscrowLogistics(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyEscrowLogisticsHTTPResponse(rsp)
}

// ApplyEscrowLogisticsWithBodyWithResponse request with arbitrary body returning *ApplyEscrowLogisticsHTTPResponse
func (c *ClientWithResponses) ApplyEscrowLogisticsWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyEscrowLogisticsHTTPResponse, error) {
	rsp, err := c.ApplyEscrowLogisticsWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyEscrowLogisticsHTTPResponse(rsp)
}

func (c *ClientWithResponses) ApplyEscrowLogisticsWithResponse(ctx context.Context, paymentId string, body ApplyEscrowLogisticsJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyEscrowLogisticsHTTPResponse, error) {
	rsp, err := c.ApplyEscrowLogistics(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyEscrowLogisticsHTTPResponse(rsp)
}

// PayInstantlyWithBodyWithResponse request with arbitrary body returning *PayInstantlyHTTPResponse
func (c *ClientWithResponses) PayInstantlyWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PayInstantlyHTTPResponse, error) {
	rsp, err := c.PayInstantlyWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayInstantlyHTTPResponse(rsp)
}

func (c *ClientWithResponses) PayInstantlyWithResponse(ctx context.Context, paymentId string, body PayInstantlyJSONRequestBody, reqEditors ...RequestEditorFn) (*PayInstantlyHTTPResponse, error) {
	rsp, err := c.PayInstantly(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePayInstantlyHTTPResponse(rsp)
}

// PreRegisterPaymentWithBodyWithResponse request with arbitrary body returning *PreRegisterPaymentHTTPResponse
func (c *ClientWithResponses) PreRegisterPaymentWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreRegisterPaymentHTTPResponse, error) {
	rsp, err := c.PreRegisterPaymentWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreRegisterPaymentHTTPResponse(rsp)
}

func (c *ClientWithResponses) PreRegisterPaymentWithResponse(ctx context.Context, paymentId string, body PreRegisterPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (*PreRegisterPaymentHTTPResponse, error) {
	rsp, err := c.PreRegisterPayment(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreRegisterPaymentHTTPResponse(rsp)
}

// RegisterStoreReceiptWithBodyWithResponse request with arbitrary body returning *RegisterStoreReceiptHTTPResponse
func (c *ClientWithResponses) RegisterStoreReceiptWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterStoreReceiptHTTPResponse, error) {
	rsp, err := c.RegisterStoreReceiptWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterStoreReceiptHTTPResponse(rsp)
}

func (c *ClientWithResponses) RegisterStoreReceiptWithResponse(ctx context.Context, paymentId string, body RegisterStoreReceiptJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterStoreReceiptHTTPResponse, error) {
	rsp, err := c.RegisterStoreReceipt(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterStoreReceiptHTTPResponse(rsp)
}

// ResendWebhookWithBodyWithResponse request with arbitrary body returning *ResendWebhookHTTPResponse
func (c *ClientWithResponses) ResendWebhookWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResendWebhookHTTPResponse, error) {
	rsp, err := c.ResendWebhookWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendWebhookHTTPResponse(rsp)
}

func (c *ClientWithResponses) ResendWebhookWithResponse(ctx context.Context, paymentId string, body ResendWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ResendWebhookHTTPResponse, error) {
	rsp, err := c.ResendWebhook(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResendWebhookHTTPResponse(rsp)
}

// CreatePaymentScheduleWithBodyWithResponse request with arbitrary body returning *CreatePaymentScheduleHTTPResponse
func (c *ClientWithResponses) CreatePaymentScheduleWithBodyWithResponse(ctx context.Context, paymentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePaymentScheduleHTTPResponse, error) {
	rsp, err := c.CreatePaymentScheduleWithBody(ctx, paymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentScheduleHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePaymentScheduleWithResponse(ctx context.Context, paymentId string, body CreatePaymentScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePaymentScheduleHTTPResponse, error) {
	rsp, err := c.CreatePaymentSchedule(ctx, paymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePaymentScheduleHTTPResponse(rsp)
}

// GetPaymentTransactionsWithResponse request returning *GetPaymentTransactionsHTTPResponse
func (c *ClientWithResponses) GetPaymentTransactionsWithResponse(ctx context.Context, paymentId string, params *GetPaymentTransactionsParams, reqEditors ...RequestEditorFn) (*GetPaymentTransactionsHTTPResponse, error) {
	rsp, err := c.GetPaymentTransactions(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentTransactionsHTTPResponse(rsp)
}

// CloseVirtualAccountWithResponse request returning *CloseVirtualAccountHTTPResponse
func (c *ClientWithResponses) CloseVirtualAccountWithResponse(ctx context.Context, paymentId string, params *CloseVirtualAccountParams, reqEditors ...RequestEditorFn) (*CloseVirtualAccountHTTPResponse, error) {
	rsp, err := c.CloseVirtualAccount(ctx, paymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseVirtualAccountHTTPResponse(rsp)
}

// GetPlatformAccountTransfersWithBodyWithResponse request with arbitrary body returning *GetPlatformAccountTransfersHTTPResponse
func (c *ClientWithResponses) GetPlatformAccountTransfersWithBodyWithResponse(ctx context.Context, params *GetPlatformAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformAccountTransfersHTTPResponse, error) {
	rsp, err := c.GetPlatformAccountTransfersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAccountTransfersHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformAccountTransfersWithResponse(ctx context.Context, params *GetPlatformAccountTransfersParams, body GetPlatformAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformAccountTransfersHTTPResponse, error) {
	rsp, err := c.GetPlatformAccountTransfers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAccountTransfersHTTPResponse(rsp)
}

// GetPlatformAdditionalFeePoliciesWithBodyWithResponse request with arbitrary body returning *GetPlatformAdditionalFeePoliciesHTTPResponse
func (c *ClientWithResponses) GetPlatformAdditionalFeePoliciesWithBodyWithResponse(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePoliciesHTTPResponse, error) {
	rsp, err := c.GetPlatformAdditionalFeePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAdditionalFeePoliciesHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformAdditionalFeePoliciesWithResponse(ctx context.Context, params *GetPlatformAdditionalFeePoliciesParams, body GetPlatformAdditionalFeePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePoliciesHTTPResponse, error) {
	rsp, err := c.GetPlatformAdditionalFeePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAdditionalFeePoliciesHTTPResponse(rsp)
}

// CreatePlatformAdditionalFeePolicyWithBodyWithResponse request with arbitrary body returning *CreatePlatformAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) CreatePlatformAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.CreatePlatformAdditionalFeePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformAdditionalFeePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformAdditionalFeePolicyWithResponse(ctx context.Context, params *CreatePlatformAdditionalFeePolicyParams, body CreatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.CreatePlatformAdditionalFeePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformAdditionalFeePolicyHTTPResponse(rsp)
}

// GetPlatformAdditionalFeePolicyWithResponse request returning *GetPlatformAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) GetPlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.GetPlatformAdditionalFeePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAdditionalFeePolicyHTTPResponse(rsp)
}

// UpdatePlatformAdditionalFeePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePlatformAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) UpdatePlatformAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.UpdatePlatformAdditionalFeePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformAdditionalFeePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *UpdatePlatformAdditionalFeePolicyParams, body UpdatePlatformAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.UpdatePlatformAdditionalFeePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformAdditionalFeePolicyHTTPResponse(rsp)
}

// ArchivePlatformAdditionalFeePolicyWithResponse request returning *ArchivePlatformAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) ArchivePlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *ArchivePlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*ArchivePlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.ArchivePlatformAdditionalFeePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatformAdditionalFeePolicyHTTPResponse(rsp)
}

// RecoverPlatformAdditionalFeePolicyWithResponse request returning *RecoverPlatformAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) RecoverPlatformAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *RecoverPlatformAdditionalFeePolicyParams, reqEditors ...RequestEditorFn) (*RecoverPlatformAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.RecoverPlatformAdditionalFeePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverPlatformAdditionalFeePolicyHTTPResponse(rsp)
}

// CancelPlatformAdditionalFeePolicyScheduleWithResponse request returning *CancelPlatformAdditionalFeePolicyScheduleHTTPResponse
func (c *ClientWithResponses) CancelPlatformAdditionalFeePolicyScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformAdditionalFeePolicyScheduleHTTPResponse, error) {
	rsp, err := c.CancelPlatformAdditionalFeePolicySchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPlatformAdditionalFeePolicyScheduleHTTPResponse(rsp)
}

// GetPlatformAdditionalFeePolicyScheduleWithResponse request returning *GetPlatformAdditionalFeePolicyScheduleHTTPResponse
func (c *ClientWithResponses) GetPlatformAdditionalFeePolicyScheduleWithResponse(ctx context.Context, id string, params *GetPlatformAdditionalFeePolicyScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformAdditionalFeePolicyScheduleHTTPResponse, error) {
	rsp, err := c.GetPlatformAdditionalFeePolicySchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAdditionalFeePolicyScheduleHTTPResponse(rsp)
}

// ScheduleAdditionalFeePolicyWithBodyWithResponse request with arbitrary body returning *ScheduleAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) ScheduleAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.ScheduleAdditionalFeePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleAdditionalFeePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) ScheduleAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *ScheduleAdditionalFeePolicyParams, body ScheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.ScheduleAdditionalFeePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleAdditionalFeePolicyHTTPResponse(rsp)
}

// RescheduleAdditionalFeePolicyWithBodyWithResponse request with arbitrary body returning *RescheduleAdditionalFeePolicyHTTPResponse
func (c *ClientWithResponses) RescheduleAdditionalFeePolicyWithBodyWithResponse(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.RescheduleAdditionalFeePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleAdditionalFeePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) RescheduleAdditionalFeePolicyWithResponse(ctx context.Context, id string, params *RescheduleAdditionalFeePolicyParams, body RescheduleAdditionalFeePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleAdditionalFeePolicyHTTPResponse, error) {
	rsp, err := c.RescheduleAdditionalFeePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleAdditionalFeePolicyHTTPResponse(rsp)
}

// GetPlatformAccountHolderWithResponse request returning *GetPlatformAccountHolderHTTPResponse
func (c *ClientWithResponses) GetPlatformAccountHolderWithResponse(ctx context.Context, bank Bank, accountNumber string, params *GetPlatformAccountHolderParams, reqEditors ...RequestEditorFn) (*GetPlatformAccountHolderHTTPResponse, error) {
	rsp, err := c.GetPlatformAccountHolder(ctx, bank, accountNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAccountHolderHTTPResponse(rsp)
}

// GetPlatformBulkAccountTransfersWithBodyWithResponse request with arbitrary body returning *GetPlatformBulkAccountTransfersHTTPResponse
func (c *ClientWithResponses) GetPlatformBulkAccountTransfersWithBodyWithResponse(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformBulkAccountTransfersHTTPResponse, error) {
	rsp, err := c.GetPlatformBulkAccountTransfersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformBulkAccountTransfersHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformBulkAccountTransfersWithResponse(ctx context.Context, params *GetPlatformBulkAccountTransfersParams, body GetPlatformBulkAccountTransfersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformBulkAccountTransfersHTTPResponse, error) {
	rsp, err := c.GetPlatformBulkAccountTransfers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformBulkAccountTransfersHTTPResponse(rsp)
}

// GetPlatformBulkPayoutsWithBodyWithResponse request with arbitrary body returning *GetPlatformBulkPayoutsHTTPResponse
func (c *ClientWithResponses) GetPlatformBulkPayoutsWithBodyWithResponse(ctx context.Context, params *GetPlatformBulkPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformBulkPayoutsHTTPResponse, error) {
	rsp, err := c.GetPlatformBulkPayoutsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformBulkPayoutsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformBulkPayoutsWithResponse(ctx context.Context, params *GetPlatformBulkPayoutsParams, body GetPlatformBulkPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformBulkPayoutsHTTPResponse, error) {
	rsp, err := c.GetPlatformBulkPayouts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformBulkPayoutsHTTPResponse(rsp)
}

// GetPlatformCompanyStateWithResponse request returning *GetPlatformCompanyStateHTTPResponse
func (c *ClientWithResponses) GetPlatformCompanyStateWithResponse(ctx context.Context, businessRegistrationNumber string, params *GetPlatformCompanyStateParams, reqEditors ...RequestEditorFn) (*GetPlatformCompanyStateHTTPResponse, error) {
	rsp, err := c.GetPlatformCompanyState(ctx, businessRegistrationNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformCompanyStateHTTPResponse(rsp)
}

// GetPlatformContractsWithBodyWithResponse request with arbitrary body returning *GetPlatformContractsHTTPResponse
func (c *ClientWithResponses) GetPlatformContractsWithBodyWithResponse(ctx context.Context, params *GetPlatformContractsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformContractsHTTPResponse, error) {
	rsp, err := c.GetPlatformContractsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformContractsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformContractsWithResponse(ctx context.Context, params *GetPlatformContractsParams, body GetPlatformContractsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformContractsHTTPResponse, error) {
	rsp, err := c.GetPlatformContracts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformContractsHTTPResponse(rsp)
}

// CreatePlatformContractWithBodyWithResponse request with arbitrary body returning *CreatePlatformContractHTTPResponse
func (c *ClientWithResponses) CreatePlatformContractWithBodyWithResponse(ctx context.Context, params *CreatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformContractHTTPResponse, error) {
	rsp, err := c.CreatePlatformContractWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformContractHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformContractWithResponse(ctx context.Context, params *CreatePlatformContractParams, body CreatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformContractHTTPResponse, error) {
	rsp, err := c.CreatePlatformContract(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformContractHTTPResponse(rsp)
}

// GetPlatformContractWithResponse request returning *GetPlatformContractHTTPResponse
func (c *ClientWithResponses) GetPlatformContractWithResponse(ctx context.Context, id string, params *GetPlatformContractParams, reqEditors ...RequestEditorFn) (*GetPlatformContractHTTPResponse, error) {
	rsp, err := c.GetPlatformContract(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformContractHTTPResponse(rsp)
}

// UpdatePlatformContractWithBodyWithResponse request with arbitrary body returning *UpdatePlatformContractHTTPResponse
func (c *ClientWithResponses) UpdatePlatformContractWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformContractHTTPResponse, error) {
	rsp, err := c.UpdatePlatformContractWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformContractHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlatformContractWithResponse(ctx context.Context, id string, params *UpdatePlatformContractParams, body UpdatePlatformContractJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformContractHTTPResponse, error) {
	rsp, err := c.UpdatePlatformContract(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformContractHTTPResponse(rsp)
}

// ArchivePlatformContractWithResponse request returning *ArchivePlatformContractHTTPResponse
func (c *ClientWithResponses) ArchivePlatformContractWithResponse(ctx context.Context, id string, params *ArchivePlatformContractParams, reqEditors ...RequestEditorFn) (*ArchivePlatformContractHTTPResponse, error) {
	rsp, err := c.ArchivePlatformContract(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatformContractHTTPResponse(rsp)
}

// RecoverPlatformContractWithResponse request returning *RecoverPlatformContractHTTPResponse
func (c *ClientWithResponses) RecoverPlatformContractWithResponse(ctx context.Context, id string, params *RecoverPlatformContractParams, reqEditors ...RequestEditorFn) (*RecoverPlatformContractHTTPResponse, error) {
	rsp, err := c.RecoverPlatformContract(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverPlatformContractHTTPResponse(rsp)
}

// CancelPlatformContractScheduleWithResponse request returning *CancelPlatformContractScheduleHTTPResponse
func (c *ClientWithResponses) CancelPlatformContractScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformContractScheduleHTTPResponse, error) {
	rsp, err := c.CancelPlatformContractSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPlatformContractScheduleHTTPResponse(rsp)
}

// GetPlatformContractScheduleWithResponse request returning *GetPlatformContractScheduleHTTPResponse
func (c *ClientWithResponses) GetPlatformContractScheduleWithResponse(ctx context.Context, id string, params *GetPlatformContractScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformContractScheduleHTTPResponse, error) {
	rsp, err := c.GetPlatformContractSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformContractScheduleHTTPResponse(rsp)
}

// ScheduleContractWithBodyWithResponse request with arbitrary body returning *ScheduleContractHTTPResponse
func (c *ClientWithResponses) ScheduleContractWithBodyWithResponse(ctx context.Context, id string, params *ScheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleContractHTTPResponse, error) {
	rsp, err := c.ScheduleContractWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleContractHTTPResponse(rsp)
}

func (c *ClientWithResponses) ScheduleContractWithResponse(ctx context.Context, id string, params *ScheduleContractParams, body ScheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleContractHTTPResponse, error) {
	rsp, err := c.ScheduleContract(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleContractHTTPResponse(rsp)
}

// RescheduleContractWithBodyWithResponse request with arbitrary body returning *RescheduleContractHTTPResponse
func (c *ClientWithResponses) RescheduleContractWithBodyWithResponse(ctx context.Context, id string, params *RescheduleContractParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleContractHTTPResponse, error) {
	rsp, err := c.RescheduleContractWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleContractHTTPResponse(rsp)
}

func (c *ClientWithResponses) RescheduleContractWithResponse(ctx context.Context, id string, params *RescheduleContractParams, body RescheduleContractJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleContractHTTPResponse, error) {
	rsp, err := c.RescheduleContract(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleContractHTTPResponse(rsp)
}

// GetPlatformDiscountSharePoliciesWithBodyWithResponse request with arbitrary body returning *GetPlatformDiscountSharePoliciesHTTPResponse
func (c *ClientWithResponses) GetPlatformDiscountSharePoliciesWithBodyWithResponse(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePoliciesHTTPResponse, error) {
	rsp, err := c.GetPlatformDiscountSharePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDiscountSharePoliciesHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformDiscountSharePoliciesWithResponse(ctx context.Context, params *GetPlatformDiscountSharePoliciesParams, body GetPlatformDiscountSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePoliciesHTTPResponse, error) {
	rsp, err := c.GetPlatformDiscountSharePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDiscountSharePoliciesHTTPResponse(rsp)
}

// CreatePlatformDiscountSharePolicyWithBodyWithResponse request with arbitrary body returning *CreatePlatformDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) CreatePlatformDiscountSharePolicyWithBodyWithResponse(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.CreatePlatformDiscountSharePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformDiscountSharePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformDiscountSharePolicyWithResponse(ctx context.Context, params *CreatePlatformDiscountSharePolicyParams, body CreatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.CreatePlatformDiscountSharePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformDiscountSharePolicyHTTPResponse(rsp)
}

// GetPlatformDiscountSharePolicyWithResponse request returning *GetPlatformDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) GetPlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.GetPlatformDiscountSharePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDiscountSharePolicyHTTPResponse(rsp)
}

// UpdatePlatformDiscountSharePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePlatformDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) UpdatePlatformDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.UpdatePlatformDiscountSharePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformDiscountSharePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *UpdatePlatformDiscountSharePolicyParams, body UpdatePlatformDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.UpdatePlatformDiscountSharePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformDiscountSharePolicyHTTPResponse(rsp)
}

// ArchivePlatformDiscountSharePolicyWithResponse request returning *ArchivePlatformDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) ArchivePlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *ArchivePlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*ArchivePlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.ArchivePlatformDiscountSharePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatformDiscountSharePolicyHTTPResponse(rsp)
}

// RecoverPlatformDiscountSharePolicyWithResponse request returning *RecoverPlatformDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) RecoverPlatformDiscountSharePolicyWithResponse(ctx context.Context, id string, params *RecoverPlatformDiscountSharePolicyParams, reqEditors ...RequestEditorFn) (*RecoverPlatformDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.RecoverPlatformDiscountSharePolicy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverPlatformDiscountSharePolicyHTTPResponse(rsp)
}

// CancelPlatformDiscountSharePolicyScheduleWithResponse request returning *CancelPlatformDiscountSharePolicyScheduleHTTPResponse
func (c *ClientWithResponses) CancelPlatformDiscountSharePolicyScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformDiscountSharePolicyScheduleHTTPResponse, error) {
	rsp, err := c.CancelPlatformDiscountSharePolicySchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPlatformDiscountSharePolicyScheduleHTTPResponse(rsp)
}

// GetPlatformDiscountSharePolicyScheduleWithResponse request returning *GetPlatformDiscountSharePolicyScheduleHTTPResponse
func (c *ClientWithResponses) GetPlatformDiscountSharePolicyScheduleWithResponse(ctx context.Context, id string, params *GetPlatformDiscountSharePolicyScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyScheduleHTTPResponse, error) {
	rsp, err := c.GetPlatformDiscountSharePolicySchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDiscountSharePolicyScheduleHTTPResponse(rsp)
}

// ScheduleDiscountSharePolicyWithBodyWithResponse request with arbitrary body returning *ScheduleDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) ScheduleDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScheduleDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.ScheduleDiscountSharePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleDiscountSharePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) ScheduleDiscountSharePolicyWithResponse(ctx context.Context, id string, params *ScheduleDiscountSharePolicyParams, body ScheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScheduleDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.ScheduleDiscountSharePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScheduleDiscountSharePolicyHTTPResponse(rsp)
}

// RescheduleDiscountSharePolicyWithBodyWithResponse request with arbitrary body returning *RescheduleDiscountSharePolicyHTTPResponse
func (c *ClientWithResponses) RescheduleDiscountSharePolicyWithBodyWithResponse(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RescheduleDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.RescheduleDiscountSharePolicyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleDiscountSharePolicyHTTPResponse(rsp)
}

func (c *ClientWithResponses) RescheduleDiscountSharePolicyWithResponse(ctx context.Context, id string, params *RescheduleDiscountSharePolicyParams, body RescheduleDiscountSharePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*RescheduleDiscountSharePolicyHTTPResponse, error) {
	rsp, err := c.RescheduleDiscountSharePolicy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRescheduleDiscountSharePolicyHTTPResponse(rsp)
}

// GetPlatformDiscountSharePolicyFilterOptionsWithResponse request returning *GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse
func (c *ClientWithResponses) GetPlatformDiscountSharePolicyFilterOptionsWithResponse(ctx context.Context, params *GetPlatformDiscountSharePolicyFilterOptionsParams, reqEditors ...RequestEditorFn) (*GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse, error) {
	rsp, err := c.GetPlatformDiscountSharePolicyFilterOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformDiscountSharePolicyFilterOptionsHTTPResponse(rsp)
}

// GetPlatformPartnerFilterOptionsWithResponse request returning *GetPlatformPartnerFilterOptionsHTTPResponse
func (c *ClientWithResponses) GetPlatformPartnerFilterOptionsWithResponse(ctx context.Context, params *GetPlatformPartnerFilterOptionsParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerFilterOptionsHTTPResponse, error) {
	rsp, err := c.GetPlatformPartnerFilterOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnerFilterOptionsHTTPResponse(rsp)
}

// GetPlatformPartnerSettlementsWithBodyWithResponse request with arbitrary body returning *GetPlatformPartnerSettlementsHTTPResponse
func (c *ClientWithResponses) GetPlatformPartnerSettlementsWithBodyWithResponse(ctx context.Context, params *GetPlatformPartnerSettlementsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPartnerSettlementsHTTPResponse, error) {
	rsp, err := c.GetPlatformPartnerSettlementsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnerSettlementsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformPartnerSettlementsWithResponse(ctx context.Context, params *GetPlatformPartnerSettlementsParams, body GetPlatformPartnerSettlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPartnerSettlementsHTTPResponse, error) {
	rsp, err := c.GetPlatformPartnerSettlements(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnerSettlementsHTTPResponse(rsp)
}

// GetPlatformPartnersWithBodyWithResponse request with arbitrary body returning *GetPlatformPartnersHTTPResponse
func (c *ClientWithResponses) GetPlatformPartnersWithBodyWithResponse(ctx context.Context, params *GetPlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPartnersHTTPResponse, error) {
	rsp, err := c.GetPlatformPartnersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnersHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformPartnersWithResponse(ctx context.Context, params *GetPlatformPartnersParams, body GetPlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPartnersHTTPResponse, error) {
	rsp, err := c.GetPlatformPartners(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnersHTTPResponse(rsp)
}

// CreatePlatformPartnerWithBodyWithResponse request with arbitrary body returning *CreatePlatformPartnerHTTPResponse
func (c *ClientWithResponses) CreatePlatformPartnerWithBodyWithResponse(ctx context.Context, params *CreatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformPartnerHTTPResponse, error) {
	rsp, err := c.CreatePlatformPartnerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformPartnerHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformPartnerWithResponse(ctx context.Context, params *CreatePlatformPartnerParams, body CreatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformPartnerHTTPResponse, error) {
	rsp, err := c.CreatePlatformPartner(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformPartnerHTTPResponse(rsp)
}

// CreatePlatformPartnersWithBodyWithResponse request with arbitrary body returning *CreatePlatformPartnersHTTPResponse
func (c *ClientWithResponses) CreatePlatformPartnersWithBodyWithResponse(ctx context.Context, params *CreatePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformPartnersHTTPResponse, error) {
	rsp, err := c.CreatePlatformPartnersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformPartnersHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformPartnersWithResponse(ctx context.Context, params *CreatePlatformPartnersParams, body CreatePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformPartnersHTTPResponse, error) {
	rsp, err := c.CreatePlatformPartners(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformPartnersHTTPResponse(rsp)
}

// ConnectBulkPartnerMemberCompanyWithBodyWithResponse request with arbitrary body returning *ConnectBulkPartnerMemberCompanyHTTPResponse
func (c *ClientWithResponses) ConnectBulkPartnerMemberCompanyWithBodyWithResponse(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectBulkPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.ConnectBulkPartnerMemberCompanyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectBulkPartnerMemberCompanyHTTPResponse(rsp)
}

func (c *ClientWithResponses) ConnectBulkPartnerMemberCompanyWithResponse(ctx context.Context, params *ConnectBulkPartnerMemberCompanyParams, body ConnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectBulkPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.ConnectBulkPartnerMemberCompany(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectBulkPartnerMemberCompanyHTTPResponse(rsp)
}

// ConnectPartnerMemberCompanyWithResponse request returning *ConnectPartnerMemberCompanyHTTPResponse
func (c *ClientWithResponses) ConnectPartnerMemberCompanyWithResponse(ctx context.Context, id string, params *ConnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*ConnectPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.ConnectPartnerMemberCompany(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectPartnerMemberCompanyHTTPResponse(rsp)
}

// DisconnectBulkPartnerMemberCompanyWithBodyWithResponse request with arbitrary body returning *DisconnectBulkPartnerMemberCompanyHTTPResponse
func (c *ClientWithResponses) DisconnectBulkPartnerMemberCompanyWithBodyWithResponse(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisconnectBulkPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.DisconnectBulkPartnerMemberCompanyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectBulkPartnerMemberCompanyHTTPResponse(rsp)
}

func (c *ClientWithResponses) DisconnectBulkPartnerMemberCompanyWithResponse(ctx context.Context, params *DisconnectBulkPartnerMemberCompanyParams, body DisconnectBulkPartnerMemberCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (*DisconnectBulkPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.DisconnectBulkPartnerMemberCompany(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectBulkPartnerMemberCompanyHTTPResponse(rsp)
}

// DisconnectPartnerMemberCompanyWithResponse request returning *DisconnectPartnerMemberCompanyHTTPResponse
func (c *ClientWithResponses) DisconnectPartnerMemberCompanyWithResponse(ctx context.Context, id string, params *DisconnectPartnerMemberCompanyParams, reqEditors ...RequestEditorFn) (*DisconnectPartnerMemberCompanyHTTPResponse, error) {
	rsp, err := c.DisconnectPartnerMemberCompany(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectPartnerMemberCompanyHTTPResponse(rsp)
}

// SchedulePlatformPartnersWithBodyWithResponse request with arbitrary body returning *SchedulePlatformPartnersHTTPResponse
func (c *ClientWithResponses) SchedulePlatformPartnersWithBodyWithResponse(ctx context.Context, params *SchedulePlatformPartnersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchedulePlatformPartnersHTTPResponse, error) {
	rsp, err := c.SchedulePlatformPartnersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchedulePlatformPartnersHTTPResponse(rsp)
}

func (c *ClientWithResponses) SchedulePlatformPartnersWithResponse(ctx context.Context, params *SchedulePlatformPartnersParams, body SchedulePlatformPartnersJSONRequestBody, reqEditors ...RequestEditorFn) (*SchedulePlatformPartnersHTTPResponse, error) {
	rsp, err := c.SchedulePlatformPartners(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchedulePlatformPartnersHTTPResponse(rsp)
}

// GetPlatformPartnerWithResponse request returning *GetPlatformPartnerHTTPResponse
func (c *ClientWithResponses) GetPlatformPartnerWithResponse(ctx context.Context, id string, params *GetPlatformPartnerParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerHTTPResponse, error) {
	rsp, err := c.GetPlatformPartner(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnerHTTPResponse(rsp)
}

// UpdatePlatformPartnerWithBodyWithResponse request with arbitrary body returning *UpdatePlatformPartnerHTTPResponse
func (c *ClientWithResponses) UpdatePlatformPartnerWithBodyWithResponse(ctx context.Context, id string, params *UpdatePlatformPartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformPartnerHTTPResponse, error) {
	rsp, err := c.UpdatePlatformPartnerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformPartnerHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlatformPartnerWithResponse(ctx context.Context, id string, params *UpdatePlatformPartnerParams, body UpdatePlatformPartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformPartnerHTTPResponse, error) {
	rsp, err := c.UpdatePlatformPartner(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformPartnerHTTPResponse(rsp)
}

// ArchivePlatformPartnerWithResponse request returning *ArchivePlatformPartnerHTTPResponse
func (c *ClientWithResponses) ArchivePlatformPartnerWithResponse(ctx context.Context, id string, params *ArchivePlatformPartnerParams, reqEditors ...RequestEditorFn) (*ArchivePlatformPartnerHTTPResponse, error) {
	rsp, err := c.ArchivePlatformPartner(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatformPartnerHTTPResponse(rsp)
}

// RecoverPlatformPartnerWithResponse request returning *RecoverPlatformPartnerHTTPResponse
func (c *ClientWithResponses) RecoverPlatformPartnerWithResponse(ctx context.Context, id string, params *RecoverPlatformPartnerParams, reqEditors ...RequestEditorFn) (*RecoverPlatformPartnerHTTPResponse, error) {
	rsp, err := c.RecoverPlatformPartner(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverPlatformPartnerHTTPResponse(rsp)
}

// CancelPlatformPartnerScheduleWithResponse request returning *CancelPlatformPartnerScheduleHTTPResponse
func (c *ClientWithResponses) CancelPlatformPartnerScheduleWithResponse(ctx context.Context, id string, params *CancelPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*CancelPlatformPartnerScheduleHTTPResponse, error) {
	rsp, err := c.CancelPlatformPartnerSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelPlatformPartnerScheduleHTTPResponse(rsp)
}

// GetPlatformPartnerScheduleWithResponse request returning *GetPlatformPartnerScheduleHTTPResponse
func (c *ClientWithResponses) GetPlatformPartnerScheduleWithResponse(ctx context.Context, id string, params *GetPlatformPartnerScheduleParams, reqEditors ...RequestEditorFn) (*GetPlatformPartnerScheduleHTTPResponse, error) {
	rsp, err := c.GetPlatformPartnerSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPartnerScheduleHTTPResponse(rsp)
}

// SchedulePartnerWithBodyWithResponse request with arbitrary body returning *SchedulePartnerHTTPResponse
func (c *ClientWithResponses) SchedulePartnerWithBodyWithResponse(ctx context.Context, id string, params *SchedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchedulePartnerHTTPResponse, error) {
	rsp, err := c.SchedulePartnerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchedulePartnerHTTPResponse(rsp)
}

func (c *ClientWithResponses) SchedulePartnerWithResponse(ctx context.Context, id string, params *SchedulePartnerParams, body SchedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*SchedulePartnerHTTPResponse, error) {
	rsp, err := c.SchedulePartner(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchedulePartnerHTTPResponse(rsp)
}

// ReschedulePartnerWithBodyWithResponse request with arbitrary body returning *ReschedulePartnerHTTPResponse
func (c *ClientWithResponses) ReschedulePartnerWithBodyWithResponse(ctx context.Context, id string, params *ReschedulePartnerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReschedulePartnerHTTPResponse, error) {
	rsp, err := c.ReschedulePartnerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReschedulePartnerHTTPResponse(rsp)
}

func (c *ClientWithResponses) ReschedulePartnerWithResponse(ctx context.Context, id string, params *ReschedulePartnerParams, body ReschedulePartnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReschedulePartnerHTTPResponse, error) {
	rsp, err := c.ReschedulePartner(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReschedulePartnerHTTPResponse(rsp)
}

// GetPlatformPayoutsWithBodyWithResponse request with arbitrary body returning *GetPlatformPayoutsHTTPResponse
func (c *ClientWithResponses) GetPlatformPayoutsWithBodyWithResponse(ctx context.Context, params *GetPlatformPayoutsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformPayoutsHTTPResponse, error) {
	rsp, err := c.GetPlatformPayoutsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPayoutsHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformPayoutsWithResponse(ctx context.Context, params *GetPlatformPayoutsParams, body GetPlatformPayoutsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformPayoutsHTTPResponse, error) {
	rsp, err := c.GetPlatformPayouts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformPayoutsHTTPResponse(rsp)
}

// GetPlatformSettingWithResponse request returning *GetPlatformSettingHTTPResponse
func (c *ClientWithResponses) GetPlatformSettingWithResponse(ctx context.Context, params *GetPlatformSettingParams, reqEditors ...RequestEditorFn) (*GetPlatformSettingHTTPResponse, error) {
	rsp, err := c.GetPlatformSetting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformSettingHTTPResponse(rsp)
}

// UpdatePlatformSettingWithBodyWithResponse request with arbitrary body returning *UpdatePlatformSettingHTTPResponse
func (c *ClientWithResponses) UpdatePlatformSettingWithBodyWithResponse(ctx context.Context, params *UpdatePlatformSettingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlatformSettingHTTPResponse, error) {
	rsp, err := c.UpdatePlatformSettingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformSettingHTTPResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlatformSettingWithResponse(ctx context.Context, params *UpdatePlatformSettingParams, body UpdatePlatformSettingJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlatformSettingHTTPResponse, error) {
	rsp, err := c.UpdatePlatformSetting(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlatformSettingHTTPResponse(rsp)
}

// GetPlatformTransferSummariesWithBodyWithResponse request with arbitrary body returning *GetPlatformTransferSummariesHTTPResponse
func (c *ClientWithResponses) GetPlatformTransferSummariesWithBodyWithResponse(ctx context.Context, params *GetPlatformTransferSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPlatformTransferSummariesHTTPResponse, error) {
	rsp, err := c.GetPlatformTransferSummariesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformTransferSummariesHTTPResponse(rsp)
}

func (c *ClientWithResponses) GetPlatformTransferSummariesWithResponse(ctx context.Context, params *GetPlatformTransferSummariesParams, body GetPlatformTransferSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPlatformTransferSummariesHTTPResponse, error) {
	rsp, err := c.GetPlatformTransferSummaries(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformTransferSummariesHTTPResponse(rsp)
}

// DownloadPlatformTransferSheetWithBodyWithResponse request with arbitrary body returning *DownloadPlatformTransferSheetHTTPResponse
func (c *ClientWithResponses) DownloadPlatformTransferSheetWithBodyWithResponse(ctx context.Context, params *DownloadPlatformTransferSheetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadPlatformTransferSheetHTTPResponse, error) {
	rsp, err := c.DownloadPlatformTransferSheetWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPlatformTransferSheetHTTPResponse(rsp)
}

func (c *ClientWithResponses) DownloadPlatformTransferSheetWithResponse(ctx context.Context, params *DownloadPlatformTransferSheetParams, body DownloadPlatformTransferSheetJSONRequestBody, reqEditors ...RequestEditorFn) (*DownloadPlatformTransferSheetHTTPResponse, error) {
	rsp, err := c.DownloadPlatformTransferSheet(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadPlatformTransferSheetHTTPResponse(rsp)
}

// CreatePlatformManualTransferWithBodyWithResponse request with arbitrary body returning *CreatePlatformManualTransferHTTPResponse
func (c *ClientWithResponses) CreatePlatformManualTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformManualTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformManualTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformManualTransferWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformManualTransferHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformManualTransferWithResponse(ctx context.Context, params *CreatePlatformManualTransferParams, body CreatePlatformManualTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformManualTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformManualTransfer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformManualTransferHTTPResponse(rsp)
}

// CreatePlatformOrderTransferWithBodyWithResponse request with arbitrary body returning *CreatePlatformOrderTransferHTTPResponse
func (c *ClientWithResponses) CreatePlatformOrderTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformOrderTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformOrderTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformOrderTransferWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformOrderTransferHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformOrderTransferWithResponse(ctx context.Context, params *CreatePlatformOrderTransferParams, body CreatePlatformOrderTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformOrderTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformOrderTransfer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformOrderTransferHTTPResponse(rsp)
}

// CreatePlatformOrderCancelTransferWithBodyWithResponse request with arbitrary body returning *CreatePlatformOrderCancelTransferHTTPResponse
func (c *ClientWithResponses) CreatePlatformOrderCancelTransferWithBodyWithResponse(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlatformOrderCancelTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformOrderCancelTransferWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformOrderCancelTransferHTTPResponse(rsp)
}

func (c *ClientWithResponses) CreatePlatformOrderCancelTransferWithResponse(ctx context.Context, params *CreatePlatformOrderCancelTransferParams, body CreatePlatformOrderCancelTransferJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlatformOrderCancelTransferHTTPResponse, error) {
	rsp, err := c.CreatePlatformOrderCancelTransfer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlatformOrderCancelTransferHTTPResponse(rsp)
}

// DeletePlatformTransferWithResponse request returning *DeletePlatformTransferHTTPResponse
func (c *ClientWithResponses) DeletePlatformTransferWithResponse(ctx context.Context, id string, params *DeletePlatformTransferParams, reqEditors ...RequestEditorFn) (*DeletePlatformTransferHTTPResponse, error) {
	rsp, err := c.DeletePlatformTransfer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlatformTransferHTTPResponse(rsp)
}

// GetPlatformTransferWithResponse request returning *GetPlatformTransferHTTPResponse
func (c *ClientWithResponses) GetPlatformTransferWithResponse(ctx context.Context, id string, params *GetPlatformTransferParams, reqEditors ...RequestEditorFn) (*GetPlatformTransferHTTPResponse, error) {
	rsp, err := c.GetPlatformTransfer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformTransferHTTPResponse(rsp)
}

// GetPromotionWithResponse request returning *GetPromotionHTTPResponse
func (c *ClientWithResponses) GetPromotionWithResponse(ctx context.Context, promotionId string, reqEditors ...RequestEditorFn) (*GetPromotionHTTPResponse, error) {
	rsp, err := c.GetPromotion(ctx, promotionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPromotionHTTPResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenHTTPResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenHTTPResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenHTTPResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenHTTPResponse, error) {
	rsp, err := c.RefreshToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenHTTPResponse(rsp)
}

// ParseGetB2bBulkTaxInvoiceHTTPResponse parses an HTTP response from a GetB2bBulkTaxInvoiceWithResponse call
func ParseGetB2bBulkTaxInvoiceHTTPResponse(rsp *http.Response) (*GetB2bBulkTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bBulkTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest B2bBulkTaxInvoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bBulkTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bBulkTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bBulkTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bBulkTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bBulkTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bBusinessInfosHTTPResponse parses an HTTP response from a GetB2bBusinessInfosWithResponse call
func ParseGetB2bBusinessInfosHTTPResponse(rsp *http.Response) (*GetB2bBusinessInfosHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bBusinessInfosHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bBusinessInfosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bBusinessInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bBusinessInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bBusinessInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bBusinessInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCreateB2bFileUploadUrlHTTPResponse parses an HTTP response from a CreateB2bFileUploadUrlWithResponse call
func ParseCreateB2bFileUploadUrlHTTPResponse(rsp *http.Response) (*CreateB2bFileUploadUrlHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateB2bFileUploadUrlHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateB2bFileUploadUrlPayload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreateB2bFileUploadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreateB2bFileUploadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreateB2bFileUploadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CreateB2bFileUploadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoicesHTTPResponse parses an HTTP response from a GetB2bTaxInvoicesWithResponse call
func ParseGetB2bTaxInvoicesHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoicesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoicesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bTaxInvoicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoicesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoicesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoicesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoicesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoicesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDownloadB2bTaxInvoicesSheetHTTPResponse parses an HTTP response from a DownloadB2bTaxInvoicesSheetWithResponse call
func ParseDownloadB2bTaxInvoicesSheetHTTPResponse(rsp *http.Response) (*DownloadB2bTaxInvoicesSheetHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadB2bTaxInvoicesSheetHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DownloadB2bTaxInvoicesSheetError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DownloadB2bTaxInvoicesSheetError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDraftB2bTaxInvoiceHTTPResponse parses an HTTP response from a DraftB2bTaxInvoiceWithResponse call
func ParseDraftB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*DraftB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DraftB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DraftB2bTaxInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest DraftB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseUpdateB2bTaxInvoiceDraftHTTPResponse parses an HTTP response from a UpdateB2bTaxInvoiceDraftWithResponse call
func ParseUpdateB2bTaxInvoiceDraftHTTPResponse(rsp *http.Response) (*UpdateB2bTaxInvoiceDraftHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateB2bTaxInvoiceDraftHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateB2bTaxInvoiceDraftResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest UpdateB2bTaxInvoiceDraftError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseIssueB2bTaxInvoiceImmediatelyHTTPResponse parses an HTTP response from a IssueB2bTaxInvoiceImmediatelyWithResponse call
func ParseIssueB2bTaxInvoiceImmediatelyHTTPResponse(rsp *http.Response) (*IssueB2bTaxInvoiceImmediatelyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueB2bTaxInvoiceImmediatelyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueB2bTaxInvoiceImmediatelyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IssueB2bTaxInvoiceImmediatelyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseRequestB2bTaxInvoiceReverseIssuanceHTTPResponse parses an HTTP response from a RequestB2bTaxInvoiceReverseIssuanceWithResponse call
func ParseRequestB2bTaxInvoiceReverseIssuanceHTTPResponse(rsp *http.Response) (*RequestB2bTaxInvoiceReverseIssuanceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestB2bTaxInvoiceReverseIssuanceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestB2bTaxInvoiceReverseIssuanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest RequestB2bTaxInvoiceReverseIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteB2bTaxInvoiceHTTPResponse parses an HTTP response from a DeleteB2bTaxInvoiceWithResponse call
func ParseDeleteB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*DeleteB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteB2bTaxInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DeleteB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DeleteB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DeleteB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DeleteB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest DeleteB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoiceHTTPResponse parses an HTTP response from a GetB2bTaxInvoiceWithResponse call
func ParseGetB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest B2bTaxInvoice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseAttachB2bTaxInvoiceFileHTTPResponse parses an HTTP response from a AttachB2bTaxInvoiceFileWithResponse call
func ParseAttachB2bTaxInvoiceFileHTTPResponse(rsp *http.Response) (*AttachB2bTaxInvoiceFileHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachB2bTaxInvoiceFileHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AttachB2bTaxInvoiceFileError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AttachB2bTaxInvoiceFileError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AttachB2bTaxInvoiceFileError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AttachB2bTaxInvoiceFileError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest AttachB2bTaxInvoiceFileError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoiceAttachmentsHTTPResponse parses an HTTP response from a GetB2bTaxInvoiceAttachmentsWithResponse call
func ParseGetB2bTaxInvoiceAttachmentsHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoiceAttachmentsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoiceAttachmentsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bTaxInvoiceAttachmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoiceAttachmentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoiceAttachmentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoiceAttachmentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoiceAttachmentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoiceAttachmentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteB2bTaxInvoiceAttachmentHTTPResponse parses an HTTP response from a DeleteB2bTaxInvoiceAttachmentWithResponse call
func ParseDeleteB2bTaxInvoiceAttachmentHTTPResponse(rsp *http.Response) (*DeleteB2bTaxInvoiceAttachmentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteB2bTaxInvoiceAttachmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DeleteB2bTaxInvoiceAttachmentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DeleteB2bTaxInvoiceAttachmentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DeleteB2bTaxInvoiceAttachmentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DeleteB2bTaxInvoiceAttachmentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest DeleteB2bTaxInvoiceAttachmentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCancelB2bTaxInvoiceIssuanceHTTPResponse parses an HTTP response from a CancelB2bTaxInvoiceIssuanceWithResponse call
func ParseCancelB2bTaxInvoiceIssuanceHTTPResponse(rsp *http.Response) (*CancelB2bTaxInvoiceIssuanceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelB2bTaxInvoiceIssuanceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelB2bTaxInvoiceIssuanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelB2bTaxInvoiceIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelB2bTaxInvoiceIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelB2bTaxInvoiceIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelB2bTaxInvoiceIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CancelB2bTaxInvoiceIssuanceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCancelB2bTaxInvoiceRequestHTTPResponse parses an HTTP response from a CancelB2bTaxInvoiceRequestWithResponse call
func ParseCancelB2bTaxInvoiceRequestHTTPResponse(rsp *http.Response) (*CancelB2bTaxInvoiceRequestHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelB2bTaxInvoiceRequestHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelB2bTaxInvoiceRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CancelB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseIssueB2bTaxInvoiceHTTPResponse parses an HTTP response from a IssueB2bTaxInvoiceWithResponse call
func ParseIssueB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*IssueB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueB2bTaxInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IssueB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest IssueB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest IssueB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IssueB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IssueB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoicePdfDownloadUrlHTTPResponse parses an HTTP response from a GetB2bTaxInvoicePdfDownloadUrlWithResponse call
func ParseGetB2bTaxInvoicePdfDownloadUrlHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoicePdfDownloadUrlHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoicePdfDownloadUrlHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bTaxInvoicePdfDownloadUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoicePdfDownloadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoicePdfDownloadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoicePdfDownloadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoicePdfDownloadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoicePdfDownloadUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoicePopupUrlHTTPResponse parses an HTTP response from a GetB2bTaxInvoicePopupUrlWithResponse call
func ParseGetB2bTaxInvoicePopupUrlHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoicePopupUrlHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoicePopupUrlHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bTaxInvoicePopupUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoicePopupUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoicePopupUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoicePopupUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoicePopupUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoicePopupUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetB2bTaxInvoicePrintUrlHTTPResponse parses an HTTP response from a GetB2bTaxInvoicePrintUrlWithResponse call
func ParseGetB2bTaxInvoicePrintUrlHTTPResponse(rsp *http.Response) (*GetB2bTaxInvoicePrintUrlHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetB2bTaxInvoicePrintUrlHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetB2bTaxInvoicePrintUrlResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetB2bTaxInvoicePrintUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetB2bTaxInvoicePrintUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetB2bTaxInvoicePrintUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetB2bTaxInvoicePrintUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest GetB2bTaxInvoicePrintUrlError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseRefuseB2bTaxInvoiceRequestHTTPResponse parses an HTTP response from a RefuseB2bTaxInvoiceRequestWithResponse call
func ParseRefuseB2bTaxInvoiceRequestHTTPResponse(rsp *http.Response) (*RefuseB2bTaxInvoiceRequestHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefuseB2bTaxInvoiceRequestHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefuseB2bTaxInvoiceRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RefuseB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RefuseB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RefuseB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RefuseB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest RefuseB2bTaxInvoiceRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseRequestB2bTaxInvoiceHTTPResponse parses an HTTP response from a RequestB2bTaxInvoiceWithResponse call
func ParseRequestB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*RequestB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestB2bTaxInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RequestB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RequestB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RequestB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RequestB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest RequestB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseSendToNtsB2bTaxInvoiceHTTPResponse parses an HTTP response from a SendToNtsB2bTaxInvoiceWithResponse call
func ParseSendToNtsB2bTaxInvoiceHTTPResponse(rsp *http.Response) (*SendToNtsB2bTaxInvoiceHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendToNtsB2bTaxInvoiceHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendToNtsB2bTaxInvoiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SendToNtsB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SendToNtsB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SendToNtsB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SendToNtsB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest SendToNtsB2bTaxInvoiceError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetBankInfosHTTPResponse parses an HTTP response from a GetBankInfosWithResponse call
func ParseGetBankInfosHTTPResponse(rsp *http.Response) (*GetBankInfosHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBankInfosHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBankInfosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetBankInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBillingKeyInfosHTTPResponse parses an HTTP response from a GetBillingKeyInfosWithResponse call
func ParseGetBillingKeyInfosHTTPResponse(rsp *http.Response) (*GetBillingKeyInfosHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingKeyInfosHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBillingKeyInfosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetBillingKeyInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetBillingKeyInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetBillingKeyInfosError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseIssueBillingKeyHTTPResponse parses an HTTP response from a IssueBillingKeyWithResponse call
func ParseIssueBillingKeyHTTPResponse(rsp *http.Response) (*IssueBillingKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueBillingKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueBillingKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IssueBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest IssueBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest IssueBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IssueBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IssueBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseConfirmBillingKeyHTTPResponse parses an HTTP response from a ConfirmBillingKeyWithResponse call
func ParseConfirmBillingKeyHTTPResponse(rsp *http.Response) (*ConfirmBillingKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmBillingKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmedBillingKeySummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ConfirmBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseConfirmBillingKeyIssueAndPayHTTPResponse parses an HTTP response from a ConfirmBillingKeyIssueAndPayWithResponse call
func ParseConfirmBillingKeyIssueAndPayHTTPResponse(rsp *http.Response) (*ConfirmBillingKeyIssueAndPayHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmBillingKeyIssueAndPayHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmedBillingKeyIssueAndPaySummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ConfirmBillingKeyIssueAndPayError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseDeleteBillingKeyHTTPResponse parses an HTTP response from a DeleteBillingKeyWithResponse call
func ParseDeleteBillingKeyHTTPResponse(rsp *http.Response) (*DeleteBillingKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillingKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteBillingKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest DeleteBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetBillingKeyInfoHTTPResponse parses an HTTP response from a GetBillingKeyInfoWithResponse call
func ParseGetBillingKeyInfoHTTPResponse(rsp *http.Response) (*GetBillingKeyInfoHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingKeyInfoHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BillingKeyInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetBillingKeyInfoError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetBillingKeyInfoError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetBillingKeyInfoError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetBillingKeyInfoError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCashReceiptsHTTPResponse parses an HTTP response from a GetCashReceiptsWithResponse call
func ParseGetCashReceiptsHTTPResponse(rsp *http.Response) (*GetCashReceiptsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashReceiptsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCashReceiptsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetCashReceiptsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetCashReceiptsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetCashReceiptsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseIssueCashReceiptHTTPResponse parses an HTTP response from a IssueCashReceiptWithResponse call
func ParseIssueCashReceiptHTTPResponse(rsp *http.Response) (*IssueCashReceiptHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCashReceiptHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueCashReceiptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest IssueCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetIdentityVerificationsHTTPResponse parses an HTTP response from a GetIdentityVerificationsWithResponse call
func ParseGetIdentityVerificationsHTTPResponse(rsp *http.Response) (*GetIdentityVerificationsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityVerificationsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIdentityVerificationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetIdentityVerificationsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetIdentityVerificationsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetIdentityVerificationsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetIdentityVerificationHTTPResponse parses an HTTP response from a GetIdentityVerificationWithResponse call
func ParseGetIdentityVerificationHTTPResponse(rsp *http.Response) (*GetIdentityVerificationHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIdentityVerificationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentityVerification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseConfirmIdentityVerificationHTTPResponse parses an HTTP response from a ConfirmIdentityVerificationWithResponse call
func ParseConfirmIdentityVerificationHTTPResponse(rsp *http.Response) (*ConfirmIdentityVerificationHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmIdentityVerificationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmIdentityVerificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ConfirmIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseResendIdentityVerificationHTTPResponse parses an HTTP response from a ResendIdentityVerificationWithResponse call
func ParseResendIdentityVerificationHTTPResponse(rsp *http.Response) (*ResendIdentityVerificationHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResendIdentityVerificationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResendIdentityVerificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ResendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseSendIdentityVerificationHTTPResponse parses an HTTP response from a SendIdentityVerificationWithResponse call
func ParseSendIdentityVerificationHTTPResponse(rsp *http.Response) (*SendIdentityVerificationHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendIdentityVerificationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendIdentityVerificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest SendIdentityVerificationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetKakaopayPaymentOrderHTTPResponse parses an HTTP response from a GetKakaopayPaymentOrderWithResponse call
func ParseGetKakaopayPaymentOrderHTTPResponse(rsp *http.Response) (*GetKakaopayPaymentOrderHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKakaopayPaymentOrderHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetKakaopayPaymentOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetKakaopayPaymentOrderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetKakaopayPaymentOrderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLoginViaApiSecretHTTPResponse parses an HTTP response from a LoginViaApiSecretWithResponse call
func ParseLoginViaApiSecretHTTPResponse(rsp *http.Response) (*LoginViaApiSecretHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginViaApiSecretHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginViaApiSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest LoginViaApiSecretError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest LoginViaApiSecretError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllPaymentEventsByCursorHTTPResponse parses an HTTP response from a GetAllPaymentEventsByCursorWithResponse call
func ParseGetAllPaymentEventsByCursorHTTPResponse(rsp *http.Response) (*GetAllPaymentEventsByCursorHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllPaymentEventsByCursorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllPaymentEventsByCursorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetAllPaymentEventsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetAllPaymentEventsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetAllPaymentEventsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRevokePaymentSchedulesHTTPResponse parses an HTTP response from a RevokePaymentSchedulesWithResponse call
func ParseRevokePaymentSchedulesHTTPResponse(rsp *http.Response) (*RevokePaymentSchedulesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokePaymentSchedulesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RevokePaymentSchedulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RevokePaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RevokePaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RevokePaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RevokePaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest RevokePaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPaymentSchedulesHTTPResponse parses an HTTP response from a GetPaymentSchedulesWithResponse call
func ParseGetPaymentSchedulesHTTPResponse(rsp *http.Response) (*GetPaymentSchedulesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentSchedulesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPaymentSchedulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPaymentSchedulesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPaymentScheduleHTTPResponse parses an HTTP response from a GetPaymentScheduleWithResponse call
func ParseGetPaymentScheduleHTTPResponse(rsp *http.Response) (*GetPaymentScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaymentSchedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPaymentsHTTPResponse parses an HTTP response from a GetPaymentsWithResponse call
func ParseGetPaymentsHTTPResponse(rsp *http.Response) (*GetPaymentsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPaymentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllPaymentsByCursorHTTPResponse parses an HTTP response from a GetAllPaymentsByCursorWithResponse call
func ParseGetAllPaymentsByCursorHTTPResponse(rsp *http.Response) (*GetAllPaymentsByCursorHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllPaymentsByCursorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllPaymentsByCursorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetAllPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetAllPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetAllPaymentsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPaymentHTTPResponse parses an HTTP response from a GetPaymentWithResponse call
func ParseGetPaymentHTTPResponse(rsp *http.Response) (*GetPaymentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePayWithBillingKeyHTTPResponse parses an HTTP response from a PayWithBillingKeyWithResponse call
func ParsePayWithBillingKeyHTTPResponse(rsp *http.Response) (*PayWithBillingKeyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayWithBillingKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayWithBillingKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest PayWithBillingKeyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCancelPaymentHTTPResponse parses an HTTP response from a CancelPaymentWithResponse call
func ParseCancelPaymentHTTPResponse(rsp *http.Response) (*CancelPaymentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPaymentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelPaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CancelPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseCapturePaymentHTTPResponse parses an HTTP response from a CapturePaymentWithResponse call
func ParseCapturePaymentHTTPResponse(rsp *http.Response) (*CapturePaymentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CapturePaymentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CapturePaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CapturePaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetCashReceiptByPaymentIdHTTPResponse parses an HTTP response from a GetCashReceiptByPaymentIdWithResponse call
func ParseGetCashReceiptByPaymentIdHTTPResponse(rsp *http.Response) (*GetCashReceiptByPaymentIdHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashReceiptByPaymentIdHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashReceipt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelCashReceiptByPaymentIdHTTPResponse parses an HTTP response from a CancelCashReceiptByPaymentIdWithResponse call
func ParseCancelCashReceiptByPaymentIdHTTPResponse(rsp *http.Response) (*CancelCashReceiptByPaymentIdHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelCashReceiptByPaymentIdHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelCashReceiptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CancelCashReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseConfirmPaymentHTTPResponse parses an HTTP response from a ConfirmPaymentWithResponse call
func ParseConfirmPaymentHTTPResponse(rsp *http.Response) (*ConfirmPaymentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmPaymentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmedPaymentSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ConfirmPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseConfirmEscrowHTTPResponse parses an HTTP response from a ConfirmEscrowWithResponse call
func ParseConfirmEscrowHTTPResponse(rsp *http.Response) (*ConfirmEscrowHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfirmEscrowHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfirmEscrowResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ConfirmEscrowError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseModifyEscrowLogisticsHTTPResponse parses an HTTP response from a ModifyEscrowLogisticsWithResponse call
func ParseModifyEscrowLogisticsHTTPResponse(rsp *http.Response) (*ModifyEscrowLogisticsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyEscrowLogisticsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModifyEscrowLogisticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ModifyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseApplyEscrowLogisticsHTTPResponse parses an HTTP response from a ApplyEscrowLogisticsWithResponse call
func ParseApplyEscrowLogisticsHTTPResponse(rsp *http.Response) (*ApplyEscrowLogisticsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplyEscrowLogisticsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplyEscrowLogisticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ApplyEscrowLogisticsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParsePayInstantlyHTTPResponse parses an HTTP response from a PayInstantlyWithResponse call
func ParsePayInstantlyHTTPResponse(rsp *http.Response) (*PayInstantlyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PayInstantlyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayInstantlyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest PayInstantlyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParsePreRegisterPaymentHTTPResponse parses an HTTP response from a PreRegisterPaymentWithResponse call
func ParsePreRegisterPaymentHTTPResponse(rsp *http.Response) (*PreRegisterPaymentHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreRegisterPaymentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreRegisterPaymentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest PreRegisterPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest PreRegisterPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PreRegisterPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest PreRegisterPaymentError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRegisterStoreReceiptHTTPResponse parses an HTTP response from a RegisterStoreReceiptWithResponse call
func ParseRegisterStoreReceiptHTTPResponse(rsp *http.Response) (*RegisterStoreReceiptHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterStoreReceiptHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisterStoreReceiptResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest RegisterStoreReceiptError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseResendWebhookHTTPResponse parses an HTTP response from a ResendWebhookWithResponse call
func ParseResendWebhookHTTPResponse(rsp *http.Response) (*ResendWebhookHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResendWebhookHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResendWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResendWebhookError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResendWebhookError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ResendWebhookError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResendWebhookError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreatePaymentScheduleHTTPResponse parses an HTTP response from a CreatePaymentScheduleWithResponse call
func ParseCreatePaymentScheduleHTTPResponse(rsp *http.Response) (*CreatePaymentScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePaymentScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePaymentScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePaymentScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPaymentTransactionsHTTPResponse parses an HTTP response from a GetPaymentTransactionsWithResponse call
func ParseGetPaymentTransactionsHTTPResponse(rsp *http.Response) (*GetPaymentTransactionsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentTransactionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPaymentTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPaymentTransactionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPaymentTransactionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPaymentTransactionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPaymentTransactionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCloseVirtualAccountHTTPResponse parses an HTTP response from a CloseVirtualAccountWithResponse call
func ParseCloseVirtualAccountHTTPResponse(rsp *http.Response) (*CloseVirtualAccountHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseVirtualAccountHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloseVirtualAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest CloseVirtualAccountError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseGetPlatformAccountTransfersHTTPResponse parses an HTTP response from a GetPlatformAccountTransfersWithResponse call
func ParseGetPlatformAccountTransfersHTTPResponse(rsp *http.Response) (*GetPlatformAccountTransfersHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAccountTransfersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformAccountTransfersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformAdditionalFeePoliciesHTTPResponse parses an HTTP response from a GetPlatformAdditionalFeePoliciesWithResponse call
func ParseGetPlatformAdditionalFeePoliciesHTTPResponse(rsp *http.Response) (*GetPlatformAdditionalFeePoliciesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAdditionalFeePoliciesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformAdditionalFeePoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformAdditionalFeePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformAdditionalFeePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformAdditionalFeePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreatePlatformAdditionalFeePolicyHTTPResponse parses an HTTP response from a CreatePlatformAdditionalFeePolicyWithResponse call
func ParseCreatePlatformAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*CreatePlatformAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPlatformAdditionalFeePolicyHTTPResponse parses an HTTP response from a GetPlatformAdditionalFeePolicyWithResponse call
func ParseGetPlatformAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*GetPlatformAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformAdditionalFeePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePlatformAdditionalFeePolicyHTTPResponse parses an HTTP response from a UpdatePlatformAdditionalFeePolicyWithResponse call
func ParseUpdatePlatformAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*UpdatePlatformAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlatformAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest UpdatePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseArchivePlatformAdditionalFeePolicyHTTPResponse parses an HTTP response from a ArchivePlatformAdditionalFeePolicyWithResponse call
func ParseArchivePlatformAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*ArchivePlatformAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlatformAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchivePlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ArchivePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ArchivePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ArchivePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ArchivePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ArchivePlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRecoverPlatformAdditionalFeePolicyHTTPResponse parses an HTTP response from a RecoverPlatformAdditionalFeePolicyWithResponse call
func ParseRecoverPlatformAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*RecoverPlatformAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverPlatformAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverPlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoverPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RecoverPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RecoverPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RecoverPlatformAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelPlatformAdditionalFeePolicyScheduleHTTPResponse parses an HTTP response from a CancelPlatformAdditionalFeePolicyScheduleWithResponse call
func ParseCancelPlatformAdditionalFeePolicyScheduleHTTPResponse(rsp *http.Response) (*CancelPlatformAdditionalFeePolicyScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPlatformAdditionalFeePolicyScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelPlatformAdditionalFeePolicyScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformAdditionalFeePolicyScheduleHTTPResponse parses an HTTP response from a GetPlatformAdditionalFeePolicyScheduleWithResponse call
func ParseGetPlatformAdditionalFeePolicyScheduleHTTPResponse(rsp *http.Response) (*GetPlatformAdditionalFeePolicyScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAdditionalFeePolicyScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformAdditionalFeePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformAdditionalFeePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScheduleAdditionalFeePolicyHTTPResponse parses an HTTP response from a ScheduleAdditionalFeePolicyWithResponse call
func ParseScheduleAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*ScheduleAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchedulePlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ScheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ScheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRescheduleAdditionalFeePolicyHTTPResponse parses an HTTP response from a RescheduleAdditionalFeePolicyWithResponse call
func ParseRescheduleAdditionalFeePolicyHTTPResponse(rsp *http.Response) (*RescheduleAdditionalFeePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RescheduleAdditionalFeePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReschedulePlatformAdditionalFeePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RescheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RescheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RescheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RescheduleAdditionalFeePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformAccountHolderHTTPResponse parses an HTTP response from a GetPlatformAccountHolderWithResponse call
func ParseGetPlatformAccountHolderHTTPResponse(rsp *http.Response) (*GetPlatformAccountHolderHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAccountHolderHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformAccountHolder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformAccountHolderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformAccountHolderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformAccountHolderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPlatformAccountHolderError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPlatformBulkAccountTransfersHTTPResponse parses an HTTP response from a GetPlatformBulkAccountTransfersWithResponse call
func ParseGetPlatformBulkAccountTransfersHTTPResponse(rsp *http.Response) (*GetPlatformBulkAccountTransfersHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformBulkAccountTransfersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformBulkAccountTransfersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformBulkAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformBulkAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformBulkAccountTransfersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformBulkPayoutsHTTPResponse parses an HTTP response from a GetPlatformBulkPayoutsWithResponse call
func ParseGetPlatformBulkPayoutsHTTPResponse(rsp *http.Response) (*GetPlatformBulkPayoutsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformBulkPayoutsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformBulkPayoutsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformBulkPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformBulkPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformBulkPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformCompanyStateHTTPResponse parses an HTTP response from a GetPlatformCompanyStateWithResponse call
func ParseGetPlatformCompanyStateHTTPResponse(rsp *http.Response) (*GetPlatformCompanyStateHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformCompanyStateHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformCompanyStatePayload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformCompanyStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformCompanyStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformCompanyStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformCompanyStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest GetPlatformCompanyStateError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPlatformContractsHTTPResponse parses an HTTP response from a GetPlatformContractsWithResponse call
func ParseGetPlatformContractsHTTPResponse(rsp *http.Response) (*GetPlatformContractsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformContractsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformContractsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformContractsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformContractsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformContractsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreatePlatformContractHTTPResponse parses an HTTP response from a CreatePlatformContractWithResponse call
func ParseCreatePlatformContractHTTPResponse(rsp *http.Response) (*CreatePlatformContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPlatformContractHTTPResponse parses an HTTP response from a GetPlatformContractWithResponse call
func ParseGetPlatformContractHTTPResponse(rsp *http.Response) (*GetPlatformContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformContract
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePlatformContractHTTPResponse parses an HTTP response from a UpdatePlatformContractWithResponse call
func ParseUpdatePlatformContractHTTPResponse(rsp *http.Response) (*UpdatePlatformContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlatformContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest UpdatePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseArchivePlatformContractHTTPResponse parses an HTTP response from a ArchivePlatformContractWithResponse call
func ParseArchivePlatformContractHTTPResponse(rsp *http.Response) (*ArchivePlatformContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlatformContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchivePlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ArchivePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ArchivePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ArchivePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ArchivePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ArchivePlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRecoverPlatformContractHTTPResponse parses an HTTP response from a RecoverPlatformContractWithResponse call
func ParseRecoverPlatformContractHTTPResponse(rsp *http.Response) (*RecoverPlatformContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverPlatformContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverPlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoverPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RecoverPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RecoverPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RecoverPlatformContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelPlatformContractScheduleHTTPResponse parses an HTTP response from a CancelPlatformContractScheduleWithResponse call
func ParseCancelPlatformContractScheduleHTTPResponse(rsp *http.Response) (*CancelPlatformContractScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPlatformContractScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelPlatformContractScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformContractScheduleHTTPResponse parses an HTTP response from a GetPlatformContractScheduleWithResponse call
func ParseGetPlatformContractScheduleHTTPResponse(rsp *http.Response) (*GetPlatformContractScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformContractScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformContract
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformContractScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScheduleContractHTTPResponse parses an HTTP response from a ScheduleContractWithResponse call
func ParseScheduleContractHTTPResponse(rsp *http.Response) (*ScheduleContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchedulePlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ScheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ScheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRescheduleContractHTTPResponse parses an HTTP response from a RescheduleContractWithResponse call
func ParseRescheduleContractHTTPResponse(rsp *http.Response) (*RescheduleContractHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RescheduleContractHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReschedulePlatformContractResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RescheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RescheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RescheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RescheduleContractError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformDiscountSharePoliciesHTTPResponse parses an HTTP response from a GetPlatformDiscountSharePoliciesWithResponse call
func ParseGetPlatformDiscountSharePoliciesHTTPResponse(rsp *http.Response) (*GetPlatformDiscountSharePoliciesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDiscountSharePoliciesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformDiscountSharePoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformDiscountSharePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformDiscountSharePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformDiscountSharePoliciesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreatePlatformDiscountSharePolicyHTTPResponse parses an HTTP response from a CreatePlatformDiscountSharePolicyWithResponse call
func ParseCreatePlatformDiscountSharePolicyHTTPResponse(rsp *http.Response) (*CreatePlatformDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPlatformDiscountSharePolicyHTTPResponse parses an HTTP response from a GetPlatformDiscountSharePolicyWithResponse call
func ParseGetPlatformDiscountSharePolicyHTTPResponse(rsp *http.Response) (*GetPlatformDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformDiscountSharePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePlatformDiscountSharePolicyHTTPResponse parses an HTTP response from a UpdatePlatformDiscountSharePolicyWithResponse call
func ParseUpdatePlatformDiscountSharePolicyHTTPResponse(rsp *http.Response) (*UpdatePlatformDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlatformDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest UpdatePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseArchivePlatformDiscountSharePolicyHTTPResponse parses an HTTP response from a ArchivePlatformDiscountSharePolicyWithResponse call
func ParseArchivePlatformDiscountSharePolicyHTTPResponse(rsp *http.Response) (*ArchivePlatformDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlatformDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchivePlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ArchivePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ArchivePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ArchivePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ArchivePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ArchivePlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRecoverPlatformDiscountSharePolicyHTTPResponse parses an HTTP response from a RecoverPlatformDiscountSharePolicyWithResponse call
func ParseRecoverPlatformDiscountSharePolicyHTTPResponse(rsp *http.Response) (*RecoverPlatformDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverPlatformDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverPlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoverPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RecoverPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RecoverPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RecoverPlatformDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelPlatformDiscountSharePolicyScheduleHTTPResponse parses an HTTP response from a CancelPlatformDiscountSharePolicyScheduleWithResponse call
func ParseCancelPlatformDiscountSharePolicyScheduleHTTPResponse(rsp *http.Response) (*CancelPlatformDiscountSharePolicyScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPlatformDiscountSharePolicyScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelPlatformDiscountSharePolicyScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformDiscountSharePolicyScheduleHTTPResponse parses an HTTP response from a GetPlatformDiscountSharePolicyScheduleWithResponse call
func ParseGetPlatformDiscountSharePolicyScheduleHTTPResponse(rsp *http.Response) (*GetPlatformDiscountSharePolicyScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDiscountSharePolicyScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformDiscountSharePolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformDiscountSharePolicyScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScheduleDiscountSharePolicyHTTPResponse parses an HTTP response from a ScheduleDiscountSharePolicyWithResponse call
func ParseScheduleDiscountSharePolicyHTTPResponse(rsp *http.Response) (*ScheduleDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScheduleDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchedulePlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ScheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ScheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRescheduleDiscountSharePolicyHTTPResponse parses an HTTP response from a RescheduleDiscountSharePolicyWithResponse call
func ParseRescheduleDiscountSharePolicyHTTPResponse(rsp *http.Response) (*RescheduleDiscountSharePolicyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RescheduleDiscountSharePolicyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReschedulePlatformDiscountSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RescheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RescheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RescheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RescheduleDiscountSharePolicyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformDiscountSharePolicyFilterOptionsHTTPResponse parses an HTTP response from a GetPlatformDiscountSharePolicyFilterOptionsWithResponse call
func ParseGetPlatformDiscountSharePolicyFilterOptionsHTTPResponse(rsp *http.Response) (*GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformDiscountSharePolicyFilterOptionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformDiscountSharePolicyFilterOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformDiscountSharePolicyFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformDiscountSharePolicyFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformDiscountSharePolicyFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformPartnerFilterOptionsHTTPResponse parses an HTTP response from a GetPlatformPartnerFilterOptionsWithResponse call
func ParseGetPlatformPartnerFilterOptionsHTTPResponse(rsp *http.Response) (*GetPlatformPartnerFilterOptionsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPartnerFilterOptionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformPartnerFilterOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPartnerFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPartnerFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPartnerFilterOptionsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformPartnerSettlementsHTTPResponse parses an HTTP response from a GetPlatformPartnerSettlementsWithResponse call
func ParseGetPlatformPartnerSettlementsHTTPResponse(rsp *http.Response) (*GetPlatformPartnerSettlementsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPartnerSettlementsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformPartnerSettlementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPartnerSettlementsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPartnerSettlementsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPartnerSettlementsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformPartnersHTTPResponse parses an HTTP response from a GetPlatformPartnersWithResponse call
func ParseGetPlatformPartnersHTTPResponse(rsp *http.Response) (*GetPlatformPartnersHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPartnersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformPartnersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreatePlatformPartnerHTTPResponse parses an HTTP response from a CreatePlatformPartnerWithResponse call
func ParseCreatePlatformPartnerHTTPResponse(rsp *http.Response) (*CreatePlatformPartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformPartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCreatePlatformPartnersHTTPResponse parses an HTTP response from a CreatePlatformPartnersWithResponse call
func ParseCreatePlatformPartnersHTTPResponse(rsp *http.Response) (*CreatePlatformPartnersHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformPartnersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePlatformPartnersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseConnectBulkPartnerMemberCompanyHTTPResponse parses an HTTP response from a ConnectBulkPartnerMemberCompanyWithResponse call
func ParseConnectBulkPartnerMemberCompanyHTTPResponse(rsp *http.Response) (*ConnectBulkPartnerMemberCompanyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectBulkPartnerMemberCompanyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectBulkPartnerMemberCompanyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseConnectPartnerMemberCompanyHTTPResponse parses an HTTP response from a ConnectPartnerMemberCompanyWithResponse call
func ParseConnectPartnerMemberCompanyHTTPResponse(rsp *http.Response) (*ConnectPartnerMemberCompanyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectPartnerMemberCompanyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectPartnerMemberCompanyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ConnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDisconnectBulkPartnerMemberCompanyHTTPResponse parses an HTTP response from a DisconnectBulkPartnerMemberCompanyWithResponse call
func ParseDisconnectBulkPartnerMemberCompanyHTTPResponse(rsp *http.Response) (*DisconnectBulkPartnerMemberCompanyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectBulkPartnerMemberCompanyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DisconnectBulkPartnerMemberCompanyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DisconnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DisconnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DisconnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DisconnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest DisconnectBulkPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDisconnectPartnerMemberCompanyHTTPResponse parses an HTTP response from a DisconnectPartnerMemberCompanyWithResponse call
func ParseDisconnectPartnerMemberCompanyHTTPResponse(rsp *http.Response) (*DisconnectPartnerMemberCompanyHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectPartnerMemberCompanyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DisconnectPartnerMemberCompanyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest DisconnectPartnerMemberCompanyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSchedulePlatformPartnersHTTPResponse parses an HTTP response from a SchedulePlatformPartnersWithResponse call
func ParseSchedulePlatformPartnersHTTPResponse(rsp *http.Response) (*SchedulePlatformPartnersHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchedulePlatformPartnersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchedulePlatformPartnersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SchedulePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SchedulePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SchedulePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SchedulePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest SchedulePlatformPartnersError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPlatformPartnerHTTPResponse parses an HTTP response from a GetPlatformPartnerWithResponse call
func ParseGetPlatformPartnerHTTPResponse(rsp *http.Response) (*GetPlatformPartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformPartner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePlatformPartnerHTTPResponse parses an HTTP response from a UpdatePlatformPartnerWithResponse call
func ParseUpdatePlatformPartnerHTTPResponse(rsp *http.Response) (*UpdatePlatformPartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlatformPartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest UpdatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest UpdatePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseArchivePlatformPartnerHTTPResponse parses an HTTP response from a ArchivePlatformPartnerWithResponse call
func ParseArchivePlatformPartnerHTTPResponse(rsp *http.Response) (*ArchivePlatformPartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlatformPartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchivePlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ArchivePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ArchivePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ArchivePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ArchivePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ArchivePlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRecoverPlatformPartnerHTTPResponse parses an HTTP response from a RecoverPlatformPartnerWithResponse call
func ParseRecoverPlatformPartnerHTTPResponse(rsp *http.Response) (*RecoverPlatformPartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverPlatformPartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecoverPlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RecoverPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RecoverPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest RecoverPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RecoverPlatformPartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCancelPlatformPartnerScheduleHTTPResponse parses an HTTP response from a CancelPlatformPartnerScheduleWithResponse call
func ParseCancelPlatformPartnerScheduleHTTPResponse(rsp *http.Response) (*CancelPlatformPartnerScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelPlatformPartnerScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelPlatformPartnerScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CancelPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CancelPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CancelPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CancelPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformPartnerScheduleHTTPResponse parses an HTTP response from a GetPlatformPartnerScheduleWithResponse call
func ParseGetPlatformPartnerScheduleHTTPResponse(rsp *http.Response) (*GetPlatformPartnerScheduleHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPartnerScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformPartner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformPartnerScheduleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSchedulePartnerHTTPResponse parses an HTTP response from a SchedulePartnerWithResponse call
func ParseSchedulePartnerHTTPResponse(rsp *http.Response) (*SchedulePartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchedulePartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchedulePlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SchedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SchedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SchedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest SchedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest SchedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseReschedulePartnerHTTPResponse parses an HTTP response from a ReschedulePartnerWithResponse call
func ParseReschedulePartnerHTTPResponse(rsp *http.Response) (*ReschedulePartnerHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReschedulePartnerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReschedulePlatformPartnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ReschedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ReschedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ReschedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ReschedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ReschedulePartnerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetPlatformPayoutsHTTPResponse parses an HTTP response from a GetPlatformPayoutsWithResponse call
func ParseGetPlatformPayoutsHTTPResponse(rsp *http.Response) (*GetPlatformPayoutsHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformPayoutsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformPayoutsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformPayoutsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformSettingHTTPResponse parses an HTTP response from a GetPlatformSettingWithResponse call
func ParseGetPlatformSettingHTTPResponse(rsp *http.Response) (*GetPlatformSettingHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformSettingHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformSetting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdatePlatformSettingHTTPResponse parses an HTTP response from a UpdatePlatformSettingWithResponse call
func ParseUpdatePlatformSettingHTTPResponse(rsp *http.Response) (*UpdatePlatformSettingHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlatformSettingHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePlatformSettingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UpdatePlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UpdatePlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest UpdatePlatformSettingError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetPlatformTransferSummariesHTTPResponse parses an HTTP response from a GetPlatformTransferSummariesWithResponse call
func ParseGetPlatformTransferSummariesHTTPResponse(rsp *http.Response) (*GetPlatformTransferSummariesHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformTransferSummariesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPlatformTransferSummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformTransferSummariesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformTransferSummariesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformTransferSummariesError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDownloadPlatformTransferSheetHTTPResponse parses an HTTP response from a DownloadPlatformTransferSheetWithResponse call
func ParseDownloadPlatformTransferSheetHTTPResponse(rsp *http.Response) (*DownloadPlatformTransferSheetHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadPlatformTransferSheetHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DownloadPlatformTransferSheetError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DownloadPlatformTransferSheetError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreatePlatformManualTransferHTTPResponse parses an HTTP response from a CreatePlatformManualTransferWithResponse call
func ParseCreatePlatformManualTransferHTTPResponse(rsp *http.Response) (*CreatePlatformManualTransferHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformManualTransferHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateManualTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformManualTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformManualTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformManualTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePlatformManualTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreatePlatformOrderTransferHTTPResponse parses an HTTP response from a CreatePlatformOrderTransferWithResponse call
func ParseCreatePlatformOrderTransferHTTPResponse(rsp *http.Response) (*CreatePlatformOrderTransferHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformOrderTransferHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrderTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformOrderTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformOrderTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformOrderTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePlatformOrderTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformOrderTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCreatePlatformOrderCancelTransferHTTPResponse parses an HTTP response from a CreatePlatformOrderCancelTransferWithResponse call
func ParseCreatePlatformOrderCancelTransferHTTPResponse(rsp *http.Response) (*CreatePlatformOrderCancelTransferHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlatformOrderCancelTransferHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrderCancelTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CreatePlatformOrderCancelTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CreatePlatformOrderCancelTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CreatePlatformOrderCancelTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CreatePlatformOrderCancelTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest CreatePlatformOrderCancelTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeletePlatformTransferHTTPResponse parses an HTTP response from a DeletePlatformTransferWithResponse call
func ParseDeletePlatformTransferHTTPResponse(rsp *http.Response) (*DeletePlatformTransferHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlatformTransferHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePlatformTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DeletePlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest DeletePlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest DeletePlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DeletePlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlatformTransferHTTPResponse parses an HTTP response from a GetPlatformTransferWithResponse call
func ParseGetPlatformTransferHTTPResponse(rsp *http.Response) (*GetPlatformTransferHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformTransferHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatformTransfer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPlatformTransferError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPromotionHTTPResponse parses an HTTP response from a GetPromotionWithResponse call
func ParseGetPromotionHTTPResponse(rsp *http.Response) (*GetPromotionHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPromotionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Promotion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetPromotionError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest GetPromotionError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GetPromotionError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetPromotionError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRefreshTokenHTTPResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenHTTPResponse(rsp *http.Response) (*RefreshTokenHTTPResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RefreshTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RefreshTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
